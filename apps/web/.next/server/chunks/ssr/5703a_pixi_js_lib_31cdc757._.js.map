{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/app/ResizePlugin.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/app/ResizePlugin.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link ResizePlugin}.\n * These options control how your application handles window and element resizing.\n * @example\n * ```ts\n * // Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Auto-resize to container element\n * await app.init({ resizeTo: document.querySelector('#game') });\n * ```\n * @category app\n * @standard\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @example\n     * ```ts\n     * const app = new Application();\n     * await app.init({\n     *     resizeTo: window, // Resize to the entire window\n     *     // or\n     *     resizeTo: document.querySelector('#game-container'), // Resize to a specific element\n     *     // or\n     *     resizeTo: null, // Disable auto-resize\n     * });\n     * ```\n     * @default null\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality. This plugin handles automatic\n * and manual resizing of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `resizeTo`: Set an element to automatically resize to\n * - `resize`: Manually trigger a resize\n * - `queueResize`: Queue a resize for the next animation frame\n * - `cancelResize`: Cancel a queued resize\n * @example\n * ```ts\n * import { Application, ResizePlugin } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Example 2: Auto-resize to specific element\n * const container = document.querySelector('#game-container');\n * await app.init({ resizeTo: container });\n *\n * // Example 3: Change resize target at runtime\n * app.resizeTo = window;                    // Enable auto-resize to window\n * app.resizeTo = null;                      // Disable auto-resize\n * ```\n * @category app\n * @standard\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n    /** @internal */\n    public static resizeTo: Window | HTMLElement;\n    /** @internal */\n    public static resize: () => void;\n    /** @internal */\n    public static renderer: ResizeableRenderer;\n    /** @internal */\n    public static queueResize: () => void;\n    /** @internal */\n    public static render: () => void;\n    /** @internal */\n    private static _resizeId: number;\n    /** @internal */\n    private static _resizeTo: Window | HTMLElement;\n    /** @internal */\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAuEO,MAAM,YACb,CAAA;IAAA;;;;GAAA,GAyBI,OAAc,KAAK,OACnB,EAAA;QACW,MAAA,CAAA,cAAA,CAAe,IAAA,EAAM,UAAA,EACxB;YACI,KAAI,GACJ,EAAA;gBACe,UAAA,CAAA,mBAAA,CAAoB,QAAU,EAAA,IAAA,CAAK,WAAW,CAAA,CAAA;gBACzD,IAAA,CAAK,SAAY,GAAA,GAAA,CAAA;gBACjB,IAAI,GACJ,EAAA;oBACe,UAAA,CAAA,gBAAA,CAAiB,QAAU,EAAA,IAAA,CAAK,WAAW,CAAA,CAAA;oBACtD,IAAA,CAAK,MAAO,EAAA,CAAA;gBAAA,CAChB;YAAA,CACJ;YACA,GACA,GAAA;gBACI,OAAO,IAAK,CAAA,SAAA,CAAA;YAAA,CAChB;QAAA,CACJ;QAEJ,IAAA,CAAK,WAAA,GAAc,MACnB;YACQ,IAAA,CAAC,IAAA,CAAK,SACV,EAAA;gBACI,OAAA;YAAA,CACJ;YAEA,IAAA,CAAK,aAAc,EAAA,CAAA;YAGnB,IAAA,CAAK,SAAY,GAAA,qBAAA,CAAsB,IAAM,IAAA,CAAK,MAAA,EAAQ,CAAA,CAAA;QAAA,CAC9D,CAAA;QAEA,IAAA,CAAK,aAAA,GAAgB,MACrB;YACI,IAAI,IAAA,CAAK,SACT,EAAA;gBACI,oBAAA,CAAqB,IAAA,CAAK,SAAS,CAAA,CAAA;gBACnC,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;YAAA,CACrB;QAAA,CACJ,CAAA;QAEA,IAAA,CAAK,MAAA,GAAS,MACd;YACQ,IAAA,CAAC,IAAA,CAAK,SACV,EAAA;gBACI,OAAA;YAAA,CACJ;YAGA,IAAA,CAAK,aAAc,EAAA,CAAA;YAEf,IAAA,KAAA,CAAA;YACA,IAAA,MAAA,CAAA;YAGA,IAAA,IAAA,CAAK,SAAc,KAAA,UAAA,CAAW,MAClC,EAAA;gBACI,KAAA,GAAQ,UAAW,CAAA,UAAA,CAAA;gBACnB,MAAA,GAAS,UAAW,CAAA,WAAA,CAAA;YAAA,CAIxB,MAAA;gBACI,MAAM,EAAE,WAAA,EAAa,YAAa,EAAA,GAAI,IAAK,CAAA,SAAA,CAAA;gBAEnC,KAAA,GAAA,WAAA,CAAA;gBACC,MAAA,GAAA,YAAA,CAAA;YAAA,CACb;YAEK,IAAA,CAAA,QAAA,CAAS,MAAO,CAAA,KAAA,EAAO,MAAM,CAAA,CAAA;YAClC,IAAA,CAAK,MAAO,EAAA,CAAA;QAAA,CAChB,CAAA;QAGA,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;QACjB,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;QACZ,IAAA,CAAA,QAAA,GAAW,QAAQ,QAAY,IAAA,IAAA,CAAA;IAAA,CACxC;IAAA;;;GAAA,GAMA,OAAc,OACd,GAAA;QACe,UAAA,CAAA,mBAAA,CAAoB,QAAU,EAAA,IAAA,CAAK,WAAW,CAAA,CAAA;QACzD,IAAA,CAAK,aAAc,EAAA,CAAA;QACnB,IAAA,CAAK,aAAgB,GAAA,IAAA,CAAA;QACrB,IAAA,CAAK,WAAc,GAAA,IAAA,CAAA;QACnB,IAAA,CAAK,QAAW,GAAA,IAAA,CAAA;QAChB,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;IAAA,CAClB;AACJ,CAAA;AAAA,YAAA,GAvHa,YAAA,CAGK,SAAA,GAA+B,uOAAc,CAAA,WAAA","debugId":null}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/app/TickerPlugin.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/app/TickerPlugin.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link TickerPlugin}.\n * These options control the animation loop and update cycle of your PixiJS application.\n * @example\n * ```ts\n * import { Application } from 'pixi.js';\n *\n * // Basic setup with default options\n * const app = new Application();\n * await app.init({\n *     autoStart: true,     // Start animation loop automatically\n *     sharedTicker: false  // Use dedicated ticker instance\n * });\n *\n * // Advanced setup with shared ticker\n * const app2 = new Application();\n * await app2.init({\n *     autoStart: false,    // Don't start automatically\n *     sharedTicker: true   // Use global shared ticker\n * });\n *\n * // Start animation when ready\n * app2.start();\n * ```\n * @remarks\n * The ticker is the heart of your application's animation system. It:\n * - Manages the render loop\n * - Provides accurate timing information\n * - Handles frame-based updates\n * - Supports priority-based execution order\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For update priority constants\n * @category app\n * @standard\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Controls whether the animation loop starts automatically after initialization.\n     * > [!IMPORTANT]\n     * > Setting this to `false` does NOT stop the shared ticker even if `sharedTicker` is `true`.\n     * > You must stop the shared ticker manually if needed.\n     * @example\n     * ```ts\n     * // Auto-start (default behavior)\n     * await app.init({ autoStart: true });\n     *\n     * // Manual start\n     * await app.init({ autoStart: false });\n     * app.start(); // Start when ready\n     * ```\n     * @default true\n     */\n    autoStart?: boolean;\n\n    /**\n     * Controls whether to use the shared global ticker or create a new instance.\n     *\n     * The shared ticker is useful when you have multiple instances that should sync their updates.\n     * However, it has some limitations regarding update order control.\n     *\n     * Update Order:\n     * 1. System ticker (always runs first)\n     * 2. Shared ticker (if enabled)\n     * 3. App ticker (if using own ticker)\n     * @example\n     * ```ts\n     * // Use shared ticker (global instance)\n     * await app.init({ sharedTicker: true });\n     *\n     * // Use dedicated ticker (default)\n     * await app.init({ sharedTicker: false });\n     *\n     * // Access ticker properties\n     * console.log(app.ticker.FPS);    // Current FPS\n     * console.log(app.ticker.deltaMS); // MS since last update\n     * ```\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link Ticker} functionality. This plugin manages the\n * animation loop and update cycle of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `ticker`: Access to the application's ticker\n * - `start`: Start the animation loop\n * - `stop`: Stop the animation loop\n * @example\n * ```ts\n * import { Application, TickerPlugin, extensions } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Basic ticker usage (default autoStart)\n * await app.init({ autoStart: true });      // Starts ticker automatically\n *\n * // Example 2: Manual ticker control\n * await app.init({ autoStart: false });     // Don't start automatically\n * app.start();                              // Start manually\n * app.stop();                               // Stop manually\n *\n * // Example 3: Add custom update logic\n * app.ticker.add((ticker) => {\n *     // Run every frame, delta is the time since last update\n *     sprite.rotation += 0.1 * ticker.deltaTime;\n * });\n *\n * // Example 4: Control update priority\n * import { UPDATE_PRIORITY } from 'pixi.js';\n *\n * app.ticker.add(\n *     (ticker) => {\n *         // Run before normal priority updates\n *     },\n *     null,\n *     UPDATE_PRIORITY.HIGH\n * );\n *\n * // Example 5: One-time update\n * app.ticker.addOnce(() => {\n *     console.log('Runs next frame only');\n * });\n * ```\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For priority constants\n * @category app\n * @standard\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    /** @internal */\n    public static start: () => void;\n    /** @internal */\n    public static stop: () => void;\n    /** @internal */\n    private static _ticker: Ticker;\n    /** @internal */\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        this._ticker = null;\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AA0IO,MAAM,YACb,CAAA;IAAA;;;;GAAA,GAkBI,OAAc,KAAK,OACnB,EAAA;QAEI,OAAA,GAAU,OAAO,MAAO,CAAA;YACpB,SAAW,EAAA,IAAA;YACX,YAAc,EAAA,KAAA;QAAA,GACf,OAAO,CAAA,CAAA;QAGH,MAAA,CAAA,cAAA,CAAe,IAAA,EAAM,QAAA,EACxB;YACI,KAAI,MACJ,EAAA;gBACI,IAAI,IAAA,CAAK,OACT,EAAA;oBACI,IAAA,CAAK,OAAQ,CAAA,MAAA,CAAO,IAAK,CAAA,MAAA,EAAQ,IAAI,CAAA,CAAA;gBAAA,CACzC;gBACA,IAAA,CAAK,OAAU,GAAA,MAAA,CAAA;gBACf,IAAI,MACJ,EAAA;oBACI,MAAA,CAAO,GAAI,CAAA,IAAA,CAAK,MAAQ,EAAA,IAAA,EAAM,gOAAA,CAAgB,GAAG,CAAA,CAAA;gBAAA,CACrD;YAAA,CACJ;YACA,GACA,GAAA;gBACI,OAAO,IAAK,CAAA,OAAA,CAAA;YAAA,CAChB;QAAA,CACJ;QAEJ,IAAA,CAAK,IAAA,GAAO,MACZ;YACI,IAAA,CAAK,OAAA,CAAQ,IAAK,EAAA,CAAA;QAAA,CACtB,CAAA;QAEA,IAAA,CAAK,KAAA,GAAQ,MACb;YACI,IAAA,CAAK,OAAA,CAAQ,KAAM,EAAA,CAAA;QAAA,CACvB,CAAA;QAEA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;QACf,IAAA,CAAK,MAAA,GAAS,OAAQ,CAAA,YAAA,GAAe,wNAAO,CAAA,MAAA,GAAS,IAAI,wNAAO,EAAA,CAAA;QAGhE,IAAI,QAAQ,SACZ,EAAA;YACI,IAAA,CAAK,KAAM,EAAA,CAAA;QAAA,CACf;IAAA,CACJ;IAAA;;;GAAA,GAMA,OAAc,OACd,GAAA;QACI,IAAI,IAAA,CAAK,OACT,EAAA;YACI,MAAM,YAAY,IAAK,CAAA,OAAA,CAAA;YAEvB,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;YACd,SAAA,CAAU,OAAQ,EAAA,CAAA;QAAA,CACtB;IAAA,CACJ;AACJ,CAAA;AAAA,YAAA,GAlFa,YAAA,CAGK,SAAA,GAA+B,uOAAc,CAAA,WAAA","debugId":null}},
    {"offset": {"line": 149, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/app/init.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/app/init.ts"],"sourcesContent":["import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n"],"names":[],"mappings":";;;;;;;;AAIA,oOAAA,CAAW,GAAA,CAAI,iOAAY,CAAA,CAAA;AAC3B,oOAAA,CAAW,GAAA,CAAI,iOAAY,CAAA","debugId":null}},
    {"offset": {"line": 163, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts"],"sourcesContent":["import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link GlStateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @category rendering\n * @advanced\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    /** @internal */\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n"],"names":[],"mappings":";;;;;AAEA,MAAM,YAAe,GAAA;IACjB,MAAQ,EAAA,CAAA;IACR,GAAK,EAAA,CAAA;IACL,QAAU,EAAA,CAAA;IACV,MAAQ,EAAA,CAAA;IACR,OAAS,EAAA,CAAA;IACT,KAAO,EAAA,CAAA;IACP,YAAc,EAAA,CAAA;IACd,SAAW,EAAA,CAAA;IACX,YAAc,EAAA,CAAA;IACd,GAAK,EAAA,CAAA;IACL,GAAK,EAAA,EAAA;AACT,CAAA,CAAA;AACA,MAAM,KAAQ,GAAA,CAAA,CAAA;AACd,MAAM,MAAS,GAAA,CAAA,CAAA;AACf,MAAM,OAAU,GAAA,CAAA,CAAA;AAChB,MAAM,UAAa,GAAA,CAAA,CAAA;AACnB,MAAM,OAAU,GAAA,CAAA,CAAA;AAChB,MAAM,UAAa,GAAA,CAAA,CAAA;AAUZ,MAAM,MAAA,GAAN,MAAM,MACb,CAAA;IAYI,WACA,EAAA;QACI,IAAA,CAAK,IAAO,GAAA,CAAA,CAAA;QAEZ,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;QACjB,IAAA,CAAK,aAAgB,GAAA,CAAA,CAAA;QAErB,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAA;QACb,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;IAAA,CACrB;IAAA;;;GAAA,GAMA,IAAI,KACJ,GAAA;QACI,OAAO,CAAC,CAAA,CAAE,IAAK,CAAA,IAAA,GAAQ,CAAK,IAAA,KAAA,CAAA,CAAA;IAAA,CAChC;IAEA,IAAI,MAAM,KACV,EAAA;QACI,IAAI,CAAC,CAAA,CAAE,IAAA,CAAK,IAAQ,GAAA,CAAA,IAAK,KAAA,MAAY,KACrC,EAAA;YACI,IAAA,CAAK,IAAA,IAAS,CAAK,IAAA,KAAA,CAAA;QAAA,CACvB;IAAA,CACJ;IAAA;;;GAAA,GAMA,IAAI,OACJ,GAAA;QACI,OAAO,CAAC,CAAA,CAAE,IAAK,CAAA,IAAA,GAAQ,CAAK,IAAA,MAAA,CAAA,CAAA;IAAA,CAChC;IAEA,IAAI,QAAQ,KACZ,EAAA;QACI,IAAI,CAAC,CAAA,CAAE,IAAA,CAAK,IAAQ,GAAA,CAAA,IAAK,MAAA,MAAa,KACtC,EAAA;YACI,IAAA,CAAK,IAAA,IAAS,CAAK,IAAA,MAAA,CAAA;QAAA,CACvB;IAAA,CACJ;IAAA,8GAAA,GAGA,IAAI,SAAS,KACb,EAAA;QACI,IAAI,UAAU,MACd,EAAA;YACI,IAAA,CAAK,OAAU,GAAA,KAAA,CAAA;YAEf,OAAA;QAAA,CACJ;QAEA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;QACf,IAAA,CAAK,kBAAA,GAAqB,KAAU,KAAA,OAAA,CAAA;IAAA,CACxC;IAEA,IAAI,QACJ,GAAA;QACQ,IAAA,CAAC,IAAA,CAAK,OACV,EAAA;YACW,OAAA,MAAA,CAAA;QAAA,CACX;QAEO,OAAA,IAAA,CAAK,kBAAA,GAAqB,OAAU,GAAA,MAAA,CAAA;IAAA,CAC/C;IAAA;;;GAAA,GAMA,IAAI,OACJ,GAAA;QACI,OAAO,CAAC,CAAA,CAAE,IAAK,CAAA,IAAA,GAAQ,CAAK,IAAA,OAAA,CAAA,CAAA;IAAA,CAChC;IAEA,IAAI,QAAQ,KACZ,EAAA;QACI,IAAI,CAAC,CAAA,CAAE,IAAA,CAAK,IAAQ,GAAA,CAAA,IAAK,OAAA,MAAc,KACvC,EAAA;YACI,IAAA,CAAK,IAAA,IAAS,CAAK,IAAA,OAAA,CAAA;QAAA,CACvB;IAAA,CACJ;IAAA;;;GAAA,GAMA,IAAI,SACJ,GAAA;QACI,OAAO,CAAC,CAAA,CAAE,IAAK,CAAA,IAAA,GAAQ,CAAK,IAAA,UAAA,CAAA,CAAA;IAAA,CAChC;IAEA,IAAI,UAAU,KACd,EAAA;QACI,IAAI,CAAC,CAAA,CAAE,IAAA,CAAK,IAAQ,GAAA,CAAA,IAAK,UAAA,MAAiB,KAC1C,EAAA;YACI,IAAA,CAAK,IAAA,IAAS,CAAK,IAAA,UAAA,CAAA;QAAA,CACvB;IAAA,CACJ;IAAA;;;GAAA,GAMA,IAAI,SACJ,GAAA;QACI,OAAO,CAAC,CAAA,CAAE,IAAK,CAAA,IAAA,GAAQ,CAAK,IAAA,UAAA,CAAA,CAAA;IAAA,CAChC;IAEA,IAAI,UAAU,KACd,EAAA;QACI,IAAI,CAAC,CAAA,CAAE,IAAA,CAAK,IAAQ,GAAA,CAAA,IAAK,UAAA,MAAiB,KAC1C,EAAA;YACI,IAAA,CAAK,IAAA,IAAS,CAAK,IAAA,UAAA,CAAA;QAAA,CACvB;IAAA,CACJ;IAAA;;;GAAA,GAMA,IAAI,kBACJ,GAAA;QACI,OAAO,CAAC,CAAA,CAAE,IAAK,CAAA,IAAA,GAAQ,CAAK,IAAA,OAAA,CAAA,CAAA;IAAA,CAChC;IAEA,IAAI,mBAAmB,KACvB,EAAA;QACI,IAAI,CAAC,CAAA,CAAE,IAAA,CAAK,IAAQ,GAAA,CAAA,IAAK,OAAA,MAAc,KACvC,EAAA;YACI,IAAA,CAAK,IAAA,IAAS,CAAK,IAAA,OAAA,CAAA;QAAA,CACvB;IAAA,CACJ;IAAA;;;;GAAA,GAOA,IAAI,SACJ,GAAA;QACI,OAAO,IAAK,CAAA,UAAA,CAAA;IAAA,CAChB;IAEA,IAAI,UAAU,KACd,EAAA;QACI,IAAA,CAAK,KAAA,GAAS,KAAU,KAAA,MAAA,CAAA;QACxB,IAAA,CAAK,UAAa,GAAA,KAAA,CAAA;QACb,IAAA,CAAA,YAAA,GAAe,YAAa,CAAA,KAAkC,CAAK,IAAA,CAAA,CAAA;IAAA,CAC5E;IAAA;;;GAAA,GAMA,IAAI,aACJ,GAAA;QACI,OAAO,IAAK,CAAA,cAAA,CAAA;IAAA,CAChB;IAEA,IAAI,cAAc,KAClB,EAAA;QACS,IAAA,CAAA,OAAA,GAAU,CAAC,CAAC,KAAA,CAAA;QACjB,IAAA,CAAK,cAAiB,GAAA,KAAA,CAAA;IAAA,CAC1B;IAGO,QACP,GAAA;QACI,OAAO,CACY,8BAAA,EAAA,IAAA,CAAK,SAAS,CAAA,oBAAA,EACL,IAAA,CAAK,kBAAkB,CAAA,SAAA,EAClC,IAAK,CAAA,OAAO,CACV,WAAA,EAAA,IAAA,CAAK,SAAS,CAAA,eAAA,EACV,IAAA,CAAK,aAAa,CAAA,CAAA,CAAA,CAAA;IAAA,CAE7C;IAAA;;;GAAA,GAOA,OAAc,KACd,GAAA;QACU,MAAA,KAAA,GAAQ,IAAI,MAAM,EAAA,CAAA;QAExB,KAAA,CAAM,SAAY,GAAA,KAAA,CAAA;QAClB,KAAA,CAAM,KAAQ,GAAA,IAAA,CAAA;QAEP,OAAA,KAAA,CAAA;IAAA,CACX;AAGJ,CAAA,CAAA;AAlNa,MAiNK,CAAA,SAAA,GAAY,OAAM,KAAM,EAAA,CAAA;AAjNnC,IAAM,KAAN,GAAA","debugId":null}},
    {"offset": {"line": 318, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts"],"sourcesContent":["/**\n * @param rgb\n * @param alpha\n * @param out\n * @param offset\n * @internal\n */\nexport function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\n/**\n * @param abgr\n * @param out\n * @param offset\n * @internal\n */\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n"],"names":[],"mappings":";;;;;;;AAOO,SAAS,cAAe,CAAA,GAAA,EAAa,KAAe,EAAA,GAAA,EAAmB,MAC9E,EAAA;IAEI,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAM,GAAO,IAAA,EAAA,GAAM,GAAQ,IAAA,GAAA,CAAA;IACvC,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAM,GAAO,IAAA,CAAA,GAAK,GAAQ,IAAA,GAAA,CAAA;IAClC,GAAA,CAAA,MAAA,EAAQ,CAAK,GAAA,CAAA,GAAA,GAAM,GAAQ,IAAA,GAAA,CAAA;IAC/B,GAAA,CAAI,QAAQ,CAAI,GAAA,KAAA,CAAA;AACpB,CAAA;AAQgB,SAAA,mBAAA,CAAoB,IAAc,EAAA,GAAA,EAAmB,MACrE,EAAA;IACU,MAAA,KAAA,GAAA,CAAU,IAAQ,IAAA,EAAA,GAAM,GAAQ,IAAA,GAAA,CAAA;IAEtC,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAM,IAAO,GAAA,GAAA,IAAQ,GAAO,GAAA,KAAA,CAAA;IACxC,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAO,IAAQ,IAAA,CAAA,GAAK,GAAA,IAAQ,GAAO,GAAA,KAAA,CAAA;IAC/C,GAAA,CAAI,MAAQ,EAAA,CAAA,GAAA,CAAO,IAAQ,IAAA,EAAA,GAAM,GAAA,IAAQ,GAAO,GAAA,KAAA,CAAA;IAChD,GAAA,CAAI,QAAQ,CAAI,GAAA,KAAA,CAAA;AACpB","debugId":null}},
    {"offset": {"line": 344, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/graphics/shared/GraphicsPipe.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { type Renderer } from '../../../rendering/renderers/types';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext } from './GraphicsContextSystem';\n\n/** @internal */\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    contextChange(renderer: Renderer): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\n\n/** @internal */\nexport class GraphicsGpuData\n{\n    public batches: BatchableGraphics[] = [];\n    public batched = false;\n    public destroy()\n    {\n        this.batches.forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this.batches.length = 0;\n    }\n}\n\n/** @internal */\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: Renderer;\n    public state: State = State.for2d();\n\n    private _adaptor: GraphicsAdaptor;\n\n    constructor(renderer: Renderer, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n\n        this.renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._adaptor.contextChange(this.renderer);\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n        const context = graphics.context;\n\n        const wasBatched = !!graphics._gpuData;\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n        if (graphics.didViewUpdate)\n        {\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const batches = gpuData.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batch._batcher.updateElement(batch);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // free up the batches..\n        gpuData.destroy();\n\n        if (gpuContext.isBatchable)\n        {\n            this._updateBatchesForRenderable(graphics, gpuData);\n        }\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getGpuDataForRenderable(graphics).batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n    }\n\n    private _initGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        const gpuData = new GraphicsGpuData();\n\n        graphics._gpuData[this.renderer.uid] = gpuData;\n\n        return gpuData;\n    }\n\n    private _updateBatchesForRenderable(graphics: Graphics, gpuData: GraphicsGpuData)\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        gpuData.batches = gpuContext.batches.map((batch) =>\n        {\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 485, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/graphics/init.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/graphics/init.ts"],"sourcesContent":["import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n"],"names":[],"mappings":";;;;;;;;AAIA,oOAAA,CAAW,GAAA,CAAI,yPAAY,CAAA,CAAA;AAC3B,oOAAA,CAAW,GAAA,CAAI,2QAAqB,CAAA","debugId":null}},
    {"offset": {"line": 499, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/mesh/shared/BatchableMesh.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts"],"sourcesContent":["import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n\n    public _topology: Topology;\n\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n    public _textureMatrixUpdateId: number = -1;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    get topology() { return this._topology || this.geometry.topology; }\n    set topology(value: Topology) { this._topology = value; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    /**\n     * Sets the texture for the batchable mesh.\n     * As it does so, it resets the texture matrix update ID.\n     * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n     * @param value - The texture to set.\n     */\n    public setTexture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this.texture = value;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 588, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/mesh/shared/MeshPipe.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\n/**\n * GPUData for Mesh\n * @internal\n */\nexport class MeshGpuData implements GPUData\n{\n    public meshData?: MeshData;\n    public batchableMesh?: BatchableMesh;\n\n    public destroy()\n    {\n        // BOOM!\n    }\n}\n\n/**\n * The data for the mesh\n * @internal\n */\ninterface MeshData\n{\n    /** if the mesh is batched or not */\n    batched: boolean;\n    /** the size of the index buffer */\n    indexSize: number;\n    /** the size of the vertex buffer */\n    vertexSize: number;\n}\n\n/** @internal */\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\n/**\n * The MeshPipe is responsible for handling the rendering of Mesh objects.\n * It manages the batching of meshes, updates their GPU data, and executes the rendering instructions.\n * It also handles the local uniforms for each mesh, such as transformation matrices and colors.\n * @category scene\n * @internal\n */\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            if (batchableMesh.texture.uid !== mesh._texture.uid)\n            {\n                batchableMesh._textureMatrixUpdateId = -1;\n            }\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                mesh._texture\n            );\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const meshData = this._getMeshData(mesh);\n\n        if (mesh.didViewUpdate)\n        {\n            meshData.indexSize = mesh._geometry.indices?.length;\n            meshData.vertexSize = mesh._geometry.positions?.length;\n        }\n\n        if (meshData.batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid].meshData = {\n            batched: mesh.batched,\n            indexSize: 0,\n            vertexSize: 0,\n        };\n\n        return mesh._gpuData[this.renderer.uid].meshData;\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = new BatchableMesh();\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.setTexture(mesh._texture);\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 746, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/mesh/init.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/mesh/init.ts"],"sourcesContent":["import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n"],"names":[],"mappings":";;;;;;AAGA,oOAAA,CAAW,GAAA,CAAI,6OAAQ,CAAA","debugId":null}},
    {"offset": {"line": 757, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/particle-container/gl/GlParticleContainerAdaptor.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/particle-container/gl/GlParticleContainerAdaptor.ts"],"sourcesContent":["import type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GlParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const state = particleContainerPipe.state;\n        const renderer = particleContainerPipe.renderer as WebGLRenderer;\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.resources.uTexture = container.texture._source;\n        shader.resources.uniforms = particleContainerPipe.localUniforms;\n\n        const gl = renderer.gl;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        // now lets upload and render the buffers..\n        renderer.shader.bind(shader);\n        renderer.state.set(state);\n        renderer.geometry.bind(buffer.geometry, shader.glProgram);\n\n        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n    }\n}\n"],"names":[],"mappings":";;;;;AAKO,MAAM,0BACb,CAAA;IACW,OAAA,CAAQ,qBAAA,EAA8C,SAC7D,EAAA;QACI,MAAM,QAAQ,qBAAsB,CAAA,KAAA,CAAA;QACpC,MAAM,WAAW,qBAAsB,CAAA,QAAA,CAAA;QACjC,MAAA,MAAA,GAAS,SAAU,CAAA,MAAA,IAAU,qBAAsB,CAAA,aAAA,CAAA;QAElD,MAAA,CAAA,SAAA,CAAU,QAAW,GAAA,SAAA,CAAU,OAAQ,CAAA,OAAA,CAAA;QACvC,MAAA,CAAA,SAAA,CAAU,QAAA,GAAW,qBAAsB,CAAA,aAAA,CAAA;QAElD,MAAM,KAAK,QAAS,CAAA,EAAA,CAAA;QAEd,MAAA,MAAA,GAAS,qBAAsB,CAAA,UAAA,CAAW,SAAS,CAAA,CAAA;QAGhD,QAAA,CAAA,MAAA,CAAO,IAAA,CAAK,MAAM,CAAA,CAAA;QAClB,QAAA,CAAA,KAAA,CAAM,GAAA,CAAI,KAAK,CAAA,CAAA;QACxB,QAAA,CAAS,QAAS,CAAA,IAAA,CAAK,MAAO,CAAA,QAAA,EAAU,OAAO,SAAS,CAAA,CAAA;QAExD,MAAM,QAAW,GAAA,MAAA,CAAO,QAAS,CAAA,WAAA,CAAY,IAAK,CAAA,iBAAA,CAAA;QAClD,MAAM,MAAS,GAAA,QAAA,KAAa,CAAI,GAAA,EAAA,CAAG,cAAA,GAAiB,EAAG,CAAA,YAAA,CAAA;QAEpD,EAAA,CAAA,YAAA,CAAa,GAAG,SAAW,EAAA,SAAA,CAAU,gBAAA,CAAiB,MAAS,GAAA,CAAA,EAAG,QAAQ,CAAC,CAAA,CAAA;IAAA,CAClF;AACJ","debugId":null}},
    {"offset": {"line": 785, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/particle-container/shared/utils/createIndicesForQuads.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/particle-container/shared/utils/createIndicesForQuads.ts"],"sourcesContent":["/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n * @internal\n */\nexport function createIndicesForQuads(\n    size: number,\n    outBuffer: Uint16Array | Uint32Array | null = null\n): Uint16Array | Uint32Array\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    // Check if we need to use Uint32Array\n    if (totalIndices > 65535)\n    {\n        outBuffer ||= new Uint32Array(totalIndices); // Use Uint32Array if needed\n    }\n    else\n    {\n        outBuffer ||= new Uint16Array(totalIndices);\n    }\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n"],"names":[],"mappings":";;;;;AAQgB,SAAA,qBAAA,CACZ,IACA,EAAA,SAAA,GAA8C,IAElD,EAAA;IAEI,MAAM,eAAe,IAAO,GAAA,CAAA,CAAA;IAG5B,IAAI,eAAe,KACnB,EAAA;QACkB,SAAA,IAAA,CAAA,SAAA,GAAA,IAAI,YAAY,YAAY,CAAA,CAAA,CAAA;IAAA,CAG9C,MAAA;QACkB,SAAA,IAAA,CAAA,SAAA,GAAA,IAAI,YAAY,YAAY,CAAA,CAAA,CAAA;IAAA,CAC9C;IAEI,IAAA,SAAA,CAAU,MAAA,KAAW,YACzB,EAAA;QACI,MAAM,IAAI,KAAM,CAAA,CAAA,oCAAA,EAAuC,UAAU,MAAM,CAAA,cAAA,EAAiB,YAAY,CAAE,CAAA,CAAA,CAAA;IAAA,CAC1G;IAGS,IAAA,IAAA,CAAA,GAAI,GAAG,CAAI,GAAA,CAAA,EAAG,IAAI,YAAc,EAAA,CAAA,IAAK,CAAG,EAAA,CAAA,IAAK,CACtD,CAAA;QACc,SAAA,CAAA,CAAA,GAAI,CAAC,CAAA,GAAI,CAAI,GAAA,CAAA,CAAA;QACb,SAAA,CAAA,CAAA,GAAI,CAAC,CAAA,GAAI,CAAI,GAAA,CAAA,CAAA;QACb,SAAA,CAAA,CAAA,GAAI,CAAC,CAAA,GAAI,CAAI,GAAA,CAAA,CAAA;QACb,SAAA,CAAA,CAAA,GAAI,CAAC,CAAA,GAAI,CAAI,GAAA,CAAA,CAAA;QACb,SAAA,CAAA,CAAA,GAAI,CAAC,CAAA,GAAI,CAAI,GAAA,CAAA,CAAA;QACb,SAAA,CAAA,CAAA,GAAI,CAAC,CAAA,GAAI,CAAI,GAAA,CAAA,CAAA;IAAA,CAC3B;IAEO,OAAA,SAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 816, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/particle-container/shared/utils/generateParticleUpdateFunction.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/particle-container/shared/utils/generateParticleUpdateFunction.ts"],"sourcesContent":["import {\n    getAttributeInfoFromFormat\n} from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { IParticle } from '../Particle';\nimport type { ParticleRendererProperty } from '../particleData';\n\n// TODO rename to update function\n/** @internal */\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n\n/**\n * @param properties\n * @internal\n */\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>)\n{\n    return {\n        dynamicUpdate: generateUpdateFunction(properties, true),\n        staticUpdate: generateUpdateFunction(properties, false),\n    };\n}\n\nfunction generateUpdateFunction(\n    properties: Record<string, ParticleRendererProperty>,\n    dynamic: boolean\n): ParticleUpdateFunction\n{\n    const funcFragments: string[] = [];\n\n    funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n\n    let offset = 0;\n\n    for (const i in properties)\n    {\n        const property = properties[i];\n\n        if (dynamic !== property.dynamic) continue;\n\n        funcFragments.push(`offset = index + ${offset}`);\n\n        funcFragments.push(property.code);\n\n        const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n        offset += attributeInfo.stride / 4;\n    }\n\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n\n    // add to the front..\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n\n    const functionSource = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('ps', 'f32v', 'u32v', functionSource) as ParticleUpdateFunction;\n}\n"],"names":[],"mappings":";;;;;;;AAeO,SAAS,+BAA+B,UAC/C,EAAA;IACW,OAAA;QACH,aAAA,EAAe,sBAAuB,CAAA,UAAA,EAAY,IAAI,CAAA;QACtD,YAAA,EAAc,sBAAuB,CAAA,UAAA,EAAY,KAAK,CAAA;IAAA,CAC1D,CAAA;AACJ,CAAA;AAEA,SAAS,sBAAA,CACL,UAAA,EACA,OAEJ,EAAA;IACI,MAAM,gBAA0B,EAAC,CAAA;IAEjC,aAAA,CAAc,IAAK,CAAA,CAAA;;;;;;;;YAQV,CAAA,CAAA,CAAA;IAET,IAAI,MAAS,GAAA,CAAA,CAAA;IAEb,IAAA,MAAW,KAAK,UAChB,CAAA;QACU,MAAA,QAAA,GAAW,UAAA,CAAW,CAAC,CAAA,CAAA;QAE7B,IAAI,YAAY,QAAS,CAAA,OAAA,EAAS,SAAA;QAEpB,aAAA,CAAA,IAAA,CAAK,CAAoB,iBAAA,EAAA,MAAM,CAAE,CAAA,CAAA,CAAA;QAEjC,aAAA,CAAA,IAAA,CAAK,SAAS,IAAI,CAAA,CAAA;QAE1B,MAAA,aAAA,OAAgB,+SAA2B,EAAA,QAAA,CAAS,MAAM,CAAA,CAAA;QAEhE,MAAA,IAAU,cAAc,MAAS,GAAA,CAAA,CAAA;IAAA,CACrC;IAEA,aAAA,CAAc,IAAK,CAAA,CAAA;;;IAGlB,CAAA,CAAA,CAAA;IAGD,aAAA,CAAc,OAAQ,CAAA,CAAA;qBAAA,EACH,MAAM,CAAA;IACxB,CAAA,CAAA,CAAA;IAEK,MAAA,cAAA,GAAiB,aAAc,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;IAG9C,OAAO,IAAI,QAAA,CAAS,IAAM,EAAA,MAAA,EAAQ,QAAQ,cAAc,CAAA,CAAA;AAC5D","debugId":null}},
    {"offset": {"line": 865, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleBuffer.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/particle-container/shared/ParticleBuffer.ts"],"sourcesContent":["import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @internal\n */\nexport interface ParticleBufferOptions\n{\n    /** The size of the particle buffer, defaults to 1000. */\n    size: number;\n    /** A record of attributes that the particle container uses. */\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 997, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.frag.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 1008, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.vert.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 1019, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/particle-container/shared/shader/particles.wgsl.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 1030, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/particle-container/shared/shader/ParticleShader.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/particle-container/shared/shader/ParticleShader.ts"],"sourcesContent":["import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\nimport wgsl from './particles.wgsl';\n\n/** @internal */\nexport class ParticleShader extends Shader\n{\n    constructor()\n    {\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment\n        });\n\n        const gpuProgram = GpuProgram.from({\n            fragment: {\n                source: wgsl,\n                entryPoint: 'mainFragment'\n            },\n            vertex: {\n                source: wgsl,\n                entryPoint: 'mainVertex'\n            }\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                // this will be replaced with the texture from the particle container\n                uTexture: Texture.WHITE.source,\n                // this will be replaced with the texture style from the particle container\n                uSampler: new TextureStyle({}),\n                // this will be replaced with the local uniforms from the particle container\n                uniforms: {\n                    uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Color(0xFFFFFF), type: 'vec4<f32>' },\n                    uRound: { value: 1, type: 'f32' },\n                    uResolution: { value: [0, 0], type: 'vec2<f32>' },\n                }\n            }\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAYO,MAAM,uBAAuB,4PACpC,CAAA;IACI,WACA,EAAA;QACU,MAAA,SAAA,GAAY,8PAAA,CAAU,IAAK,CAAA;oBAC7B,gRAAA;sBACA,gRAAA;QAAA,CACH,CAAA,CAAA;QAEK,MAAA,UAAA,GAAa,iQAAA,CAAW,IAAK,CAAA;YAC/B,QAAU,EAAA;gBACN,MAAQ,EAAA,gRAAA;gBACR,UAAY,EAAA,cAAA;YAAA,CAChB;YACA,MAAQ,EAAA;gBACJ,MAAQ,EAAA,gRAAA;gBACR,UAAY,EAAA,YAAA;YAAA,CAChB;QAAA,CACH,CAAA,CAAA;QAEK,KAAA,CAAA;YACF,SAAA;YACA,UAAA;YACA,SAAW,EAAA;gBAAA,qEAAA;gBAEP,QAAA,EAAU,+PAAA,CAAQ,KAAM,CAAA,MAAA;gBAAA,2EAAA;gBAExB,QAAU,EAAA,IAAI,yQAAa,CAAA,CAAA,CAAE,CAAA;gBAAA,4EAAA;gBAE7B,QAAU,EAAA;oBACN,oBAAoB;wBAAE,KAAA,EAAO,IAAI,iOAAO,EAAA;wBAAG,MAAM,aAAc;oBAAA,CAAA;oBAC/D,MAAA,EAAQ;wBAAE,KAAO,EAAA,IAAI,qNAAA,CAAM,QAAQ,CAAA;wBAAG,MAAM,WAAY;oBAAA,CAAA;oBACxD,MAAQ,EAAA;wBAAE,KAAO,EAAA,CAAA;wBAAG,MAAM,KAAM;oBAAA,CAAA;oBAChC,WAAA,EAAa;wBAAE,KAAO,EAAA;4BAAC;4BAAG,CAAC;yBAAA;wBAAG,MAAM,WAAY;oBAAA,CAAA;gBAAA,CACpD;YAAA,CACJ;QAAA,CACH,CAAA,CAAA;IAAA,CACL;AACJ","debugId":null}},
    {"offset": {"line": 1111, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/particle-container/shared/ParticleContainerPipe.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/particle-container/shared/ParticleContainerPipe.ts"],"sourcesContent":["import { Matrix } from '../../../maths/matrix/Matrix';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport { ParticleShader } from './shader/ParticleShader';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { ParticleContainer } from './ParticleContainer';\n\n/** @internal */\nexport interface ParticleContainerAdaptor\n{\n    execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer): void;\n}\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @category scene\n * @internal\n */\nexport class ParticleContainerPipe implements RenderPipe<ParticleContainer>\n{\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public defaultShader: Shader;\n\n    /** @internal */\n    public adaptor: ParticleContainerAdaptor;\n    /** @internal */\n    public readonly state = State.for2d();\n    /** @internal */\n    public readonly renderer: Renderer;\n\n    /** Local uniforms that are used for rendering particles. */\n    public readonly localUniforms = new UniformGroup({\n        uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uRound: { value: 1, type: 'f32' },\n        uResolution: { value: [0, 0], type: 'vec2<f32>' },\n    });\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     * @param adaptor\n     */\n    constructor(renderer: Renderer, adaptor: ParticleContainerAdaptor)\n    {\n        this.renderer = renderer;\n\n        this.adaptor = adaptor;\n\n        this.defaultShader = new ParticleShader();\n\n        this.state = State.for2d();\n    }\n\n    public validateRenderable(_renderable: ParticleContainer): boolean\n    {\n        // always fine :D\n        return false;\n    }\n\n    public addRenderable(renderable: ParticleContainer, instructionSet: InstructionSet)\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(renderable);\n    }\n\n    public getBuffers(renderable: ParticleContainer): ParticleBuffer\n    {\n        return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n    }\n\n    private _initBuffer(renderable: ParticleContainer): ParticleBuffer\n    {\n        renderable._gpuData[this.renderer.uid] = new ParticleBuffer({\n            size: renderable.particleChildren.length,\n            properties: renderable._properties,\n        });\n\n        return renderable._gpuData[this.renderer.uid];\n    }\n\n    public updateRenderable(_renderable: ParticleContainer)\n    {\n        // nothing to be done here!\n\n    }\n\n    public execute(container: ParticleContainer): void\n    {\n        const children = container.particleChildren;\n\n        if (children.length === 0)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const buffer = this.getBuffers(container);\n\n        container.texture ||= children[0].texture;\n\n        const state = this.state;\n\n        buffer.update(children, container._childrenDirty);\n        container._childrenDirty = false;\n\n        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n\n        const uniforms = this.localUniforms.uniforms;\n\n        const transformationMatrix = uniforms.uTranslationMatrix;\n\n        container.worldTransform.copyTo(transformationMatrix);\n\n        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n\n        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n        uniforms.uRound = renderer._roundPixels | container._roundPixels;\n\n        color32BitToUniform(\n            container.groupColorAlpha,\n            uniforms.uColor,\n            0\n        );\n\n        this.adaptor.execute(this, container);\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        (this.renderer as null) = null;\n        if (this.defaultShader)\n        {\n            this.defaultShader.destroy();\n            this.defaultShader = null;\n        }\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1215, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/particle-container/shared/GlParticleContainerPipe.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/particle-container/shared/GlParticleContainerPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\n\n/**\n * WebGL renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GlParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer, new GlParticleContainerAdaptor());\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAWO,MAAM,gCAAgC,wRAC7C,CAAA;IASI,YAAY,QACZ,CAAA;QACU,KAAA,CAAA,QAAA,EAAU,IAAI,8RAAA,EAA4B,CAAA,CAAA;IAAA,CACpD;AACJ,CAAA;AAAA,YAAA,GAda,uBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,uOAAc,CAAA,UAAA;KAClB;IACA,IAAM,EAAA,UAAA;AACV,CAAA","debugId":null}},
    {"offset": {"line": 1243, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/particle-container/gpu/GpuParticleContainerAdaptor.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/particle-container/gpu/GpuParticleContainerAdaptor.ts"],"sourcesContent":["import type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GpuParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const renderer = particleContainerPipe.renderer as WebGPURenderer;\n\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n\n        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n\n        const state = particleContainerPipe.state;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        renderer.encoder.draw({\n            geometry: buffer.geometry,\n            shader: container.shader || particleContainerPipe.defaultShader,\n            state,\n            size: container.particleChildren.length * 6,\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;AAKO,MAAM,2BACb,CAAA;IACW,OAAA,CAAQ,qBAAA,EAA8C,SAC7D,EAAA;QACI,MAAM,WAAW,qBAAsB,CAAA,QAAA,CAAA;QAEjC,MAAA,MAAA,GAAS,SAAU,CAAA,MAAA,IAAU,qBAAsB,CAAA,aAAA,CAAA;QAElD,MAAA,CAAA,MAAA,CAAO,CAAC,CAAI,GAAA,QAAA,CAAS,WAAA,CAAY,YAAa,CAAA,mBAAA,CAAoB,qBAAsB,CAAA,aAAA,EAAe,IAAI,CAAA,CAAA;QAElH,MAAA,CAAO,MAAA,CAAO,CAAC,CAAA,GAAI,SAAS,OAAQ,CAAA,mBAAA,CAAoB,UAAU,OAAO,CAAA,CAAA;QAEzE,MAAM,QAAQ,qBAAsB,CAAA,KAAA,CAAA;QAE9B,MAAA,MAAA,GAAS,qBAAsB,CAAA,UAAA,CAAW,SAAS,CAAA,CAAA;QAEzD,QAAA,CAAS,OAAA,CAAQ,IAAK,CAAA;YAClB,UAAU,MAAO,CAAA,QAAA;YACjB,MAAA,EAAQ,SAAU,CAAA,MAAA,IAAU,qBAAsB,CAAA,aAAA;YAClD,KAAA;YACA,IAAA,EAAM,SAAU,CAAA,gBAAA,CAAiB,MAAS,GAAA,CAAA;QAAA,CAC7C,CAAA,CAAA;IAAA,CACL;AACJ","debugId":null}},
    {"offset": {"line": 1270, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/particle-container/shared/GpuParticleContainerPipe.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/particle-container/shared/GpuParticleContainerPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\n\n/**\n * WebGPU renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GpuParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer, new GpuParticleContainerAdaptor());\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAWO,MAAM,iCAAiC,wRAC9C,CAAA;IASI,YAAY,QACZ,CAAA;QACU,KAAA,CAAA,QAAA,EAAU,IAAI,iSAAA,EAA6B,CAAA,CAAA;IAAA,CACrD;AACJ,CAAA;AAAA,YAAA,GAda,wBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,uOAAc,CAAA,WAAA;KAClB;IACA,IAAM,EAAA,UAAA;AACV,CAAA","debugId":null}},
    {"offset": {"line": 1298, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/particle-container/init.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/particle-container/init.ts"],"sourcesContent":["import { extensions } from '../../extensions/Extensions';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe';\n\n// NOTE: this is the first occurrence of needing both gl and gpu pipes in the same file\n// This could cause some issues with tree shaking in the future.\n// Right now these two files do not import anything specific for a renderer, so is not an issue for now.\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n"],"names":[],"mappings":";;;;;;;;AAOA,oOAAA,CAAW,GAAA,CAAI,4RAAuB,CAAA,CAAA;AACtC,oOAAA,CAAW,GAAA,CAAI,8RAAwB,CAAA","debugId":null}},
    {"offset": {"line": 1312, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text/utils/updateTextBounds.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text/utils/updateTextBounds.ts"],"sourcesContent":["import { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { type BatchableSprite } from '../../sprite/BatchableSprite';\nimport { type AbstractText } from '../AbstractText';\nimport { type TextStyle, type TextStyleOptions } from '../TextStyle';\n\n/**\n * Updates the bounds of the given batchable sprite based on the provided text object.\n *\n * This function adjusts the bounds of the batchable sprite to match the dimensions\n * and anchor point of the text's texture. Additionally, it compensates for any padding\n * specified in the text's style to ensure the text is rendered correctly on screen.\n * @param {BatchableSprite} batchableSprite - The sprite whose bounds need to be updated.\n * @param {AbstractText} text - The text object containing the texture and style information.\n * @internal\n */\nexport function updateTextBounds(batchableSprite: BatchableSprite, text: AbstractText<TextStyle, TextStyleOptions>)\n{\n    const { texture, bounds } = batchableSprite;\n    const padding = text._style._getFinalPadding();\n\n    // When HTML text textures are created, they include the padding around the text content\n    // to prevent text clipping and provide a buffer zone. This padding is built into\n    // the texture itself. However, we don't want this padding to affect the text's\n    // actual position on screen.\n\n    // First, calculate bounds using the full padded texture\n    updateQuadBounds(bounds, text._anchor, texture);\n\n    // Then adjust by the padding amount to compensate for the buffer zone\n    // This shifts the render position back by the padding amount, ensuring the text\n    // appears exactly where intended while maintaining the buffer zone around it.\n    const paddingOffset = text._anchor._x * padding * 2;\n    const paddingOffsetY = text._anchor._y * padding * 2;\n\n    bounds.minX -= padding - paddingOffset;\n    bounds.minY -= padding - paddingOffsetY;\n    bounds.maxX -= padding - paddingOffset;\n    bounds.maxY -= padding - paddingOffsetY;\n}\n"],"names":[],"mappings":";;;;;;;AAegB,SAAA,gBAAA,CAAiB,eAAA,EAAkC,IACnE,EAAA;IACU,MAAA,EAAE,OAAS,EAAA,MAAA,EAAW,GAAA,eAAA,CAAA;IACtB,MAAA,OAAA,GAAU,IAAK,CAAA,MAAA,CAAO,gBAAiB,EAAA,CAAA;QAQ5B,mPAAA,EAAA,MAAA,EAAQ,IAAK,CAAA,OAAA,EAAS,OAAO,CAAA,CAAA;IAK9C,MAAM,aAAgB,GAAA,IAAA,CAAK,OAAQ,CAAA,EAAA,GAAK,OAAU,GAAA,CAAA,CAAA;IAClD,MAAM,cAAiB,GAAA,IAAA,CAAK,OAAQ,CAAA,EAAA,GAAK,OAAU,GAAA,CAAA,CAAA;IAEnD,MAAA,CAAO,IAAA,IAAQ,OAAU,GAAA,aAAA,CAAA;IACzB,MAAA,CAAO,IAAA,IAAQ,OAAU,GAAA,cAAA,CAAA;IACzB,MAAA,CAAO,IAAA,IAAQ,OAAU,GAAA,aAAA,CAAA;IACzB,MAAA,CAAO,IAAA,IAAQ,OAAU,GAAA,cAAA,CAAA;AAC7B","debugId":null}},
    {"offset": {"line": 1336, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts"],"sourcesContent":["import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @internal\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n\n    public destroy()\n    {\n        // BOOM!\n    }\n}\n"],"names":[],"mappings":";;;;;AAYO,MAAM,eACb,CAAA;IADO,WAAA,EAAA;QAEH,IAAA,CAAO,WAAc,GAAA,SAAA,CAAA;QACrB,IAAA,CAAO,QAAqB,GAAA,eAAA,CAAA;QAG5B,mBAAA;QAAA,IAAA,CAAgB,aAAgB,GAAA,CAAA,CAAA;QAChC,IAAA,CAAgB,SAAY,GAAA,CAAA,CAAA;QAC5B,IAAA,CAAgB,UAAa,GAAA,IAAA,CAAA;QAQ7B,IAAA,CAAO,WAAqB,GAAA,CAAA,CAAA;QAI5B,IAAA,CAAO,eAAkB,GAAA,CAAA,CAAA;QACzB,yBAAA;QAAA,IAAA,CAAO,QAAoB,GAAA,IAAA,CAAA;QAC3B,IAAA,CAAO,MAAgB,GAAA,IAAA,CAAA;IAAA,CAAA;IAEvB,IAAI,SAAY,GAAA;QAAE,OAAO,IAAA,CAAK,UAAW,CAAA,cAAA,CAAA;IAAA,CAAgB;IACzD,IAAI,KAAQ,GAAA;QAAE,OAAO,IAAA,CAAK,UAAW,CAAA,eAAA,CAAA;IAAA,CAAiB;IAE/C,KACP,GAAA;QACI,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;QAClB,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;QACf,IAAA,CAAK,QAAW,GAAA,IAAA,CAAA;QAChB,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;QACd,IAAA,CAAK,MAAS,GAAA,IAAA,CAAA;IAAA,CAClB;IAEO,OACP,GAAA,CAAA,CAEA;AACJ","debugId":null}},
    {"offset": {"line": 1376, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text/canvas/BatchableText.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text/canvas/BatchableText.ts"],"sourcesContent":["import { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\n/** @internal */\nexport class BatchableText extends BatchableSprite\n{\n    private readonly _renderer: Renderer;\n    public currentKey: string;\n\n    constructor(renderer: Renderer)\n    {\n        super();\n\n        // Next step is to make canvasTextSystem a GLOBAL object.\n        // so this is ok for now..\n        this._renderer = renderer;\n\n        renderer.runners.resolutionChange.add(this);\n    }\n\n    public resolutionChange()\n    {\n        const text = this.renderable as Text;\n\n        if (text._autoResolution)\n        {\n            text.onViewUpdate();\n        }\n    }\n\n    public destroy()\n    {\n        const { canvasText } = this._renderer;\n\n        canvasText.getReferenceCount(this.currentKey) === null\n            ? canvasText.returnTexture(this.texture)\n            : canvasText.decreaseReferenceCount(this.currentKey);\n        this._renderer.runners.resolutionChange.remove(this);\n        (this._renderer as null) = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAMO,MAAM,sBAAsB,mPACnC,CAAA;IAII,YAAY,QACZ,CAAA;QACU,KAAA,EAAA,CAAA;QAIN,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;QAER,QAAA,CAAA,OAAA,CAAQ,gBAAiB,CAAA,GAAA,CAAI,IAAI,CAAA,CAAA;IAAA,CAC9C;IAEO,gBACP,GAAA;QACI,MAAM,OAAO,IAAK,CAAA,UAAA,CAAA;QAElB,IAAI,KAAK,eACT,EAAA;YACI,IAAA,CAAK,YAAa,EAAA,CAAA;QAAA,CACtB;IAAA,CACJ;IAEO,OACP,GAAA;QACU,MAAA,EAAE,UAAW,EAAA,GAAI,IAAK,CAAA,SAAA,CAAA;QAE5B,UAAA,CAAW,iBAAkB,CAAA,IAAA,CAAK,UAAU,CAAA,KAAM,IAC5C,GAAA,UAAA,CAAW,aAAc,CAAA,IAAA,CAAK,OAAO,CAAA,GACrC,UAAW,CAAA,sBAAA,CAAuB,IAAA,CAAK,UAAU,CAAA,CAAA;QACvD,IAAA,CAAK,SAAU,CAAA,OAAA,CAAQ,gBAAiB,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;QAClD,IAAA,CAAK,SAAqB,GAAA,IAAA,CAAA;IAAA,CAC/B;AACJ","debugId":null}},
    {"offset": {"line": 1408, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextPipe.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateTextBounds } from '../utils/updateTextBounds';\nimport { BatchableText } from './BatchableText';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\n/** @internal */\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        const gpuText = this._getGpuText(text);\n\n        const newKey = text.styleKey;\n\n        if (gpuText.currentKey !== newKey) return true;\n\n        return text._didTextUpdate;\n    }\n\n    public addRenderable(text: Text, instructionSet: InstructionSet)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (text._didTextUpdate)\n        {\n            const resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n\n            if (batchableText.currentKey !== text.styleKey || text.resolution !== resolution)\n            {\n                // If the text has changed, we need to update the GPU text\n                this._updateGpuText(text);\n            }\n            text._didTextUpdate = false;\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        batchableText._batcher.updateElement(batchableText);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (batchableText.texture)\n        {\n            this._renderer.canvasText.decreaseReferenceCount(batchableText.currentKey);\n        }\n\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n\n        batchableText.texture = this._renderer.canvasText.getManagedTexture(text);\n        batchableText.currentKey = text.styleKey;\n\n        updateTextBounds(batchableText, text);\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const batchableText = new BatchableText(this._renderer);\n\n        batchableText.currentKey = '--';\n        batchableText.renderable = text;\n        batchableText.transform = text.groupTransform;\n        batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableText.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        text._gpuData[this._renderer.uid] = batchableText;\n\n        return batchableText;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1490, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text/utils/getPo2TextureFromSource.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts"],"sourcesContent":["import { type ImageLike } from '../../../environment/ImageLike';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n * @internal\n */\nexport function getPo2TextureFromSource(\n    image: ImageLike | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n"],"names":[],"mappings":";;;;;;;;;AAOA,MAAM,UAAA,GAAa,IAAI,8OAAO,EAAA,CAAA;AAYvB,SAAS,uBACZ,CAAA,KAAA,EACA,KACA,EAAA,MAAA,EACA,UAEJ,EAAA;IACI,MAAM,MAAS,GAAA,UAAA,CAAA;IAEf,MAAA,CAAO,IAAO,GAAA,CAAA,CAAA;IACd,MAAA,CAAO,IAAO,GAAA,CAAA,CAAA;IAEP,MAAA,CAAA,IAAA,GAAQ,KAAM,CAAA,KAAA,GAAQ,UAAc,GAAA,CAAA,CAAA;IACpC,MAAA,CAAA,IAAA,GAAQ,KAAM,CAAA,MAAA,GAAS,UAAc,GAAA,CAAA,CAAA;IAE5C,MAAM,UAAU,uQAAY,CAAA,iBAAA,CACxB,MAAO,CAAA,KAAA,EACP,MAAO,CAAA,MAAA,EACP,UAAA,EACA,KAAA;IAGJ,OAAA,CAAQ,MAAA,CAAO,cAAiB,GAAA,OAAA,CAAA;IAChC,OAAA,CAAQ,MAAA,CAAO,QAAW,GAAA,KAAA,CAAA;IAC1B,OAAA,CAAQ,MAAA,CAAO,SAAY,GAAA,6BAAA,CAAA;IAEnB,OAAA,CAAA,KAAA,CAAM,KAAA,GAAQ,KAAQ,GAAA,UAAA,CAAA;IACtB,OAAA,CAAA,KAAA,CAAM,MAAA,GAAS,MAAS,GAAA,UAAA,CAAA;IAOhC,OAAA,CAAQ,MAAO,CAAA,IAAA,CAAK,QAAU,EAAA,OAAA,CAAQ,MAAM,CAAA,CAAA;IAE5C,OAAA,CAAQ,SAAU,EAAA,CAAA;IAEX,OAAA,OAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 1522, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/utils/canvas/getCanvasBoundingBox.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/utils/canvas/getCanvasBoundingBox.ts"],"sourcesContent":["import { DOMAdapter } from '../../environment/adapter';\nimport { nextPow2 } from '../../maths/misc/pow2';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\n\nimport type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\n\n// Internal canvas for measuring bounds\nlet _internalCanvas: ICanvas | null = null;\nlet _internalContext: ICanvasRenderingContext2D | null = null;\n\nfunction ensureInternalCanvas(width: number, height: number): void\n{\n    if (!_internalCanvas)\n    {\n        _internalCanvas = DOMAdapter.get().createCanvas(256, 128);\n        _internalContext = _internalCanvas.getContext('2d', { willReadFrequently: true });\n        _internalContext.globalCompositeOperation = 'copy';\n        _internalContext.globalAlpha = 1;\n    }\n\n    if (_internalCanvas.width < width || _internalCanvas.height < height)\n    {\n        // Use power-of-two dimensions for better performance\n        _internalCanvas.width = nextPow2(width);\n        _internalCanvas.height = nextPow2(height);\n    }\n}\n\nfunction checkRow(data: Uint8ClampedArray, width: number, y: number)\n{\n    for (let x = 0, index = 4 * y * width; x < width; ++x, index += 4)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\nfunction checkColumn(data: Uint8ClampedArray, width: number, x: number, top: number, bottom: number)\n{\n    const stride = 4 * width;\n\n    for (let y = top, index = (top * stride) + (4 * x); y <= bottom; ++y, index += stride)\n    {\n        if (data[index + 3] !== 0) return false;\n    }\n\n    return true;\n}\n\n/** @internal */\nexport interface GetCanvasBoundingBoxOptions\n{\n    /** The canvas to measure */\n    canvas: ICanvas;\n    /** Optional. The width to analyze (defaults to canvas.width) */\n    width?: number;\n    /** Optional. The height to analyze (defaults to canvas.height) */\n    height?: number;\n    /**\n     * Optional. The resolution at which to analyze the canvas, between 0-1.\n     * Lower values improve performance for large canvases but may be less precise.\n     * Default is 1 (full resolution).\n     */\n    resolution?: number;\n    /** Optional. The rectangle to store the result in. */\n    output?: Rectangle;\n}\n\n/**\n * Measures the bounding box of a canvas's visible (non-transparent) pixels.\n *\n * This function analyzes the alpha channel of the canvas pixels to find the smallest\n * rectangle containing all non-transparent pixels. It's useful for optimizing sprite\n * rendering by trimming transparent borders.\n *\n * Uses an internal canvas with `willReadFrequently: true` for efficient pixel data access.\n * This internal canvas is reused between calls for better performance.\n * @example\n * ```typescript\n * // Basic usage - get trim bounds at full resolution\n * const bounds = getCanvasBoundingBox({ canvas: myCanvas });\n * console.log(bounds); // Rectangle{x: 10, y: 5, width: 100, height: 200}\n * // Optimized for performance with lower resolution scanning\n * const fastBounds = getCanvasBoundingBox({\n *     canvas: largeCanvas,\n *     width: largeCanvas.width,\n *     height: largeCanvas.height,\n *     resolution: 0.5\n * });\n * // Resolution of 0.5 means scanning at half size, much faster for large canvases\n *\n * // Using custom dimensions - only analyze part of the canvas\n * const partialBounds = getCanvasBoundingBox({ canvas: myCanvas, width: 100, height: 100 });\n * // Only analyzes a 100x100 region starting from top-left\n * ```\n * @param options - The options for measuring the bounding box, including the canvas to measure.\n * @returns The bounding box as a Rectangle containing the visible content.\n *          Returns Rectangle.EMPTY if the canvas is completely transparent.\n * @internal\n */\nexport function getCanvasBoundingBox(\n    options: GetCanvasBoundingBoxOptions,\n): Rectangle;\n/**\n * @param canvas\n * @param resolution\n * @internal\n * @deprecated since 8.10.0\n */\nexport function getCanvasBoundingBox(canvas: ICanvas, resolution?: number): Rectangle;\n/**\n * @param {...any} args\n * @internal\n */\nexport function getCanvasBoundingBox(...args: [GetCanvasBoundingBoxOptions] | [ICanvas, number?]): Rectangle\n{\n    let options = args[0] as GetCanvasBoundingBoxOptions;\n\n    if (!options.canvas)\n    {\n        options = { canvas: args[0] as ICanvas, resolution: args[1] };\n    }\n\n    const { canvas } = options; // canvas is correctly extracted from options\n\n    // Cap resolution at 1\n    const resolution = Math.min(options.resolution ?? 1, 1);\n    const width = options.width ?? canvas.width;\n    const height = options.height ?? canvas.height;\n    let output = options.output;\n\n    // Ensure internal canvas is large enough\n    ensureInternalCanvas(width, height);\n\n    if (!_internalContext)\n    {\n        throw new TypeError('Failed to get canvas 2D context');\n    }\n\n    // Set up for pixel replacement (no blending)\n    _internalContext.drawImage(\n        canvas as unknown as CanvasImageSource,\n        0, 0,\n        width, height,\n        0, 0,\n        width * resolution, height * resolution\n    );\n\n    // Get the image data at full resolution\n    const imageData = _internalContext.getImageData(0, 0, width, height);\n    const data = imageData.data;\n\n    let left = 0;\n    let top = 0;\n    let right = width - 1;\n    let bottom = height - 1;\n\n    while (top < height && checkRow(data, width, top)) ++top;\n    if (top === height) return Rectangle.EMPTY;\n    while (checkRow(data, width, bottom)) --bottom;\n    while (checkColumn(data, width, left, top, bottom)) ++left;\n    while (checkColumn(data, width, right, top, bottom)) --right;\n\n    ++right;\n    ++bottom;\n\n    _internalContext.globalCompositeOperation = 'source-over';\n    // draw the rect on the canvas\n    _internalContext.strokeRect(left, top, right - left, bottom - top);\n    _internalContext.globalCompositeOperation = 'copy';\n\n    output ??= new Rectangle();\n\n    output.set(left / resolution, top / resolution, (right - left) / resolution, (bottom - top) / resolution);\n\n    return output;\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1606, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextGenerator.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text/canvas/CanvasTextGenerator.ts"],"sourcesContent":["import { Color } from '../../../color/Color';\nimport { Rectangle } from '../../../maths/shapes/Rectangle';\nimport { type CanvasAndContext, CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\nimport { getCanvasBoundingBox } from '../../../utils/canvas/getCanvasBoundingBox';\nimport { type TextStyle } from '../TextStyle';\nimport { CanvasTextMetrics } from './CanvasTextMetrics';\nimport { fontStringFromTextStyle } from './utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from './utils/getCanvasFillStyle';\n\n/**\n * Temporary rectangle for getting the bounding box of the text.\n * @internal\n */\nconst tempRect = new Rectangle();\n\n/**\n * Utility for generating and managing canvas-based text rendering.\n *\n * This class is responsible for rendering text to canvas elements based on provided styles,\n * measuring the resulting text dimensions, and managing the lifecycle of canvas resources.\n *\n * CanvasTextGenerator supports:\n * - Text rendering with various styles (fill, stroke, gradient, etc.)\n * - Drop shadows and letter spacing\n * - Automatic trimming of transparent pixels\n * - Canvas resource pooling\n *\n * As a singleton, it's accessed via the exported `CanvasTextGenerator` constant.\n * @example\n * ```typescript\n * // Basic usage - render text to a canvas\n * import { CanvasTextGenerator } from 'pixi.js';\n * import { TextStyle } from 'pixi.js';\n *\n * // Create a text style\n * const style = new TextStyle({\n *   fontFamily: 'Arial',\n *   fontSize: 24,\n *   fill: 0xff1010,\n *   align: 'center',\n * });\n *\n * // Get a canvas with the text rendered to it\n * const { canvasAndContext, frame } = CanvasTextGenerator.getCanvasAndContext({\n *   text: 'Hello Pixi!',\n *   style,\n *   resolution: 1\n * });\n *\n * @internal\n */\nclass CanvasTextGeneratorClass\n{\n    /**\n     * Creates a canvas with the specified text rendered to it.\n     *\n     * Generates a canvas of appropriate size, renders the text with the provided style,\n     * and returns both the canvas/context and a Rectangle representing the text bounds.\n     *\n     * When trim is enabled in the style, the frame will represent the bounds of the\n     * non-transparent pixels, which can be smaller than the full canvas.\n     * @param options - The options for generating the text canvas\n     * @param options.text - The text to render\n     * @param options.style - The style to apply to the text\n     * @param options.resolution - The resolution of the canvas (defaults to 1)\n     * @param options.padding\n     * @returns An object containing the canvas/context and the frame (bounds) of the text\n     */\n    public getCanvasAndContext(options: {text: string, style: TextStyle, resolution?: number, padding?: number})\n    {\n        const { text, style, resolution = 1 } = options;\n\n        const padding = (style as TextStyle)._getFinalPadding();\n\n        // create a canvas with the word hello on it\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (padding * 2))) * resolution);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(width, height);\n\n        this._renderTextToCanvas(text, style, padding, resolution, canvasAndContext);\n\n        const frame = style.trim\n            ? getCanvasBoundingBox({ canvas: canvasAndContext.canvas, width, height, resolution: 1, output: tempRect })\n            : tempRect.set(0, 0, width, height);\n\n        return {\n            canvasAndContext,\n            frame\n        };\n    }\n\n    /**\n     * Returns a canvas and context to the pool.\n     *\n     * This should be called when you're done with the canvas to allow reuse\n     * and prevent memory leaks.\n     * @param canvasAndContext - The canvas and context to return to the pool\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     * @param text - The text to render\n     * @param style - The style of the text\n     * @param padding - The padding of the text\n     * @param resolution - The resolution of the text\n     * @param canvasAndContext - The canvas and context to render the text to\n     */\n    private _renderTextToCanvas(\n        text: string,\n        style: TextStyle,\n        padding: number,\n        resolution: number,\n        canvasAndContext: CanvasAndContext\n    ): void\n    {\n        const { canvas, context } = canvasAndContext;\n\n        const font = fontStringFromTextStyle(style);\n\n        const measured = CanvasTextMetrics.measureText(text || ' ', style);// , canvas);\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        const height = canvas.height;\n\n        context.resetTransform();\n        context.scale(resolution, resolution);\n        context.textBaseline = style.textBaseline;\n\n        // set stroke styles..\n\n        if (style._stroke?.width)\n        {\n            const strokeStyle = style._stroke;\n\n            context.lineWidth = strokeStyle.width;\n\n            context.miterLimit = strokeStyle.miterLimit;\n            context.lineJoin = strokeStyle.join;\n            context.lineCap = strokeStyle.cap;\n        }\n\n        // return;\n        context.font = font;\n\n        let linePositionX: number;\n        let linePositionY: number;\n\n        // require 2 passes if a shadow; the first to draw the drop shadow, the second to draw the text\n        const passesCount = style.dropShadow ? 2 : 1;\n\n        // For v4, we drew text at the colours of the drop shadow underneath the normal text. This gave the correct zIndex,\n        // but features such as alpha and shadowblur did not look right at all, since we were using actual text as a shadow.\n        //\n        // For v5.0.0, we moved over to just use the canvas API for drop shadows, which made them look much nicer and more\n        // visually please, but now because the stroke is drawn and then the fill, drop shadows would appear on both the fill\n        // and the stroke; and fill drop shadows would appear over the top of the stroke.\n        //\n        // For v5.1.1, the new route is to revert to v4 style of drawing text first to get the drop shadows underneath normal\n        // text, but instead drawing text in the correct location, we'll draw it off screen (-paddingY), and then adjust the\n        // drop shadow so only that appears on screen (+paddingY). Now we'll have the correct draw order of the shadow\n        // beneath the text, whilst also having the proper text shadow styling.\n        for (let i = 0; i < passesCount; ++i)\n        {\n            const isShadowPass = style.dropShadow && i === 0;\n            // we only want the drop shadow, so put text way off-screen\n            const dsOffsetText = isShadowPass ? Math.ceil(Math.max(1, height) + (padding * 2)) : 0;\n            const dsOffsetShadow = dsOffsetText * resolution;\n\n            if (isShadowPass)\n            {\n                // On Safari, text with gradient and drop shadows together do not position correctly\n                // if the scale of the canvas is not 1: https://bugs.webkit.org/show_bug.cgi?id=197689\n                // Therefore we'll set the styles to be a plain black whilst generating this drop shadow\n                context.fillStyle = 'black';\n                context.strokeStyle = 'black';\n\n                const shadowOptions = style.dropShadow;\n\n                const dropShadowColor = shadowOptions.color;\n                const dropShadowAlpha = shadowOptions.alpha;\n\n                context.shadowColor = Color.shared\n                    .setValue(dropShadowColor)\n                    .setAlpha(dropShadowAlpha)\n                    .toRgbaString();\n\n                const dropShadowBlur = shadowOptions.blur * resolution;\n                const dropShadowDistance = shadowOptions.distance * resolution;\n\n                context.shadowBlur = dropShadowBlur;\n                context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n                context.shadowOffsetY = (Math.sin(shadowOptions.angle) * dropShadowDistance) + dsOffsetShadow;\n            }\n            else\n            {\n                context.fillStyle = style._fill ? getCanvasFillStyle(style._fill, context, measured, padding * 2) : null;\n\n                if (style._stroke?.width)\n                {\n                    const strokePadding = (style._stroke.width * 0.5) + (padding * 2);\n\n                    context.strokeStyle = getCanvasFillStyle(style._stroke, context, measured, strokePadding);\n                }\n\n                context.shadowColor = 'black';\n            }\n\n            let linePositionYShift = (lineHeight - fontProperties.fontSize) / 2;\n\n            if (lineHeight - fontProperties.fontSize < 0)\n            {\n                linePositionYShift = 0;\n            }\n\n            const strokeWidth = style._stroke?.width ?? 0;\n\n            // draw lines line by line\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = strokeWidth / 2;\n                linePositionY = ((strokeWidth / 2) + (i * lineHeight)) + fontProperties.ascent + linePositionYShift;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style._stroke?.width)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + padding,\n                        linePositionY + padding - dsOffsetText,\n                        true\n                    );\n                }\n\n                if (style._fill !== undefined)\n                {\n                    this._drawLetterSpacing(\n                        lines[i],\n                        style,\n                        canvasAndContext,\n                        linePositionX + padding,\n                        linePositionY + padding - dsOffsetText\n                    );\n                }\n            }\n        }\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     *\n     * This method handles rendering text with the correct letter spacing, using either:\n     * 1. Native letter spacing if supported by the browser\n     * 2. Manual letter spacing calculation if not natively supported\n     *\n     * For manual letter spacing, it calculates the position of each character\n     * based on its width and the desired spacing.\n     * @param text - The text to draw\n     * @param style - The text style to apply\n     * @param canvasAndContext - The canvas and context to draw to\n     * @param x - Horizontal position to draw the text\n     * @param y - Vertical position to draw the text\n     * @param isStroke - Whether to render the stroke (true) or fill (false)\n     * @private\n     */\n    private _drawLetterSpacing(\n        text: string,\n        style: TextStyle,\n        canvasAndContext: CanvasAndContext,\n        x: number, y: number,\n        isStroke = false\n    ): void\n    {\n        const { context } = canvasAndContext;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        let useExperimentalLetterSpacing = false;\n\n        if (CanvasTextMetrics.experimentalLetterSpacingSupported)\n        {\n            if (CanvasTextMetrics.experimentalLetterSpacing)\n            {\n                context.letterSpacing = `${letterSpacing}px`;\n                context.textLetterSpacing = `${letterSpacing}px`;\n                useExperimentalLetterSpacing = true;\n            }\n            else\n            {\n                context.letterSpacing = '0px';\n                context.textLetterSpacing = '0px';\n            }\n        }\n\n        if (letterSpacing === 0 || useExperimentalLetterSpacing)\n        {\n            if (isStroke)\n            {\n                context.strokeText(text, x, y);\n            }\n            else\n            {\n                context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        let currentPosition = x;\n\n        const stringArray = CanvasTextMetrics.graphemeSegmenter(text);\n        let previousWidth = context.measureText(text).width;\n        let currentWidth = 0;\n\n        for (let i = 0; i < stringArray.length; ++i)\n        {\n            const currentChar = stringArray[i];\n\n            if (isStroke)\n            {\n                context.strokeText(currentChar, currentPosition, y);\n            }\n            else\n            {\n                context.fillText(currentChar, currentPosition, y);\n            }\n            let textStr = '';\n\n            for (let j = i + 1; j < stringArray.length; ++j)\n            {\n                textStr += stringArray[j];\n            }\n            currentWidth = context.measureText(textStr).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n}\n\n/** @internal */\nexport const CanvasTextGenerator = new CanvasTextGeneratorClass();\n"],"names":["i"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1813, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text/canvas/CanvasTextSystem.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { type Filter } from '../../../filters/Filter';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { type CanvasTextOptions, type Text } from '../Text';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextGenerator } from './CanvasTextGenerator';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @category rendering\n * @advanced\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    private readonly _activeTextures: Record<string, {\n        texture: Texture,\n        usageCount: number,\n    }> = {};\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    public getTexture(options: CanvasTextOptions): Texture;\n    public getTexture(\n        options: CanvasTextOptions | string,\n        _resolution?: number,\n        _style?: TextStyle,\n        _textKey?: string\n    ): Texture\n    {\n        if (typeof options === 'string')\n        {\n            // #if _DEBUG\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n            // #endif\n\n            options = {\n                text: options,\n                style: _style,\n                resolution: _resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        if (!(options.textureStyle instanceof TextureStyle))\n        {\n            options.textureStyle = new TextureStyle(options.textureStyle);\n        }\n\n        if (typeof options.text !== 'string')\n        {\n            options.text = options.text.toString();\n        }\n\n        const { text, style, textureStyle } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n            text: text as string,\n            style: style as TextStyle,\n            resolution,\n        });\n\n        const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n\n        if (textureStyle) texture.source.style = textureStyle as TextureStyle;\n\n        if (style.trim)\n        {\n            // reapply the padding to the frame\n            frame.pad(style.padding);\n            texture.frame.copyFrom(frame);\n\n            // We initially increased the frame size by a resolution factor\n            // to achieve a crisper display. Now we need to scale down the already\n            // trimmed frame to render the texture in the expected size.\n            texture.frame.scale(1 / resolution);\n            texture.updateUvs();\n        }\n\n        if (style.filters)\n        {\n            // apply the filters to the texture if required..\n            // this returns a new texture with the filters applied\n            const filteredTexture = this._applyFilters(texture, style.filters as Filter[]);\n\n            // return the original texture to the pool so we can reuse the next frame\n            this.returnTexture(texture);\n\n            CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n            // return the new texture with the filters applied\n            return filteredTexture;\n        }\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    /**\n     * Returns a texture that was created wit the above `getTexture` function.\n     * Handy if you are done with a texture and want to return it to the pool.\n     * @param texture - The texture to be returned.\n     */\n    public returnTexture(texture: Texture)\n    {\n        const source = texture.source;\n\n        source.resource = null;\n        source.uploadMethodId = 'unknown';\n        source.alphaMode = 'no-premultiply-alpha';\n\n        TexturePool.returnTexture(texture, true);\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     * @deprecated since 8.10.0\n     */\n    public renderTextToCanvas(): void\n    {\n        // #if _DEBUG\n        deprecation(\n            '8.10.0',\n            'CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead'\n        );\n        // #endif\n    }\n\n    /**\n     * Gets or creates a managed texture for a Text object. This method handles texture reuse and reference counting.\n     * @param text - The Text object that needs a texture\n     * @returns A Texture instance that represents the rendered text\n     * @remarks\n     * This method performs the following:\n     * 1. Sets the appropriate resolution based on auto-resolution settings\n     * 2. Checks if a texture already exists for the text's style\n     * 3. Creates a new texture if needed or returns an existing one\n     * 4. Manages reference counting for texture reuse\n     */\n    public getManagedTexture(text: Text)\n    {\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n        const textKey = text.styleKey;\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].texture;\n        }\n\n        const texture = this.getTexture({\n            text: text.text,\n            style: text.style,\n            resolution: text._resolution,\n            textureStyle: text.textureStyle,\n        });\n\n        this._activeTextures[textKey] = {\n            texture,\n            usageCount: 1,\n        };\n\n        return texture;\n    }\n\n    /**\n     * Decreases the reference count for a texture associated with a text key.\n     * When the reference count reaches zero, the texture is returned to the pool.\n     * @param textKey - The unique key identifying the text style configuration\n     * @remarks\n     * This method is crucial for memory management, ensuring textures are properly\n     * cleaned up when they are no longer needed by any Text instances.\n     */\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            this.returnTexture(activeTexture.texture);\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    /**\n     * Gets the current reference count for a texture associated with a text key.\n     * @param textKey - The unique key identifying the text style configuration\n     * @returns The number of Text instances currently using this texture\n     */\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey]?.usageCount ?? null;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    /**\n     * Applies the specified filters to the given texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n     * texture is set to 'premultiplied-alpha'.\n     * @param {Texture} texture - The texture to which the filters will be applied.\n     * @param {Filter[]} filters - The filters to apply to the texture.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     */\n    private _applyFilters(texture: Texture, filters: Filter[]): Texture\n    {\n        // Save the current render target so it can be restored later\n        const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n\n        // Apply the filters to the texture and get the resulting texture\n        const resultTexture = this._renderer.filter.generateFilteredTexture({\n            texture,\n            filters,\n        });\n\n        // Set the alpha mode of the resulting texture to 'premultiplied-alpha'\n\n        // Restore the previous render target\n        this._renderer.renderTarget.bind(currentRenderTarget, false);\n\n        // Return the resulting texture with the filters applied\n        return resultTexture;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        // Clean up active textures\n        for (const key in this._activeTextures)\n        {\n            if (this._activeTextures[key]) this.returnTexture(this._activeTextures[key].texture);\n        }\n        (this._activeTextures as null) = null;\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1991, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text/init.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text/init.ts"],"sourcesContent":["import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n"],"names":[],"mappings":";;;;;;;;AAIA,oOAAA,CAAW,GAAA,CAAI,6PAAgB,CAAA,CAAA;AAC/B,oOAAA,CAAW,GAAA,CAAI,yPAAc,CAAA","debugId":null}},
    {"offset": {"line": 2005, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/graphics/shared/Graphics.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/graphics/shared/Graphics.ts"],"sourcesContent":["import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { ViewContainer, type ViewContainerOptions } from '../../view/ViewContainer';\nimport { GraphicsContext } from './GraphicsContext';\nimport { type GraphicsGpuData } from './GraphicsPipe';\n\nimport type { ColorSource } from '../../../color/Color';\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContextDestroyOptions, DestroyOptions } from '../../container/destroyTypes';\nimport type { FillInput, FillStyle, StrokeStyle } from './FillTypes';\nimport type { GraphicsPath } from './path/GraphicsPath';\nimport type { RoundedPoint } from './path/roundShape';\n\n/**\n * Constructor options used for Graphics instances.\n * Configures the initial state and behavior of a Graphics object.\n * @example\n * ```ts\n * const graphics = new Graphics({\n *     roundPixels: true,\n *     position: { x: 100.5, y: 100.5 }\n * });\n *\n * // Reuse graphics context\n * const sharedContext = new GraphicsContext();\n * const graphics1 = new Graphics({ context: sharedContext });\n * const graphics2 = new Graphics({ context: sharedContext });\n * ```\n * @see {@link Graphics} For the graphics class implementation\n * @see {@link GraphicsContext} For the graphics context API\n * @category scene\n * @standard\n */\nexport interface GraphicsOptions extends PixiMixins.GraphicsOptions, ViewContainerOptions\n{\n    /**\n     * The GraphicsContext to use, useful for reuse and optimisation\n     * If not provided, a new GraphicsContext will be created.\n     * @example\n     * ```ts\n     * const sharedContext = new GraphicsContext();\n     * const graphics1 = new Graphics({ context: sharedContext });\n     * const graphics2 = new Graphics({ context: sharedContext });\n     * ```\n     */\n    context?: GraphicsContext;\n    /**\n     * Whether or not to round the x/y position.\n     * @default false\n     * @example\n     * ```ts\n     * const graphics = new Graphics({ roundPixels: true });\n     * ```\n     */\n    roundPixels?: boolean;\n}\n// eslint-disable-next-line requireExport/require-export-jsdoc, requireMemberAPI/require-member-api-doc\nexport interface Graphics extends PixiMixins.Graphics, ViewContainer<GraphicsGpuData> {}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them. It can also be used to create complex\n * masks and hit areas for interaction.\n * @example\n * ```ts\n * // Create a new graphics object\n * const graphics = new Graphics();\n *\n * // Draw a filled rectangle with a stroke\n * graphics\n *     .rect(0, 0, 100, 100)\n *     .fill({ color: 0xff0000 }) // Fill with red\n *     .stroke({ width: 2, color: 0x000000 }); // Stroke with black\n *\n * // Draw a complex shape\n * graphics\n *     .moveTo(50, 50)\n *     .lineTo(100, 100)\n *     .arc(100, 100, 50, 0, Math.PI)\n *     .closePath()\n *     .fill({ color: 0x00ff00, alpha: 0.5 }); // Fill the shape\n *\n * // Use as a mask\n * sprite.mask = graphics;\n * ```\n * @see {@link GraphicsContext} For the underlying drawing API\n * @see {@link GraphicsPath} For path creation\n * @category scene\n * @standard\n */\nexport class Graphics extends ViewContainer<GraphicsGpuData> implements Instruction\n{\n    /** @internal */\n    public override readonly renderPipeId: string = 'graphics';\n    /** @internal */\n    public batched: boolean;\n\n    private _context: GraphicsContext;\n    private readonly _ownedContext: GraphicsContext;\n\n    /**\n     * Creates a new Graphics object.\n     * @param options - Options for the Graphics.\n     */\n    constructor(options?: GraphicsOptions | GraphicsContext)\n    {\n        if (options instanceof GraphicsContext)\n        {\n            options = { context: options };\n        }\n\n        const { context, roundPixels, ...rest } = options || {};\n\n        super({\n            label: 'Graphics',\n            ...rest\n        });\n\n        if (!context)\n        {\n            this._context = this._ownedContext = new GraphicsContext();\n        }\n        else\n        {\n            this._context = context;\n        }\n\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.didViewUpdate = true;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    set context(context: GraphicsContext)\n    {\n        if (context === this._context) return;\n\n        this._context.off('update', this.onViewUpdate, this);\n\n        this._context = context;\n\n        // TODO store this bound function somewhere else..\n        this._context.on('update', this.onViewUpdate, this);\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * The underlying graphics context used for drawing operations.\n     * Controls how shapes and paths are rendered.\n     * @example\n     * ```ts\n     * // Create a shared context\n     * const sharedContext = new GraphicsContext();\n     *\n     * // Create graphics objects sharing the same context\n     * const graphics1 = new Graphics();\n     * const graphics2 = new Graphics();\n     *\n     * // Assign shared context\n     * graphics1.context = sharedContext;\n     * graphics2.context = sharedContext;\n     *\n     * // Both graphics will show the same shapes\n     * sharedContext\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @see {@link GraphicsContext} For drawing operations\n     * @see {@link GraphicsOptions} For context configuration\n     */\n    get context(): GraphicsContext\n    {\n        return this._context;\n    }\n\n    /**\n     * The local bounds of the graphics object.\n     * Returns the boundaries after all graphical operations but before any transforms.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a shape\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Get bounds information\n     * const bounds = graphics.bounds;\n     * console.log(bounds.width);  // 100\n     * console.log(bounds.height); // 100\n     * ```\n     * @readonly\n     * @see {@link Bounds} For bounds operations\n     * @see {@link Container#getBounds} For transformed bounds\n     */\n    override get bounds(): Bounds\n    {\n        return this._context.bounds;\n    }\n\n    /**\n     * Graphics objects do not need to update their bounds as the context handles this.\n     * @private\n     */\n    protected updateBounds(): void { /** */ }\n\n    /**\n     * Checks if the object contains the given point.\n     * Returns true if the point lies within the Graphics object's rendered area.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a shape\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Check point intersection\n     * if (graphics.containsPoint({ x: 50, y: 50 })) {\n     *     console.log('Point is inside rectangle!');\n     * }\n     * ```\n     * @param point - The point to check in local coordinates\n     * @returns True if the point is inside the Graphics object\n     * @see {@link Graphics#bounds} For bounding box checks\n     * @see {@link PointData} For point data structure\n     */\n    public override containsPoint(point: PointData)\n    {\n        return this._context.containsPoint(point);\n    }\n\n    /**\n     * Destroys this graphics renderable and optionally its context.\n     * @param options - Options parameter. A boolean will act as if all options\n     *\n     * If the context was created by this graphics and `destroy(false)` or `destroy()` is called\n     * then the context will still be destroyed.\n     *\n     * If you want to explicitly not destroy this context that this graphics created,\n     * then you should pass destroy({ context: false })\n     *\n     * If the context was passed in as an argument to the constructor then it will not be destroyed\n     * @example\n     * ```ts\n     * // Destroy the graphics and its context\n     * graphics.destroy();\n     * graphics.destroy(true);\n     * graphics.destroy({ context: true, texture: true, textureSource: true });\n     * ```\n     */\n    public override destroy(options?: DestroyOptions): void\n    {\n        if (this._ownedContext && !options)\n        {\n            this._ownedContext.destroy(options);\n        }\n        else if (options === true || (options as ContextDestroyOptions)?.context === true)\n        {\n            this._context.destroy(options);\n        }\n\n        (this._ownedContext as null) = null;\n        this._context = null;\n\n        super.destroy(options);\n    }\n\n    private _callContextMethod(method: keyof GraphicsContext, args: any[]): this\n    {\n        (this.context as any)[method](...args);\n\n        return this;\n    }\n\n    // --------------------------------------- GraphicsContext methods ---------------------------------------\n    /**\n     * Sets the current fill style of the graphics context.\n     * The fill style can be a color, gradient, pattern, or a complex style object.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color fill\n     * graphics\n     *     .setFillStyle({ color: 0xff0000 }) // Red fill\n     *     .rect(0, 0, 100, 100)\n     *     .fill();\n     *\n     * // Gradient fill\n     * const gradient = new FillGradient({\n     *    end: { x: 1, y: 0 },\n     *    colorStops: [\n     *         { offset: 0, color: 0xff0000 }, // Red at start\n     *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *         { offset: 1, color: 0x0000ff }, // Blue at end\n     *    ],\n     * });\n     *\n     * graphics\n     *     .setFillStyle(gradient)\n     *     .circle(100, 100, 50)\n     *     .fill();\n     *\n     * // Pattern fill\n     * const pattern = new FillPattern(texture);\n     * graphics\n     *     .setFillStyle({\n     *         fill: pattern,\n     *         alpha: 0.5\n     *     })\n     *     .rect(0, 0, 200, 200)\n     *     .fill();\n     * ```\n     * @param {FillInput} args - The fill style to apply\n     * @returns The Graphics instance for chaining\n     * @see {@link FillStyle} For fill style options\n     * @see {@link FillGradient} For gradient fills\n     * @see {@link FillPattern} For pattern fills\n     */\n    public setFillStyle(...args: Parameters<GraphicsContext['setFillStyle']>): this\n    {\n        return this._callContextMethod('setFillStyle', args);\n    }\n\n    /**\n     * Sets the current stroke style of the graphics context.\n     * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color stroke\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 2,\n     *         color: 0x000000\n     *     })\n     *     .rect(0, 0, 100, 100)\n     *     .stroke();\n     *\n     * // Complex stroke style\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 4,\n     *         color: 0xff0000,\n     *         alpha: 0.5,\n     *         join: 'round',\n     *         cap: 'round',\n     *         alignment: 0.5\n     *     })\n     *     .circle(100, 100, 50)\n     *     .stroke();\n     *\n     * // Gradient stroke\n     * const gradient = new FillGradient({\n     *    end: { x: 1, y: 0 },\n     *    colorStops: [\n     *         { offset: 0, color: 0xff0000 }, // Red at start\n     *         { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *         { offset: 1, color: 0x0000ff }, // Blue at end\n     *    ],\n     * });\n     *\n     * graphics\n     *     .setStrokeStyle({\n     *         width: 10,\n     *         fill: gradient\n     *     })\n     *     .poly([0,0, 100,50, 0,100])\n     *     .stroke();\n     * ```\n     * @param {StrokeInput} args - The stroke style to apply\n     * @returns The Graphics instance for chaining\n     * @see {@link StrokeStyle} For stroke style options\n     * @see {@link FillGradient} For gradient strokes\n     * @see {@link FillPattern} For pattern strokes\n     */\n    public setStrokeStyle(...args: Parameters<GraphicsContext['setStrokeStyle']>): this\n    {\n        return this._callContextMethod('setStrokeStyle', args);\n    }\n\n    /**\n     * Fills the current or given path with the current fill style or specified style.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Fill with direct color\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .fill('red'); // Red fill\n     *\n     * // Fill with texture\n     * graphics\n     *    .rect(0, 0, 100, 100)\n     *    .fill(myTexture); // Fill with texture\n     *\n     * // Fill with complex style\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .fill({\n     *         color: 0x00ff00,\n     *         alpha: 0.5,\n     *         texture: myTexture,\n     *         matrix: new Matrix()\n     *     });\n     *\n     * // Fill with gradient\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *         { offset: 0, color: 0xff0000 },\n     *         { offset: 0.5, color: 0x00ff00 },\n     *         { offset: 1, color: 0x0000ff },\n     *     ],\n     * });\n     *\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill(gradient);\n     * ```\n     * @param {FillInput} style - The style to fill the path with. Can be:\n     * - A ColorSource\n     * - A gradient\n     * - A pattern\n     * - A complex style object\n     * If omitted, uses current fill style.\n     * @returns The Graphics instance for chaining\n     * @see {@link FillStyle} For fill style options\n     * @see {@link FillGradient} For gradient fills\n     * @see {@link FillPattern} For pattern fills\n     */\n    public fill(style?: FillInput): this;\n    /** @deprecated 8.0.0 */\n    public fill(color: ColorSource, alpha?: number): this;\n    public fill(...args: [FillStyle | ColorSource, number?]): this\n    {\n        return this._callContextMethod('fill', args);\n    }\n    /**\n     * Strokes the current path with the current stroke style or specified style.\n     * Outlines the shape using the stroke settings.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Stroke with direct color\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .stroke({\n     *         width: 2,\n     *         color: 0xff0000\n     *     }); // 2px red stroke\n     *\n     * // Fill with texture\n     * graphics\n     *    .rect(0, 0, 100, 100)\n     *    .stroke(myTexture); // Fill with texture\n     *\n     * // Stroke with gradient\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *         { offset: 0, color: 0xff0000 },\n     *         { offset: 0.5, color: 0x00ff00 },\n     *         { offset: 1, color: 0x0000ff },\n     *     ],\n     * });\n     *\n     * graphics\n     *     .rect(0, 0, 100, 100)\n     *     .stroke({\n     *         width: 4,\n     *         fill: gradient,\n     *         alignment: 0.5,\n     *         join: 'round'\n     *     });\n     * ```\n     * @param {StrokeStyle} args - Optional stroke style to apply. Can be:\n     * - A stroke style object with width, color, etc.\n     * - A gradient\n     * - A pattern\n     * If omitted, uses current stroke style.\n     * @returns The Graphics instance for chaining\n     * @see {@link StrokeStyle} For stroke style options\n     * @see {@link FillGradient} For gradient strokes\n     * @see {@link setStrokeStyle} For setting default stroke style\n     */\n    public stroke(...args: Parameters<GraphicsContext['stroke']>): this\n    {\n        return this._callContextMethod('stroke', args);\n    }\n    /**\n     * Adds a texture to the graphics context. This method supports multiple ways to draw textures\n     * including basic textures, tinted textures, and textures with custom dimensions.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic texture drawing\n     * graphics.texture(myTexture);\n     *\n     * // Tinted texture with position\n     * graphics.texture(myTexture, 0xff0000); // Red tint\n     *\n     * // Texture with custom position and dimensions\n     * graphics\n     *     .texture(\n     *         myTexture,    // texture\n     *         0xffffff,     // white tint\n     *         100, 100,     // position\n     *         200, 150      // dimensions\n     *     );\n     * ```\n     * Basic texture drawing:\n     * @param texture - The Texture object to use.\n     * @returns The instance of the current Graphics for chaining.\n     *\n     * Extended texture drawing:\n     * @param texture - The Texture object to use.\n     *        tint - A ColorSource to tint the texture (defaults to white).\n     *        dx - The x-coordinate for the texture placement.\n     *        dy - The y-coordinate for the texture placement.\n     *        dw - The width to draw the texture (defaults to texture width).\n     *        dh - The height to draw the texture (defaults to texture height).\n     * @returns The instance of the current Graphics for chaining.\n     * @see {@link Texture} For texture creation\n     * @see {@link FillPattern} For pattern fills\n     */\n    public texture(texture: Texture): this;\n    public texture(texture: Texture, tint?: ColorSource, dx?: number, dy?: number, dw?: number, dh?: number): this;\n    public texture(...args: [Texture, number?, number?, number?, number?, number?]): this\n    {\n        return this._callContextMethod('texture', args);\n    }\n    /**\n     * Resets the current path. Any previous path and its commands are discarded and a new path is\n     * started. This is typically called before beginning a new shape or series of drawing commands.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * graphics\n     *     .circle(150, 150, 50)\n     *     .fill({ color: 0x00ff00 })\n     *     .beginPath() // Starts a new path\n     *     .circle(250, 150, 50)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @returns The Graphics instance for chaining\n     * @see {@link Graphics#moveTo} For starting a new subpath\n     * @see {@link Graphics#closePath} For closing the current path\n     */\n    public beginPath(): this\n    {\n        return this._callContextMethod('beginPath', []);\n    }\n    /**\n     * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by\n     * subtracting a path from the previously drawn path.\n     *\n     * If a hole is not completely in a shape, it will fail to cut correctly.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw outer circle\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *     .circle(100, 100, 25) // Inner circle\n     *     .cut() // Cuts out the inner circle from the outer circle\n     * ```\n     */\n    public cut(): this\n    {\n        return this._callContextMethod('cut', []);\n    }\n    /**\n     * Adds an arc to the current path, which is centered at (x, y) with the specified radius,\n     * starting and ending angles, and direction.\n     * @example\n     * ```ts\n     * // Draw a simple arc (quarter circle)\n     * const graphics = new Graphics();\n     * graphics\n     *     .arc(100, 100, 50, 0, Math.PI/2)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Draw a full circle using an arc\n     * graphics\n     *     .arc(200, 200, 30, 0, Math.PI * 2)\n     *     .stroke({ color: 0x00ff00 });\n     *\n     * // Draw a counterclockwise arc\n     * graphics\n     *     .arc(150, 150, 40, Math.PI, 0, true)\n     *     .stroke({ width: 2, color: 0x0000ff });\n     * ```\n     * @param x - The x-coordinate of the arc's center\n     * @param y - The y-coordinate of the arc's center\n     * @param radius - The arc's radius (must be positive)\n     * @param startAngle - The starting point of the arc, in radians\n     * @param endAngle - The end point of the arc, in radians\n     * @param counterclockwise - Optional. If true, draws the arc counterclockwise.\n     *                          If false (default), draws clockwise.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#circle} For drawing complete circles\n     * @see {@link Graphics#arcTo} For drawing arcs between points\n     * @see {@link Graphics#arcToSvg} For SVG-style arc drawing\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise?: boolean): this;\n    public arc(...args: Parameters<GraphicsContext['arc']>): this\n    {\n        return this._callContextMethod('arc', args);\n    }\n    /**\n     * Adds an arc to the current path that connects two points using a radius.\n     * The arc is drawn between the current point and the specified end point,\n     * using the given control point to determine the curve of the arc.\n     * @example\n     * ```ts\n     * // Draw a simple curved corner\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .arcTo(100, 50, 100, 100, 20) // Rounded corner with 20px radius\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create a rounded rectangle using arcTo\n     * graphics\n     *     .moveTo(150, 150)\n     *     .arcTo(250, 150, 250, 250, 30) // Top right corner\n     *     .arcTo(250, 250, 150, 250, 30) // Bottom right corner\n     *     .arcTo(150, 250, 150, 150, 30) // Bottom left corner\n     *     .arcTo(150, 150, 250, 150, 30) // Top left corner\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param x1 - The x-coordinate of the control point\n     * @param y1 - The y-coordinate of the control point\n     * @param x2 - The x-coordinate of the end point\n     * @param y2 - The y-coordinate of the end point\n     * @param radius - The radius of the arc in pixels (must be positive)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#arc} For drawing arcs using center point and angles\n     * @see {@link Graphics#arcToSvg} For SVG-style arc drawing\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this;\n    public arcTo(...args: Parameters<GraphicsContext['arcTo']>): this\n    {\n        return this._callContextMethod('arcTo', args);\n    }\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * This is particularly useful when converting SVG paths to Graphics or creating complex curved shapes.\n     * @example\n     * ```ts\n     * // Draw a simple elliptical arc\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(100, 100)\n     *     .arcToSvg(50, 30, 0, 0, 1, 200, 100)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create a complex path with rotated elliptical arc\n     * graphics\n     *     .moveTo(150, 150)\n     *     .arcToSvg(\n     *         60,    // rx\n     *         30,    // ry\n     *         45,    // x-axis rotation (45 degrees)\n     *         1,     // large arc flag\n     *         0,     // sweep flag\n     *         250,   // end x\n     *         200    // end y\n     *     )\n     *     .stroke({ width: 4, color: 0x00ff00 });\n     *\n     * // Chain multiple arcs for complex shapes\n     * graphics\n     *     .moveTo(300, 100)\n     *     .arcToSvg(40, 20, 0, 0, 1, 350, 150)\n     *     .arcToSvg(40, 20, 0, 0, 1, 300, 200)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param rx - The x-radius of the ellipse (must be non-negative)\n     * @param ry - The y-radius of the ellipse (must be non-negative)\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative to the x-axis, in degrees\n     * @param largeArcFlag - Either 0 or 1, determines if the larger of the two possible arcs is chosen (1) or not (0)\n     * @param sweepFlag - Either 0 or 1, determines if the arc should be swept in\n     *                    a positive angle direction (1) or negative (0)\n     * @param x - The x-coordinate of the arc's end point\n     * @param y - The y-coordinate of the arc's end point\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#arc} For simple circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     * @see {@link Graphics#svg} For parsing complete SVG paths\n     */\n    public arcToSvg(\n        rx: number, ry: number, xAxisRotation: number, largeArcFlag: number, sweepFlag: number, x: number, y: number\n    ): this;\n    public arcToSvg(...args: Parameters<GraphicsContext['arcToSvg']>): this\n    {\n        return this._callContextMethod('arcToSvg', args);\n    }\n    /**\n     * Adds a cubic Bézier curve to the path, from the current point to the specified end point.\n     * The curve is influenced by two control points that define its shape and curvature.\n     * @example\n     * ```ts\n     * // Draw a simple curved line\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .bezierCurveTo(\n     *         100, 25,   // First control point\n     *         150, 75,   // Second control point\n     *         200, 50    // End point\n     *     )\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Adjust curve smoothness\n     * graphics\n     *     .moveTo(50, 200)\n     *     .bezierCurveTo(\n     *         100, 150,\n     *         200, 250,\n     *         250, 200,\n     *         0.5         // Smoothness factor\n     *     )\n     *     .stroke({ width: 4, color: 0x0000ff });\n     * ```\n     * @param cp1x - The x-coordinate of the first control point\n     * @param cp1y - The y-coordinate of the first control point\n     * @param cp2x - The x-coordinate of the second control point\n     * @param cp2y - The y-coordinate of the second control point\n     * @param x - The x-coordinate of the end point\n     * @param y - The y-coordinate of the end point\n     * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#quadraticCurveTo} For simpler curves with one control point\n     * @see {@link Graphics#arc} For circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number, smoothness?: number\n    ): this;\n    public bezierCurveTo(...args: Parameters<GraphicsContext['bezierCurveTo']>): this\n    {\n        return this._callContextMethod('bezierCurveTo', args);\n    }\n    /**\n     * Closes the current path by drawing a straight line back to the start point.\n     *\n     * This is useful for completing shapes and ensuring they are properly closed for fills.\n     * @example\n     * ```ts\n     * // Create a triangle with closed path\n     * const graphics = new Graphics();\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 100)\n     *     .lineTo(0, 100)\n     *     .closePath()\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#beginPath} For starting a new path\n     * @see {@link Graphics#fill} For filling closed paths\n     * @see {@link Graphics#stroke} For stroking paths\n     */\n    public closePath(): this\n    {\n        return this._callContextMethod('closePath', []);\n    }\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic ellipse\n     * graphics\n     *     .ellipse(100, 100, 50, 30)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw an ellipse with stroke\n     * graphics\n     *     .ellipse(200, 100, 70, 40)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the center of the ellipse\n     * @param y - The y-coordinate of the center of the ellipse\n     * @param radiusX - The horizontal radius of the ellipse\n     * @param radiusY - The vertical radius of the ellipse\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#circle} For drawing perfect circles\n     * @see {@link Graphics#arc} For drawing partial circular arcs\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number): this;\n    public ellipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        return this._callContextMethod('ellipse', args);\n    }\n    /**\n     * Draws a circle shape at the specified location with the given radius.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple filled circle\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a circle with gradient fill\n     * const gradient = new FillGradient({\n     *     end: { x: 1, y: 0 },\n     *     colorStops: [\n     *           { offset: 0, color: 0xff0000 }, // Red at start\n     *           { offset: 0.5, color: 0x00ff00 }, // Green at middle\n     *           { offset: 1, color: 0x0000ff }, // Blue at end\n     *     ],\n     * });\n     *\n     * graphics\n     *     .circle(250, 100, 40)\n     *     .fill({ fill: gradient });\n     * ```\n     * @param x - The x-coordinate of the center of the circle\n     * @param y - The y-coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#ellipse} For drawing ellipses\n     * @see {@link Graphics#arc} For drawing partial circles\n     */\n    public circle(x: number, y: number, radius: number): this;\n    public circle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        return this._callContextMethod('circle', args);\n    }\n    /**\n     * Adds another `GraphicsPath` to this path, optionally applying a transformation.\n     * This allows for reuse of complex paths and shapes across different graphics instances.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * // Create a reusable path\n     * const heartPath = new GraphicsPath()\n     *     .moveTo(0, 0)\n     *     .bezierCurveTo(-50, -25, -50, -75, 0, -100)\n     *     .bezierCurveTo(50, -75, 50, -25, 0, 0);\n     *\n     * // Use the path multiple times\n     * graphics\n     *     .path(heartPath)\n     *     .fill({ color: 0xff0000 })\n     *     .translateTransform(200, 200)\n     *     .path(heartPath)\n     *     .fill({ color: 0xff0000, alpha: 0.5 });\n     * ```\n     * @param path - The `GraphicsPath` to add to the current path\n     * @returns The Graphics instance for method chaining\n     * @see {@link GraphicsPath} For creating reusable paths\n     * @see {@link Matrix} For creating transformations\n     * @see {@link Graphics#transform} For applying transformations\n     */\n    public path(path: GraphicsPath): this;\n    public path(...args: Parameters<GraphicsContext['path']>): this\n    {\n        return this._callContextMethod('path', args);\n    }\n    /**\n     * Connects the current point to a new point with a straight line.\n     * Any subsequent drawing commands will start from this new point.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a triangle\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 100)\n     *     .lineTo(0, 100)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Create a complex shape with multiple lines\n     * graphics\n     *     .moveTo(200, 50)\n     *     .lineTo(250, 50)\n     *     .lineTo(250, 100)\n     *     .lineTo(200, 100)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the line's end point\n     * @param y - The y-coordinate of the line's end point\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#moveTo} For starting a new sub-path\n     */\n    public lineTo(x: number, y: number): this;\n    public lineTo(...args: Parameters<GraphicsContext['lineTo']>): this\n    {\n        return this._callContextMethod('lineTo', args);\n    }\n    /**\n     * Sets the starting point for a new sub-path.\n     *\n     * Moves the \"pen\" to a new location without drawing a line.\n     * Any subsequent drawing commands will start from this point.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Create multiple separate lines\n     * graphics\n     *     .moveTo(50, 50)\n     *     .lineTo(100, 50)\n     *     .moveTo(50, 100)    // Start a new line\n     *     .lineTo(100, 100)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Create disconnected shapes\n     * graphics\n     *     .moveTo(150, 50)\n     *     .rect(150, 50, 50, 50)\n     *     .fill({ color: 0x00ff00 })\n     *     .moveTo(250, 50)    // Start a new shape\n     *     .circle(250, 75, 25)\n     *     .fill({ color: 0x0000ff });\n     *\n     * // Position before curved paths\n     * graphics\n     *     .moveTo(300, 50)\n     *     .bezierCurveTo(\n     *         350, 25,   // Control point 1\n     *         400, 75,   // Control point 2\n     *         450, 50    // End point\n     *     )\n     *     .stroke({ width: 3, color: 0xff00ff });\n     * ```\n     * @param x - The x-coordinate to move to\n     * @param y - The y-coordinate to move to\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#lineTo} For drawing lines\n     * @see {@link Graphics#beginPath} For starting a completely new path\n     */\n    public moveTo(x: number, y: number): this;\n    public moveTo(...args: Parameters<GraphicsContext['moveTo']>): this\n    {\n        return this._callContextMethod('moveTo', args);\n    }\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple curve\n     * graphics\n     *     .moveTo(50, 50)\n     *     .quadraticCurveTo(100, 25, 150, 50)\n     *     .stroke({ width: 2, color: 0xff0000 });\n     *\n     * // Adjust curve smoothness\n     * graphics\n     *     .moveTo(50, 200)\n     *     .quadraticCurveTo(\n     *         150, 150,   // Control point\n     *         250, 200,   // End point\n     *         0.5         // Smoothness factor\n     *     )\n     *     .stroke({\n     *         width: 4,\n     *         color: 0x0000ff,\n     *         alpha: 0.7\n     *     });\n     * ```\n     * @param cpx - The x-coordinate of the control point\n     * @param cpy - The y-coordinate of the control point\n     * @param x - The x-coordinate of the end point\n     * @param y - The y-coordinate of the end point\n     * @param smoothness - Optional parameter to adjust the curve's smoothness (0-1)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#bezierCurveTo} For curves with two control points\n     * @see {@link Graphics#arc} For circular arcs\n     * @see {@link Graphics#arcTo} For connecting points with circular arcs\n     */\n    public quadraticCurveTo(cpx: number, cpy: number, x: number, y: number, smoothness?: number): this;\n    public quadraticCurveTo(...args: Parameters<GraphicsContext['quadraticCurveTo']>): this\n    {\n        return this._callContextMethod('quadraticCurveTo', args);\n    }\n    /**\n     * Draws a rectangle shape.\n     *\n     * This method adds a new rectangle path to the current drawing.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple filled rectangle\n     * graphics\n     *     .rect(50, 50, 100, 75)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Rectangle with stroke\n     * graphics\n     *     .rect(200, 50, 100, 75)\n     *     .stroke({ width: 2, color: 0x00ff00 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param w - The width of the rectangle\n     * @param h - The height of the rectangle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     * @see {@link Graphics#filletRect} For drawing rectangles with filleted corners\n     * @see {@link Graphics#chamferRect} For drawing rectangles with chamfered corners\n     */\n\n    public rect(x: number, y: number, w: number, h: number): this;\n    public rect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        return this._callContextMethod('rect', args);\n    }\n    /**\n     * Draws a rectangle with rounded corners. The corner radius can be specified to\n     * determine how rounded the corners should be.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic rounded rectangle\n     * graphics\n     *     .roundRect(50, 50, 100, 75, 15)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param w - The width of the rectangle\n     * @param h - The height of the rectangle\n     * @param radius - The radius of the rectangle's corners (must be non-negative)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#rect} For drawing rectangles with sharp corners\n     * @see {@link Graphics#filletRect} For drawing rectangles with filleted corners\n     * @see {@link Graphics#chamferRect} For drawing rectangles with chamfered corners\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number): this;\n    public roundRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        return this._callContextMethod('roundRect', args);\n    }\n    /**\n     * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,\n     * which can be both open and closed.\n     *\n     * An optional transformation can be applied, enabling the polygon to be scaled,\n     * rotated, or translated as needed.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a triangle using array of numbers [x1,y1, x2,y2, x3,y3]\n     * graphics\n     *     .poly([50,50, 100,100, 0,100], true)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a polygon using point objects\n     * graphics\n     *     .poly([\n     *         { x: 200, y: 50 },\n     *         { x: 250, y: 100 },\n     *         { x: 200, y: 150 },\n     *         { x: 150, y: 100 }\n     *     ])\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Draw an open polygon with stroke\n     * graphics\n     *     .poly([300,50, 350,50, 350,100, 300,100], false)\n     *     .stroke({\n     *         width: 2,\n     *         color: 0x0000ff,\n     *         join: 'round'\n     *     });\n     * ```\n     * @param points - An array of numbers [x1,y1, x2,y2, ...] or an array of point objects [{x,y}, ...]\n     *                representing the vertices of the polygon in sequence\n     * @param close - Whether to close the polygon path by connecting the last point to the first.\n     *               Default is true.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing regular polygons\n     * @see {@link Graphics#roundPoly} For drawing polygons with rounded corners\n     * @see {@link Graphics#star} For drawing star shapes\n     */\n    public poly(points: number[] | PointData[], close?: boolean): this;\n    public poly(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        return this._callContextMethod('poly', args);\n    }\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal,\n     * making shapes like triangles, squares, pentagons, etc.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a simple triangle (3 sides)\n     * graphics\n     *     .regularPoly(100, 100, 50, 3)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a hexagon (6 sides) with rotation\n     * graphics\n     *     .regularPoly(\n     *         250, 100,    // center position\n     *         40,          // radius\n     *         6,           // sides\n     *         Math.PI / 6  // rotation (30 degrees)\n     *     )\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     *\n     * // Draw an octagon (8 sides) with transform\n     * const transform = new Matrix()\n     *     .scale(1.5, 1)      // stretch horizontally\n     *     .rotate(Math.PI/4); // rotate 45 degrees\n     *\n     * graphics\n     *     .regularPoly(400, 100, 30, 8, 0, transform)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param x - The x-coordinate of the center of the polygon\n     * @param y - The y-coordinate of the center of the polygon\n     * @param radius - The radius of the circumscribed circle of the polygon\n     * @param sides - The number of sides of the polygon (must be 3 or more)\n     * @param rotation - The rotation angle of the polygon in radians (default: 0)\n     * @param transform - Optional Matrix to transform the polygon's shape\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#roundPoly} For drawing polygons with rounded corners\n     * @see {@link Graphics#star} For drawing star shapes\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation?: number, transform?: Matrix): this;\n    public regularPoly(...args: Parameters<GraphicsContext['regularPoly']>): this\n    {\n        return this._callContextMethod('regularPoly', args);\n    }\n    /**\n     * Draws a polygon with rounded corners.\n     *\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic rounded triangle\n     * graphics\n     *     .roundPoly(100, 100, 50, 3, 10)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a rounded hexagon with rotation\n     * graphics\n     *     .roundPoly(\n     *         250, 150,     // center position\n     *         40,           // radius\n     *         6,            // sides\n     *         8,            // corner radius\n     *         Math.PI / 6   // rotation (30 degrees)\n     *     )\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the center of the polygon\n     * @param y - The y-coordinate of the center of the polygon\n     * @param radius - The radius of the circumscribed circle of the polygon\n     * @param sides - The number of sides of the polygon (must be 3 or more)\n     * @param corner - The radius of the corner rounding (must be non-negative)\n     * @param rotation - The rotation angle of the polygon in radians (default: 0)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing polygons without rounded corners\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     */\n    public roundPoly(x: number, y: number, radius: number, sides: number, corner: number, rotation?: number): this;\n    public roundPoly(...args: Parameters<GraphicsContext['roundPoly']>): this\n    {\n        return this._callContextMethod('roundPoly', args);\n    }\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a custom shape with rounded corners\n     * graphics\n     *     .roundShape([\n     *         { x: 100, y: 100, radius: 20 },\n     *         { x: 200, y: 100, radius: 10 },\n     *         { x: 200, y: 200, radius: 15 },\n     *         { x: 100, y: 200, radius: 5 }\n     *     ], 10)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using quadratic curves for corners\n     * graphics\n     *     .roundShape([\n     *         { x: 250, y: 100 },\n     *         { x: 350, y: 100 },\n     *         { x: 350, y: 200 },\n     *         { x: 250, y: 200 }\n     *     ], 15, true, 0.5)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     *\n     * // Shape with varying corner radii\n     * graphics\n     *     .roundShape([\n     *         { x: 400, y: 100, radius: 30 },\n     *         { x: 500, y: 100, radius: 5 },\n     *         { x: 450, y: 200, radius: 15 }\n     *     ], 10)\n     *     .fill({ color: 0x0000ff, alpha: 0.5 });\n     * ```\n     * @param points - An array of `RoundedPoint` representing the corners of the shape.\n     *                Each point can have its own radius or use the default.\n     *                A minimum of 3 points is required.\n     * @param radius - The default radius for corners without a specific radius defined.\n     *                Applied to any point that doesn't specify its own radius.\n     * @param useQuadratic - When true, corners are drawn using quadratic curves instead\n     *                      of arcs, creating a different visual style. Defaults to false.\n     * @param smoothness - Controls the smoothness of quadratic corners when useQuadratic\n     *                    is true. Values range from 0-1, higher values create smoother curves.\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For drawing rectangles with rounded corners\n     * @see {@link Graphics#roundPoly} For drawing regular polygons with rounded corners\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic?: boolean, smoothness?: number): this;\n    public roundShape(...args: Parameters<GraphicsContext['roundShape']>): this\n    {\n        return this._callContextMethod('roundShape', args);\n    }\n    /**\n     * Draws a rectangle with fillet corners. Unlike rounded rectangles, this supports negative corner\n     * radii which create external rounded corners rather than internal ones.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a rectangle with internal fillets\n     * graphics\n     *     .filletRect(50, 50, 100, 80, 15)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Draw a rectangle with external fillets\n     * graphics\n     *     .filletRect(200, 50, 100, 80, -20)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param fillet - The radius of the corner fillets (can be positive or negative)\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For standard rounded corners\n     * @see {@link Graphics#chamferRect} For angled corners\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this;\n    public filletRect(...args: Parameters<GraphicsContext['filletRect']>): this\n    {\n        return this._callContextMethod('filletRect', args);\n    }\n    /**\n     * Draws a rectangle with chamfered (angled) corners. Each corner is cut off at\n     * a 45-degree angle based on the chamfer size.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic chamfered rectangle\n     * graphics\n     *     .chamferRect(50, 50, 100, 80, 15)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Add transform and stroke\n     * const transform = new Matrix()\n     *     .rotate(Math.PI / 4); // 45 degrees\n     *\n     * graphics\n     *     .chamferRect(200, 50, 100, 80, 20, transform)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the top-left corner of the rectangle\n     * @param y - The y-coordinate of the top-left corner of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param chamfer - The size of the corner chamfers (must be non-zero)\n     * @param transform - Optional Matrix to transform the rectangle\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#roundRect} For rounded corners\n     * @see {@link Graphics#filletRect} For rounded corners with negative radius support\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this;\n    public chamferRect(...args: Parameters<GraphicsContext['chamferRect']>): this\n    {\n        return this._callContextMethod('chamferRect', args);\n    }\n    /**\n     * Draws a star shape centered at a specified location. This method allows for the creation\n     * of stars with a variable number of points, outer radius, optional inner radius, and rotation.\n     *\n     * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.\n     * An optional transformation can be applied to scale, rotate, or translate the star as needed.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw a basic 5-pointed star\n     * graphics\n     *     .star(100, 100, 5, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Star with custom inner radius\n     * graphics\n     *     .star(250, 100, 6, 50, 20)\n     *     .fill({ color: 0x00ff00 })\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param x - The x-coordinate of the center of the star\n     * @param y - The y-coordinate of the center of the star\n     * @param points - The number of points on the star (must be >= 3)\n     * @param radius - The outer radius of the star (distance from center to point tips)\n     * @param innerRadius - Optional. The inner radius of the star (distance from center to inner vertices).\n     *                     If not specified, defaults to half of the outer radius\n     * @param rotation - Optional. The rotation of the star in radians. Default is 0,\n     *                  which aligns one point straight up\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#regularPoly} For drawing regular polygons\n     * @see {@link Graphics#poly} For drawing custom polygons\n     * @see {@link Graphics#path} For creating custom shapes\n     */\n    public star(x: number, y: number, points: number, radius: number, innerRadius?: number, rotation?: number): this;\n    public star(...args: Parameters<GraphicsContext['star']>): this\n    {\n        return this._callContextMethod('star', args);\n    }\n    /**\n     * Parses and renders an SVG string into the graphics context. This allows for complex shapes\n     * and paths defined in SVG format to be drawn within the graphics context.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     * graphics\n     *     .svg(`\n     *         <path d=\"M 50,50 L 100,50 L 100,100 L 50,100 Z\"\n     *               fill=\"blue\" />\n     *         <circle cx=\"150\" cy=\"75\" r=\"25\"\n     *               fill=\"green\" />\n     *     `)\n     *     .stroke({ width: 2, color: 0x000000 });\n     * ```\n     * @param svg - The SVG string to be parsed and rendered\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#path} For adding custom paths\n     * @see {@link Graphics#fill} For filling shapes after SVG parsing\n     * @see {@link Graphics#stroke} For stroking shapes after SVG parsing\n     */\n    public svg(svg: string): this;\n    public svg(...args: Parameters<GraphicsContext['svg']>): this\n    {\n        return this._callContextMethod('svg', args);\n    }\n    /**\n     * Restores the most recently saved graphics state by popping the top of the graphics state stack.\n     * This includes transformations, fill styles, and stroke styles.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Save current state\n     * graphics.save();\n     *\n     * // Make temporary changes\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .setFillStyle({ color: 0xff0000 })\n     *     .circle(0, 0, 50)\n     *     .fill();\n     *\n     * // Restore to previous state\n     * graphics.restore();\n     *\n     * // Draw with original transform and styles\n     * graphics\n     *     .circle(50, 50, 30)\n     *     .fill();\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#save} For saving the current state\n     */\n    public restore(): this;\n    public restore(...args: Parameters<GraphicsContext['restore']>): this\n    {\n        return this._callContextMethod('restore', args);\n    }\n    /**\n     * Saves the current graphics state onto a stack. The state includes:\n     * - Current transformation matrix\n     * - Current fill style\n     * - Current stroke style\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Save state before complex operations\n     * graphics.save();\n     *\n     * // Create transformed and styled shape\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .rotateTransform(Math.PI / 4)\n     *     .setFillStyle({\n     *         color: 0xff0000,\n     *         alpha: 0.5\n     *     })\n     *     .rect(-25, -25, 50, 50)\n     *     .fill();\n     *\n     * // Restore to original state\n     * graphics.restore();\n     *\n     * // Continue drawing with previous state\n     * graphics\n     *     .circle(50, 50, 25)\n     *     .fill();\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#restore} For restoring the saved state\n     * @see {@link Graphics#setTransform} For setting transformations\n     */\n    public save(): this\n    {\n        return this._callContextMethod('save', []);\n    }\n    /**\n     * Returns the current transformation matrix of the graphics context.\n     * This matrix represents all accumulated transformations including translate, scale, and rotate.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Apply some transformations\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .rotateTransform(Math.PI / 4);\n     *\n     * // Get the current transform matrix\n     * const matrix = graphics.getTransform();\n     * console.log(matrix.tx, matrix.ty); // 100, 100\n     *\n     * // Use the matrix for other operations\n     * graphics\n     *     .setTransform(matrix)\n     *     .circle(0, 0, 50)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @returns The current transformation matrix.\n     * @see {@link Graphics#setTransform} For setting the transform matrix\n     * @see {@link Matrix} For matrix operations\n     */\n    public getTransform(): Matrix\n    {\n        return this.context.getTransform();\n    }\n    /**\n     * Resets the current transformation matrix to the identity matrix, effectively removing\n     * any transformations (rotation, scaling, translation) previously applied.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Apply transformations\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .scaleTransform(2, 2)\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     * // Reset transform to default state\n     * graphics\n     *     .resetTransform()\n     *     .circle(50, 50, 25) // Will draw at actual coordinates\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#getTransform} For getting the current transform\n     * @see {@link Graphics#setTransform} For setting a specific transform\n     * @see {@link Graphics#save} For saving the current transform state\n     * @see {@link Graphics#restore} For restoring a previous transform state\n     */\n    public resetTransform(): this\n    {\n        return this._callContextMethod('resetTransform', []);\n    }\n    /**\n     * Applies a rotation transformation to the graphics context around the current origin.\n     * Positive angles rotate clockwise, while negative angles rotate counterclockwise.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Rotate 45 degrees clockwise\n     * graphics\n     *     .rotateTransform(Math.PI / 4)\n     *     .rect(-25, -25, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param angle - The angle of rotation in radians\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#scaleTransform} For scaling transformations\n     * @see {@link Graphics#translateTransform} For position transformations\n     */\n    public rotateTransform(angle: number): this;\n    public rotateTransform(...args: Parameters<GraphicsContext['rotate']>): this\n    {\n        return this._callContextMethod('rotate', args);\n    }\n    /**\n     * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally\n     * and by y vertically relative to the current origin.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Uniform scaling\n     * graphics\n     *     .scaleTransform(2)  // Scale both dimensions by 2\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Non-uniform scaling\n     * graphics\n     *     .scaleTransform(0.5, 2)  // Half width, double height\n     *     .rect(100, 100, 50, 50)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param x - The scale factor in the horizontal direction\n     * @param y - The scale factor in the vertical direction. If omitted, equals x\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#rotateTransform} For rotation transformations\n     * @see {@link Graphics#translateTransform} For position transformations\n     */\n    public scaleTransform(x: number, y?: number): this;\n    public scaleTransform(...args: Parameters<GraphicsContext['scale']>): this\n    {\n        return this._callContextMethod('scale', args);\n    }\n    /**\n     * Sets the current transformation matrix of the graphics context.\n     *\n     * This method can either\n     * take a Matrix object or individual transform values to create a new transformation matrix.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Using a Matrix object\n     * const matrix = new Matrix()\n     *     .translate(100, 100)\n     *     .rotate(Math.PI / 4);\n     *\n     * graphics\n     *     .setTransform(matrix)\n     *     .rect(0, 0, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using individual transform values\n     * graphics\n     *     .setTransform(\n     *         2, 0,     // scale x by 2\n     *         0, 1,     // no skew\n     *         100, 100  // translate x,y by 100\n     *     )\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param transform - The matrix to set as the current transformation matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(transform: Matrix): this;\n    /**\n     * Sets the current transformation matrix of the graphics context to the specified matrix or values.\n     * This replaces the current transformation matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public setTransform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public setTransform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public setTransform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('setTransform', args);\n    }\n    /**\n     * Applies a transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix. This allows for complex transformations\n     * combining multiple operations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Using a Matrix object\n     * const matrix = new Matrix()\n     *     .scale(2, 1)      // Scale horizontally\n     *     .rotate(Math.PI/6); // Rotate 30 degrees\n     *\n     * graphics\n     *     .transform(matrix)\n     *     .rect(0, 0, 50, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Using individual transform values\n     * graphics\n     *     .transform(\n     *         1, 0.5,    // Skew horizontally\n     *         0, 1,      // No vertical skew\n     *         100, 100   // Translate\n     *     )\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0x00ff00 });\n     * ```\n     * @param transform - The matrix to apply to the current transformation.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(transform: Matrix): this;\n    /**\n     * Applies the specified transformation matrix to the current graphics context by multiplying\n     * the current matrix with the specified matrix.\n     * @param a - The value for the a property of the matrix, or a Matrix object to use directly.\n     * @param b - The value for the b property of the matrix.\n     * @param c - The value for the c property of the matrix.\n     * @param d - The value for the d property of the matrix.\n     * @param dx - The value for the tx (translate x) property of the matrix.\n     * @param dy - The value for the ty (translate y) property of the matrix.\n     * @returns The instance of the current GraphicsContext for method chaining.\n     */\n    public transform(a: number, b: number, c: number, d: number, dx: number, dy: number): this;\n    public transform(a: number | Matrix, b?: number, c?: number, d?: number, dx?: number, dy?: number): this;\n    public transform(...args: [Matrix] | [number, number, number, number, number, number]): this\n    {\n        return this._callContextMethod('transform', args);\n    }\n    /**\n     * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.\n     * This affects all subsequent drawing operations.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic translation\n     * graphics\n     *     .translateTransform(100, 100)\n     *     .circle(0, 0, 25)\n     *     .fill({ color: 0xff0000 });\n     * ```\n     * @param x - The amount to translate in the horizontal direction\n     * @param y - The amount to translate in the vertical direction. If omitted, equals x\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#setTransform} For setting absolute transformations\n     * @see {@link Graphics#transform} For applying complex transformations\n     * @see {@link Graphics#save} For saving the current transform state\n     */\n    public translateTransform(x: number, y?: number): this;\n    public translateTransform(...args: Parameters<GraphicsContext['translate']>): this\n    {\n        return this._callContextMethod('translate', args);\n    }\n    /**\n     * Clears all drawing commands from the graphics context, effectively resetting it.\n     * This includes clearing the current path, fill style, stroke style, and transformations.\n     *\n     * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.\n     * > Instead, they are intended to be used for static or semi-static graphics that\n     * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Draw some shapes\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 })\n     *     .rect(200, 100, 100, 50)\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Clear all graphics\n     * graphics.clear();\n     *\n     * // Start fresh with new shapes\n     * graphics\n     *     .circle(150, 150, 30)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @returns The Graphics instance for method chaining\n     * @see {@link Graphics#beginPath} For starting a new path without clearing styles\n     * @see {@link Graphics#save} For saving the current state\n     * @see {@link Graphics#restore} For restoring a previous state\n     */\n    public clear(): this\n    {\n        return this._callContextMethod('clear', []);\n    }\n    /**\n     * Gets or sets the current fill style for the graphics context. The fill style determines\n     * how shapes are filled when using the fill() method.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic color fill\n     * graphics.fillStyle = {\n     *     color: 0xff0000,  // Red\n     *     alpha: 1\n     * };\n     *\n     * // Using gradients\n     * const gradient = new FillGradient({\n     *     end: { x: 0, y: 1 }, // Vertical gradient\n     *     stops: [\n     *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color\n     *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color\n     *     ]\n     * });\n     *\n     * graphics.fillStyle = {\n     *     fill: gradient,\n     *     alpha: 0.8\n     * };\n     *\n     * // Using patterns\n     * graphics.fillStyle = {\n     *     texture: myTexture,\n     *     alpha: 1,\n     *     matrix: new Matrix()\n     *         .scale(0.5, 0.5)\n     *         .rotate(Math.PI / 4)\n     * };\n     * ```\n     * @type {ConvertedFillStyle}\n     * @see {@link FillStyle} For all available fill style options\n     * @see {@link FillGradient} For creating gradient fills\n     * @see {@link Graphics#fill} For applying the fill to paths\n     */\n    get fillStyle(): GraphicsContext['fillStyle']\n    {\n        return this._context.fillStyle;\n    }\n    set fillStyle(value: FillInput)\n    {\n        this._context.fillStyle = value;\n    }\n    /**\n     * Gets or sets the current stroke style for the graphics context. The stroke style determines\n     * how paths are outlined when using the stroke() method.\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Basic stroke style\n     * graphics.strokeStyle = {\n     *     width: 2,\n     *     color: 0xff0000,\n     *     alpha: 1\n     * };\n     *\n     * // Using with gradients\n     * const gradient = new FillGradient({\n     *   end: { x: 0, y: 1 },\n     *   stops: [\n     *       { offset: 0, color: 0xff0000, alpha: 1 },\n     *       { offset: 1, color: 0x0000ff, alpha: 1 }\n     *   ]\n     * });\n     *\n     * graphics.strokeStyle = {\n     *     width: 4,\n     *     fill: gradient,\n     *     alignment: 0.5,\n     *     join: 'round',\n     *     cap: 'round'\n     * };\n     *\n     * // Complex stroke settings\n     * graphics.strokeStyle = {\n     *     width: 6,\n     *     color: 0x00ff00,\n     *     alpha: 0.5,\n     *     join: 'miter',\n     *     miterLimit: 10,\n     * };\n     * ```\n     * @see {@link StrokeStyle} For all available stroke style options\n     * @see {@link Graphics#stroke} For applying the stroke to paths\n     */\n    get strokeStyle(): GraphicsContext['strokeStyle']\n    {\n        return this._context.strokeStyle;\n    }\n    set strokeStyle(value: StrokeStyle)\n    {\n        this._context.strokeStyle = value;\n    }\n\n    /**\n     * Creates a new Graphics object that copies the current graphics content.\n     * The clone can either share the same context (shallow clone) or have its own independent\n     * context (deep clone).\n     * @example\n     * ```ts\n     * const graphics = new Graphics();\n     *\n     * // Create original graphics content\n     * graphics\n     *     .circle(100, 100, 50)\n     *     .fill({ color: 0xff0000 });\n     *\n     * // Create a shallow clone (shared context)\n     * const shallowClone = graphics.clone();\n     *\n     * // Changes to original affect the clone\n     * graphics\n     *     .circle(200, 100, 30)\n     *     .fill({ color: 0x00ff00 });\n     *\n     * // Create a deep clone (independent context)\n     * const deepClone = graphics.clone(true);\n     *\n     * // Modify deep clone independently\n     * deepClone\n     *     .translateTransform(100, 100)\n     *     .circle(0, 0, 40)\n     *     .fill({ color: 0x0000ff });\n     * ```\n     * @param deep - Whether to create a deep clone of the graphics object.\n     *              If false (default), the context will be shared between objects.\n     *              If true, creates an independent copy of the context.\n     * @returns A new Graphics instance with either shared or copied context\n     * @see {@link Graphics#context} For accessing the underlying graphics context\n     * @see {@link GraphicsContext} For understanding the shared context behavior\n     */\n    public clone(deep = false): Graphics\n    {\n        if (deep)\n        {\n            return new Graphics(this._context.clone());\n        }\n\n        (this._ownedContext as null) = null;\n        const clone = new Graphics(this._context);\n\n        return clone;\n    }\n\n    // -------- v7 deprecations ---------\n\n    /**\n     * @param width\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead\n     */\n    public lineStyle(width?: number, color?: ColorSource, alpha?: number): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.');\n        // #endif\n\n        const strokeStyle: Partial<StrokeStyle> = {};\n\n        // avoid undefined assignment\n        width && (strokeStyle.width = width);\n        color && (strokeStyle.color = color);\n        alpha && (strokeStyle.alpha = alpha);\n\n        this.context.strokeStyle = strokeStyle;\n\n        return this;\n    }\n\n    /**\n     * @param color\n     * @param alpha\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public beginFill(color: ColorSource, alpha?: number)\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        const fillStyle: Partial<FillStyle> = {};\n\n        // avoid undefined assignment\n        if (color !== undefined) fillStyle.color = color;\n        if (alpha !== undefined) fillStyle.alpha = alpha;\n\n        this.context.fillStyle = fillStyle;\n\n        return this;\n    }\n\n    /**\n     * @deprecated since 8.0.0 Use {@link Graphics#fill} instead\n     */\n    public endFill()\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.');\n        // #endif\n\n        this.context.fill();\n        const strokeStyle = this.context.strokeStyle;\n\n        if (strokeStyle.width !== GraphicsContext.defaultStrokeStyle.width\n            || strokeStyle.color !== GraphicsContext.defaultStrokeStyle.color\n            || strokeStyle.alpha !== GraphicsContext.defaultStrokeStyle.alpha)\n        {\n            this.context.stroke();\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#circle} instead\n     */\n    public drawCircle(...args: Parameters<GraphicsContext['circle']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawCircle has been renamed to Graphics#circle');\n        // #endif\n\n        return this._callContextMethod('circle', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead\n     */\n    public drawEllipse(...args: Parameters<GraphicsContext['ellipse']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawEllipse has been renamed to Graphics#ellipse');\n        // #endif\n\n        return this._callContextMethod('ellipse', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#poly} instead\n     */\n    public drawPolygon(...args: Parameters<GraphicsContext['poly']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawPolygon has been renamed to Graphics#poly');\n        // #endif\n\n        return this._callContextMethod('poly', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#rect} instead\n     */\n    public drawRect(...args: Parameters<GraphicsContext['rect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRect has been renamed to Graphics#rect');\n        // #endif\n\n        return this._callContextMethod('rect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead\n     */\n    public drawRoundedRect(...args: Parameters<GraphicsContext['roundRect']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawRoundedRect has been renamed to Graphics#roundRect');\n        // #endif\n\n        return this._callContextMethod('roundRect', args);\n    }\n\n    /**\n     * @param {...any} args\n     * @deprecated since 8.0.0 Use {@link Graphics#star} instead\n     */\n    public drawStar(...args: Parameters<GraphicsContext['star']>): this\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Graphics#drawStar has been renamed to Graphics#star');\n        // #endif\n\n        return this._callContextMethod('star', args);\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2804, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/localUniformMSDFBit.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts"],"sourcesContent":["// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\n/** @internal */\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */`\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\n/** @internal */\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */`\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n"],"names":[],"mappings":";;;;;;;AAIO,MAAM,mBAAsB,GAAA;IAC/B,IAAM,EAAA,wBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;;;QAAA,CAAA;QAUlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;QAAA,CAAA;QAIhB,GAAA,EAAA,QAAA,GAAe,CAAA;;;;;QAAA,CAAA;IAAA,CAMnB;IACA,QAAU,EAAA;QACN,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;;SAAA,CAAA;QASlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAIpB;AACJ,EAAA;AAGO,MAAM,qBAAwB,GAAA;IACjC,IAAM,EAAA,wBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;QAAA,CAAA;QAKlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;QAAA,CAAA;QAIhB,GAAA,EAAA,QAAA,GAAe,CAAA;;;;;QAAA,CAAA;IAAA,CAMnB;IACA,QAAU,EAAA;QACN,MAAA,EAAA,QAAA,GAAkB,CAAA;;SAAA,CAAA;QAGlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;QAAA,CAAA;IAAA,CAIpB;AACJ","debugId":null}},
    {"offset": {"line": 2884, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text/sdfShader/shader-bits/mSDFBit.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts"],"sourcesContent":["/** @internal */\nexport const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `,\n    }\n\n};\n\n/** @internal */\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `,\n    }\n\n};\n"],"names":[],"mappings":";;;;;;;AACO,MAAM,OAAU,GAAA;IACnB,IAAM,EAAA,UAAA;IACN,QAAU,EAAA;QACN,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;QAAA,CAAA;IAAA,CA4BtB;AAEJ,EAAA;AAGO,MAAM,SAAY,GAAA;IACrB,IAAM,EAAA,UAAA;IACN,QAAU,EAAA;QACN,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;QAAA,CAAA;IAAA,CA4BtB;AAEJ","debugId":null}},
    {"offset": {"line": 2963, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text/sdfShader/SdfShader.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts"],"sourcesContent":["import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/** @internal */\nexport class SdfShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAoBA,IAAI,UAAA,CAAA;AACJ,IAAI,SAAA,CAAA;AAGG,MAAM,kBAAkB,4PAC/B,CAAA;IACI,YAAY,WACZ,CAAA;QACU,MAAA,QAAA,GAAW,IAAI,wQAAa,CAAA;YAC9B,MAAQ,EAAA;gBAAE,KAAO,EAAA,IAAI,YAAa,CAAA;oBAAC,CAAG;oBAAA,CAAA;oBAAG,CAAG;oBAAA,CAAC;iBAAC,CAAA;gBAAG,MAAM,WAAY;YAAA,CAAA;YACnE,kBAAkB;gBAAE,KAAA,EAAO,IAAI,iOAAO,EAAA;gBAAG,MAAM,aAAc;YAAA,CAAA;YAC7D,SAAW,EAAA;gBAAE,KAAO,EAAA,CAAA;gBAAG,MAAM,KAAM;YAAA,CAAA;YACnC,MAAQ,EAAA;gBAAE,KAAO,EAAA,CAAA;gBAAG,MAAM,KAAM;YAAA,CAAA;QAAA,CACnC,CAAA,CAAA;QAED,UAAA,IAAA,CAAA,UAAA,OAAe,sRAA4B,EAAA;YACvC,IAAM,EAAA,YAAA;YACN,IAAM,EAAA;gBACF,mQAAA;oBACA,iSAAA,EAAwB,WAAW,CAAA;gBACnC,wRAAA;gBACA,gQAAA;gBACA,+QAAA;aACJ;QAAA,CACH,CAAA,CAAA,CAAA;QAED,SAAA,IAAA,CAAA,SAAA,OAAc,qRAA2B,EAAA;YACrC,IAAM,EAAA,YAAA;YACN,IAAM,EAAA;gBACF,qQAAA;oBACA,mSAAA,EAA0B,WAAW,CAAA;gBACrC,0RAAA;gBACA,kQAAA;gBACA,iRAAA;aACJ;QAAA,CACH,CAAA,CAAA,CAAA;QAEK,KAAA,CAAA;YACF,SAAA;YACA,UAAA;YACA,SAAW,EAAA;gBACP,aAAe,EAAA,QAAA;gBACf,aAAA,MAAe,oSAAA,EAA6B,WAAW,CAAA;YAAA,CAC3D;QAAA,CACH,CAAA,CAAA;IAAA,CACL;AACJ","debugId":null}},
    {"offset": {"line": 3051, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-bitmap/BitmapTextPipe.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts"],"sourcesContent":["import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { BitmapText } from './BitmapText';\n\n/** @internal */\nexport class BitmapTextGraphics extends Graphics\n{\n    public destroy()\n    {\n        if (this.context.customShader)\n        {\n            this.context.customShader.destroy();\n        }\n\n        super.destroy();\n    }\n}\n\n/** @internal */\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                // TODO: Check if this is a WebGL renderer before asserting type\n                context.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);\n            }\n        }\n\n        const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n\n        if (style._stroke)\n        {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n\n        context\n            .translate((-bitmapText._anchor._x * tx) - padding, (-bitmapText._anchor._y * ty) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        let fontSize = bitmapFont.fontMetrics.fontSize;\n        let lineHeight = bitmapFont.lineHeight;\n\n        if (style.lineHeight)\n        {\n            fontSize = style.fontSize / scale;\n            lineHeight = style.lineHeight / scale;\n        }\n\n        let linePositionYShift = (lineHeight - fontSize) / 2;\n\n        // if `currentY` is no longer starts from `baseLineOffset`\n        // the `baseLineOffset` below may also need to be removed\n        if (linePositionYShift - bitmapFont.baseLineOffset < 0)\n        {\n            linePositionYShift = 0;\n        }\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = line.chars[j];\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    const texture = charData.texture;\n\n                    context.texture(\n                        texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset + linePositionYShift),\n                        texture.orig.width,\n                        texture.orig.height,\n                    );\n                }\n            }\n\n            currentY += lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that has the same style!\n        const proxyRenderable = new BitmapTextGraphics();\n\n        bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        return proxyRenderable;\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3204, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-bitmap/init.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-bitmap/init.ts"],"sourcesContent":["import { extensions } from '../../extensions/Extensions';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe);\n"],"names":[],"mappings":";;;;;;AAGA,oOAAA,CAAW,GAAA,CAAI,yPAAc,CAAA","debugId":null}},
    {"offset": {"line": 3215, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-html/BatchableHTMLText.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-html/BatchableHTMLText.ts"],"sourcesContent":["import { type Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The BatchableHTMLText class extends the BatchableSprite class and is used to handle HTML text rendering.\n * It includes a promise for the texture as generating the HTML texture takes some time.\n * @internal\n */\nexport class BatchableHTMLText extends BatchableSprite\n{\n    private readonly _renderer: Renderer;\n    public texturePromise: Promise<Texture>;\n    public generatingTexture = false;\n    public currentKey: string = '--';\n\n    /**\n     * Creates an instance of BatchableHTMLText.\n     * @param renderer - The renderer instance to be used.\n     */\n    constructor(renderer: Renderer)\n    {\n        super();\n\n        // Next step is to make canvasTextSystem a GLOBAL object.\n        // so this is ok for now..\n        this._renderer = renderer;\n\n        renderer.runners.resolutionChange.add(this);\n    }\n\n    /** Handles resolution changes for the HTML text. If the text has auto resolution enabled, it triggers a view update. */\n    public resolutionChange()\n    {\n        const text = this.renderable as HTMLText;\n\n        if (text._autoResolution)\n        {\n            text.onViewUpdate();\n        }\n    }\n\n    /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n    public destroy()\n    {\n        const { htmlText } = this._renderer;\n\n        htmlText.getReferenceCount(this.currentKey) === null\n            ? htmlText.returnTexturePromise(this.texturePromise)\n            : htmlText.decreaseReferenceCount(this.currentKey);\n        this._renderer.runners.resolutionChange.remove(this);\n        this.texturePromise = null;\n        (this._renderer as null) = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAWO,MAAM,0BAA0B,mPACvC,CAAA;IAAA;;;GAAA,GAUI,YAAY,QACZ,CAAA;QACU,KAAA,EAAA,CAAA;QATV,IAAA,CAAO,iBAAoB,GAAA,KAAA,CAAA;QAC3B,IAAA,CAAO,UAAqB,GAAA,IAAA,CAAA;QAYxB,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;QAER,QAAA,CAAA,OAAA,CAAQ,gBAAiB,CAAA,GAAA,CAAI,IAAI,CAAA,CAAA;IAAA,CAC9C;IAAA,sHAAA,GAGO,gBACP,GAAA;QACI,MAAM,OAAO,IAAK,CAAA,UAAA,CAAA;QAElB,IAAI,KAAK,eACT,EAAA;YACI,IAAA,CAAK,YAAa,EAAA,CAAA;QAAA,CACtB;IAAA,CACJ;IAAA,mHAAA,GAGO,OACP,GAAA;QACU,MAAA,EAAE,QAAS,EAAA,GAAI,IAAK,CAAA,SAAA,CAAA;QAE1B,QAAA,CAAS,iBAAkB,CAAA,IAAA,CAAK,UAAU,CAAA,KAAM,IAC1C,GAAA,QAAA,CAAS,oBAAqB,CAAA,IAAA,CAAK,cAAc,CAAA,GACjD,QAAS,CAAA,sBAAA,CAAuB,IAAA,CAAK,UAAU,CAAA,CAAA;QACrD,IAAA,CAAK,SAAU,CAAA,OAAA,CAAQ,gBAAiB,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;QACnD,IAAA,CAAK,cAAiB,GAAA,IAAA,CAAA;QACrB,IAAA,CAAK,SAAqB,GAAA,IAAA,CAAA;IAAA,CAC/B;AACJ","debugId":null}},
    {"offset": {"line": 3253, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-html/HTMLTextPipe.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateTextBounds } from '../text/utils/updateTextBounds';\nimport { BatchableHTMLText } from './BatchableHTMLText';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The HTMLTextPipe class is responsible for rendering HTML text.\n * @internal\n */\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        const gpuText = this._getGpuText(htmlText);\n\n        const newKey = htmlText.styleKey;\n\n        if (gpuText.currentKey !== newKey)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (htmlText._didTextUpdate)\n        {\n            const resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n            if (batchableHTMLText.currentKey !== htmlText.styleKey || htmlText.resolution !== resolution)\n            {\n                // If the text has changed, we need to update the GPU text\n                this._updateGpuText(htmlText).catch((e) =>\n                {\n                    console.error(e);\n                });\n            }\n\n            htmlText._didTextUpdate = false;\n\n            updateTextBounds(batchableHTMLText, htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        batchableHTMLText._batcher.updateElement(batchableHTMLText);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (batchableHTMLText.generatingTexture) return;\n\n        // We need to preserve the current texture and don't release it until the new texture is generated.\n        // It's necessary to ensure that the texture won't be captured by another field and overwritten with their\n        // content, while our texture is still in progress.\n        const oldTexturePromise = batchableHTMLText.texturePromise;\n\n        batchableHTMLText.texturePromise = null;\n\n        batchableHTMLText.generatingTexture = true;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n        let texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n\n        if (oldTexturePromise)\n        {\n            // Release old texture after new one is generated.\n            texturePromise = texturePromise.finally(() =>\n            {\n                this._renderer.htmlText.decreaseReferenceCount(batchableHTMLText.currentKey);\n                this._renderer.htmlText.returnTexturePromise(oldTexturePromise);\n            });\n        }\n\n        batchableHTMLText.texturePromise = texturePromise;\n        batchableHTMLText.currentKey = htmlText.styleKey;\n\n        batchableHTMLText.texture = await texturePromise;\n\n        // need a rerender...\n        const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            // need a rebuild of the render group\n            renderGroup.structureDidChange = true;\n        }\n\n        batchableHTMLText.generatingTexture = false;\n\n        updateTextBounds(batchableHTMLText, htmlText);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const batchableHTMLText = new BatchableHTMLText(this._renderer);\n\n        batchableHTMLText.renderable = htmlText;\n        batchableHTMLText.transform = htmlText.groupTransform;\n        batchableHTMLText.texture = Texture.EMPTY;\n        batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableHTMLText.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n\n        return batchableHTMLText;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3358, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/utils/browser/isSafari.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/utils/browser/isSafari.ts"],"sourcesContent":["import { DOMAdapter } from '../../environment/adapter';\n\n/**\n * Checks if the current browser is Safari.\n * @returns {boolean} True if the browser is Safari, false otherwise.\n * @internal\n */\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n"],"names":[],"mappings":";;;;;;;AAOO,SAAS,QAChB,GAAA;IACI,MAAM,EAAE,SAAU,EAAA,GAAI,kOAAW,CAAA,GAAA,GAAM,YAAa,EAAA,CAAA;IAE5C,OAAA,gCAAA,CAAkC,IAAA,CAAK,SAAS,CAAA,CAAA;AAC5D","debugId":null}},
    {"offset": {"line": 3375, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-html/HTMLTextRenderData.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts"],"sourcesContent":["/* eslint-disable no-restricted-globals */\nimport { DOMAdapter } from '../../environment/adapter';\nimport { type ImageLike } from '../../environment/ImageLike';\n\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\n/** @internal */\nconst nssvg = 'http://www.w3.org/2000/svg';\n/** @internal */\nconst nsxhtml = 'http://www.w3.org/1999/xhtml';\n\n/** @internal */\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image: ImageLike;\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n\n        this.image = DOMAdapter.get().createImage();\n    }\n\n    public destroy(): void\n    {\n        this.svgRoot.remove();\n        this.foreignObject.remove();\n        this.styleElement.remove();\n        this.domElement.remove();\n        this.image.src = '';\n        this.image.remove();\n\n        this.svgRoot = null;\n        this.foreignObject = null;\n        this.styleElement = null;\n        this.domElement = null;\n        this.image = null;\n        this.canvasAndContext = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAOA,MAAM,KAAQ,GAAA,4BAAA,CAAA;AAEd,MAAM,OAAU,GAAA,8BAAA,CAAA;AAGT,MAAM,kBACb,CAAA;IAQI,WACA,EAAA;QARA,IAAA,CAAO,OAAU,GAAA,QAAA,CAAS,eAAgB,CAAA,KAAA,EAAO,KAAK,CAAA,CAAA;QACtD,IAAA,CAAO,aAAgB,GAAA,QAAA,CAAS,eAAgB,CAAA,KAAA,EAAO,eAAe,CAAA,CAAA;QACtE,IAAA,CAAO,UAAa,GAAA,QAAA,CAAS,eAAgB,CAAA,OAAA,EAAS,KAAK,CAAA,CAAA;QAC3D,IAAA,CAAO,YAAe,GAAA,QAAA,CAAS,eAAgB,CAAA,OAAA,EAAS,OAAO,CAAA,CAAA;QAM3D,MAAM,EAAE,aAAA,EAAe,OAAS,EAAA,YAAA,EAAc,UAAA,EAAe,GAAA,IAAA,CAAA;QAG/C,aAAA,CAAA,YAAA,CAAa,SAAS,OAAO,CAAA,CAAA;QAC7B,aAAA,CAAA,YAAA,CAAa,UAAU,OAAO,CAAA,CAAA;QAC5C,aAAA,CAAc,KAAA,CAAM,QAAW,GAAA,QAAA,CAAA;QAE/B,OAAA,CAAQ,WAAA,CAAY,aAAa,CAAA,CAAA;QAEjC,aAAA,CAAc,WAAA,CAAY,YAAY,CAAA,CAAA;QACtC,aAAA,CAAc,WAAA,CAAY,UAAU,CAAA,CAAA;QAEpC,IAAA,CAAK,KAAQ,GAAA,kOAAA,CAAW,GAAI,EAAA,CAAE,WAAY,EAAA,CAAA;IAAA,CAC9C;IAEO,OACP,GAAA;QACI,IAAA,CAAK,OAAA,CAAQ,MAAO,EAAA,CAAA;QACpB,IAAA,CAAK,aAAA,CAAc,MAAO,EAAA,CAAA;QAC1B,IAAA,CAAK,YAAA,CAAa,MAAO,EAAA,CAAA;QACzB,IAAA,CAAK,UAAA,CAAW,MAAO,EAAA,CAAA;QACvB,IAAA,CAAK,KAAA,CAAM,GAAM,GAAA,EAAA,CAAA;QACjB,IAAA,CAAK,KAAA,CAAM,MAAO,EAAA,CAAA;QAElB,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;QACf,IAAA,CAAK,aAAgB,GAAA,IAAA,CAAA;QACrB,IAAA,CAAK,YAAe,GAAA,IAAA,CAAA;QACpB,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;QAClB,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAA;QACb,IAAA,CAAK,gBAAmB,GAAA,IAAA,CAAA;IAAA,CAC5B;AACJ","debugId":null}},
    {"offset": {"line": 3420, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-html/utils/extractFontFamilies.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts"],"sourcesContent":["import type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n * @internal\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n"],"names":["fontFamily"],"mappings":";;;;;AAUgB,SAAA,mBAAA,CAAoB,IAAA,EAAc,KAClD,EAAA;IACI,MAAM,aAAa,KAAM,CAAA,UAAA,CAAA;IACzB,MAAM,eAAyB,EAAC,CAAA;IAChC,MAAM,SAAkC,CAAA,CAAC,CAAA;IAIzC,MAAM,KAAQ,GAAA,yBAAA,CAAA;IAER,MAAA,OAAA,GAAU,IAAK,CAAA,KAAA,CAAM,KAAK,CAAA,CAAA;IAEhC,SAAS,cAAcA,WACvB,EAAA;QACQ,IAAA,CAAC,MAAOA,CAAAA,WAAU,CACtB,EAAA;YACI,YAAA,CAAa,IAAA,CAAKA,WAAU,CAAA,CAAA;YAE5B,MAAA,CAAOA,WAAU,CAAI,GAAA,IAAA,CAAA;QAAA,CACzB;IAAA,CACJ;IAEI,IAAA,KAAA,CAAM,OAAQ,CAAA,UAAU,CAC5B,EAAA;QACI,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,UAAA,CAAW,MAAA,EAAQ,CACvC,EAAA,CAAA;YACkB,aAAA,CAAA,UAAA,CAAW,CAAC,CAAC,CAAA,CAAA;QAAA,CAC/B;IAAA,CAGJ,MAAA;QACI,aAAA,CAAc,UAAU,CAAA,CAAA;IAAA,CAC5B;IAEA,IAAI,OACJ,EAAA;QACY,OAAA,CAAA,OAAA,CAAQ,CAAC,KACjB,KAAA;YACI,MAAMA,cAAa,KAAM,CAAA,KAAA,CAAM,GAAG,CAAE,CAAA,CAAC,CAAA,CAAE,IAAK,EAAA,CAAA;YAE5C,aAAA,CAAcA,WAAU,CAAA,CAAA;QAAA,CAC3B,CAAA,CAAA;IAAA,CACL;IAEW,IAAA,MAAA,CAAA,IAAK,MAAM,SACtB,CAAA;QACI,MAAMA,WAAa,GAAA,KAAA,CAAM,SAAU,CAAA,CAAC,CAAE,CAAA,UAAA,CAAA;QAEtC,aAAA,CAAcA,WAAoB,CAAA,CAAA;IAAA,CACtC;IAEO,OAAA,YAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 3462, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-html/utils/loadFontAsBase64.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts"],"sourcesContent":["import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n * @internal\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n"],"names":[],"mappings":";;;;;;;AAQA,eAAsB,iBAAiB,GACvC,EAAA;IACI,MAAM,WAAW,MAAM,kOAAA,CAAW,GAAI,EAAA,CAAE,KAAA,CAAM,GAAG,CAAA,CAAA;IAE3C,MAAA,IAAA,GAAO,MAAM,QAAA,CAAS,IAAK,EAAA,CAAA;IAE3B,MAAA,MAAA,GAAS,IAAI,UAAW,EAAA,CAAA;IAE9B,MAAM,UAAkB,MAAM,IAAI,OAAQ,CAAA,CAAC,SAAS,MACpD,KAAA;QACI,MAAA,CAAO,SAAY,GAAA,IAAM,OAAQ,CAAA,MAAA,CAAO,MAAgB,CAAA,CAAA;QACxD,MAAA,CAAO,OAAU,GAAA,MAAA,CAAA;QACjB,MAAA,CAAO,aAAA,CAAc,IAAI,CAAA,CAAA;IAAA,CAC5B,CAAA,CAAA;IAEM,OAAA,OAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 3486, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-html/utils/loadFontCSS.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts"],"sourcesContent":["import { loadFontAsBase64 } from './loadFontAsBase64';\n\n/**\n * Options for the font CSS style\n * @category text\n * @internal\n */\nexport interface FontCSSStyleOptions\n{\n    /**\n     * The font family to use in the CSS\n     * @example\n     * 'Arial' or ['Arial', 'Helvetica']\n     */\n    fontFamily: string | string[]\n    /**\n     * The font weight to use in the CSS\n     * @example\n     * 'normal', 'bold', '100', '200', etc.\n     */\n    fontWeight: string\n    /**\n     * The font style to use in the CSS\n     * @example\n     * 'normal', 'italic', 'oblique'\n     */\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n * @internal\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n        src: url('${dataSrc}');\n    }`;\n}\n"],"names":[],"mappings":";;;;;;;AAqCsB,eAAA,WAAA,CAAY,KAAA,EAA4B,GAC9D,EAAA;IACU,MAAA,OAAA,GAAU,UAAM,oQAAA,EAAiB,GAAG,CAAA,CAAA;IAEnC,OAAA,CAAA;sBAAA,EACa,MAAM,UAAU,CAAA;qBAAA,EACjB,MAAM,UAAU,CAAA;oBAAA,EACjB,MAAM,SAAS,CAAA;kBAAA,EACjB,OAAO,CAAA;KAAA,CAAA,CAAA;AAE3B","debugId":null}},
    {"offset": {"line": 3508, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-html/utils/getFontCss.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts"],"sourcesContent":["import { Cache } from '../../../assets/cache/Cache';\nimport { type FontFaceCache } from '../../../assets/loader/parsers/loadWebFont';\nimport { loadFontCSS } from './loadFontCSS';\n\n/** @internal */\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @returns - The css string\n * @internal\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { entries } = Cache.get<FontFaceCache>(`${fontFamily}-and-url`);\n                const promises: Promise<string>[] = [];\n\n                entries.forEach((entry) =>\n                {\n                    const url = entry.url;\n                    const faces = entry.faces;\n\n                    const out = faces.map((face) => ({ weight: face.weight, style: face.style }));\n\n                    // load each out font with the correct style\n                    promises.push(\n                        ...out.map((style) =>\n                            loadFontCSS(\n                                {\n                                    fontWeight: style.weight,\n                                    fontStyle: style.style,\n                                    fontFamily,\n                                },\n                                url,\n                            ),\n                        ),\n                    );\n                });\n                FontStylePromiseCache.set(\n                    fontFamily,\n                    Promise.all(promises).then((css) => css.join('\\n')),\n                );\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAKa,MAAA,qBAAA,GAAA,aAAA,GAAA,IAA4B,GAA6B,GAAA;AAStE,eAAsB,WAClB,YAEJ,EAAA;IACI,MAAM,YAAe,GAAA,YAAA,CAChB,MAAO,CAAA,CAAC,aAAe,+NAAM,CAAA,GAAA,CAAI,CAAG,EAAA,UAAU,CAAU,QAAA,CAAA,CAAC,CACzD,CAAA,GAAA,CAAI,CAAC,UACN,KAAA;QACI,IAAI,CAAC,qBAAA,CAAsB,GAAI,CAAA,UAAU,CACzC,EAAA;YACI,MAAM,EAAE,OAAQ,EAAA,GAAI,+NAAA,CAAM,GAAmB,CAAA,CAAA,EAAG,UAAU,CAAU,QAAA,CAAA,CAAA,CAAA;YACpE,MAAM,WAA8B,EAAC,CAAA;YAE7B,OAAA,CAAA,OAAA,CAAQ,CAAC,KACjB,KAAA;gBACI,MAAM,MAAM,KAAM,CAAA,GAAA,CAAA;gBAClB,MAAM,QAAQ,KAAM,CAAA,KAAA,CAAA;gBAEpB,MAAM,GAAM,GAAA,KAAA,CAAM,GAAI,CAAA,CAAC,IAAU,GAAA,CAAA;wBAAE,MAAQ,EAAA,IAAA,CAAK,MAAQ;wBAAA,KAAA,EAAO,IAAK,CAAA,KAAA;oBAAA,CAAQ,CAAA,CAAA,CAAA;gBAGnE,QAAA,CAAA,IAAA,IACF,GAAI,CAAA,GAAA,CAAI,CAAC,KACR,OAAA,0PAAA,EACI;wBACI,YAAY,KAAM,CAAA,MAAA;wBAClB,WAAW,KAAM,CAAA,KAAA;wBACjB,UAAA;oBAAA,CACJ,EACA,GAAA;YAGZ,CACH,CAAA,CAAA;YACqB,qBAAA,CAAA,GAAA,CAClB,UAAA,EACA,OAAA,CAAQ,GAAI,CAAA,QAAQ,CAAE,CAAA,IAAA,CAAK,CAAC,GAAQ,GAAA,GAAA,CAAI,IAAK,CAAA,IAAI,CAAC,CAAA;QACtD,CACJ;QAEO,OAAA,qBAAA,CAAsB,GAAA,CAAI,UAAU,CAAA,CAAA;IAAA,CAC9C,CAAA,CAAA;IAEL,OAAA,CAAQ,MAAM,OAAQ,CAAA,GAAA,CAAI,YAAY,CAAA,EAAG,IAAA,CAAK,IAAI,CAAA,CAAA;AACtD","debugId":null}},
    {"offset": {"line": 3550, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-html/utils/getSVGUrl.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts"],"sourcesContent":["import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n * @internal\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n"],"names":[],"mappings":";;;;;AAaO,SAAS,SACZ,CAAA,IAAA,EACA,KACA,EAAA,UAAA,EACA,OAAA,EACA,YAEJ,EAAA;IACI,MAAM,EAAE,UAAA,EAAY,YAAc,EAAA,OAAA,EAAY,GAAA,YAAA,CAAA;IAE9C,UAAA,CAAW,SAAY,GAAA,CAAA,OAAA,EAAU,KAAM,CAAA,QAAQ,CAAA,gCAAA,EAAmC,IAAI,CAAA,MAAA,CAAA,CAAA;IACtF,UAAA,CAAW,YAAa,CAAA,OAAA,EAAS,CAAoB,iBAAA,EAAA,UAAU,CAAqD,mDAAA,CAAA,CAAA,CAAA;IACpH,YAAA,CAAa,WAAc,GAAA,OAAA,CAAA;IAE3B,MAAM,EAAE,KAAA,EAAO,MAAO,EAAA,GAAI,YAAa,CAAA,KAAA,CAAA;IAEvC,OAAA,CAAQ,YAAa,CAAA,OAAA,EAAS,KAAM,CAAA,QAAA,EAAU,CAAA,CAAA;IAC9C,OAAA,CAAQ,YAAa,CAAA,QAAA,EAAU,MAAO,CAAA,QAAA,EAAU,CAAA,CAAA;IAEhD,OAAO,IAAI,aAAA,EAAgB,CAAA,iBAAA,CAAkB,OAAO,CAAA,CAAA;AACxD","debugId":null}},
    {"offset": {"line": 3571, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-html/utils/getTemporaryCanvasFromImage.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts"],"sourcesContent":["import { type ImageLike } from '../../../environment/ImageLike';\nimport { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\nimport type { CanvasAndContext } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * Remember to return this canvas is immediately to the CanvasPool for reuse when you are done with it.\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n * @internal\n */\nexport function getTemporaryCanvasFromImage(image: ImageLike, resolution: number): CanvasAndContext\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas.\n    return canvasAndContext;\n}\n\n"],"names":[],"mappings":";;;;;;;AAiBgB,SAAA,2BAAA,CAA4B,KAAA,EAAkB,UAC9D,EAAA;IAGI,MAAM,mBAAmB,qQAAW,CAAA,0BAAA,CAChC,KAAM,CAAA,KAAA,EACN,KAAM,CAAA,MAAA,EACN,UAAA;IAIE,MAAA,EAAE,OAAA,EAAY,GAAA,gBAAA,CAAA;IAEpB,OAAA,CAAQ,SAAA,CAAU,CAAG,EAAA,CAAA,EAAG,KAAM,CAAA,KAAA,EAAO,MAAM,MAAM,CAAA,CAAA;IACzC,OAAA,CAAA,SAAA,CAAU,KAAO,EAAA,CAAA,EAAG,CAAC,CAAA,CAAA;IAGtB,OAAA,gBAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 3591, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-html/utils/loadSVGImage.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts"],"sourcesContent":["import { type ImageLike } from '../../../environment/ImageLike';\n\n/**\n * This function loads an SVG image into an IImage element.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n * @internal\n */\nexport function loadSVGImage(image: ImageLike, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n"],"names":["resolve"],"mappings":";;;;;AAagB,SAAA,YAAA,CAAa,KAAkB,EAAA,GAAA,EAAa,KAC5D,EAAA;IACW,OAAA,IAAI,OAAc,CAAA,OAAO,OAChC,KAAA;QAKI,IAAI,KACJ,EAAA;YACI,MAAM,IAAI,OAAc,CAAA,CAACA,WAAY,UAAWA,CAAAA,QAAAA,EAAS,GAAG,CAAC,CAAA,CAAA;QAAA,CACjE;QAEA,KAAA,CAAM,MAAA,GAAS,MACf;YACY,OAAA,EAAA,CAAA;QAAA,CACZ,CAAA;QAEA,KAAA,CAAM,GAAM,GAAA,CAAA,gCAAA,EAAmC,kBAAmB,CAAA,GAAG,CAAC,CAAA,CAAA,CAAA;QACtE,KAAA,CAAM,WAAc,GAAA,WAAA,CAAA;IAAA,CACvB,CAAA,CAAA;AACL","debugId":null}},
    {"offset": {"line": 3614, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-html/utils/measureHtmlText.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts"],"sourcesContent":["/* eslint-disable no-restricted-globals */\nimport { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n * @internal\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData ||= tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    // padding is included in the CSS calculation, so we need to remove it here\n    const doublePadding = style.padding * 2;\n\n    return {\n        width: contentBounds.width - doublePadding,\n        height: contentBounds.height - doublePadding,\n    };\n}\n"],"names":[],"mappings":";;;;;;;AAMA,IAAI,sBAAA,CAAA;AAYG,SAAS,eACZ,CAAA,IAAA,EACA,KACA,EAAA,YAAA,EACA,kBAEJ,EAAA;IAC2B,kBAAA,IAAA,CAAA,kBAAA,GAAA,sBAAA,IAAA,CAA2B,sBAAyB,GAAA,IAAI,+PAAmB,EAAA,CAAA,CAAA,CAAA;IAElG,MAAM,EAAE,UAAA,EAAY,YAAc,EAAA,OAAA,EAAY,GAAA,kBAAA,CAAA;IAE9C,UAAA,CAAW,SAAY,GAAA,CAAA,OAAA,EAAU,KAAM,CAAA,QAAQ,CAAA,gCAAA,EAAmC,IAAI,CAAA,MAAA,CAAA,CAAA;IAE3E,UAAA,CAAA,YAAA,CAAa,SAAS,mDAAmD,CAAA,CAAA;IAEpF,IAAI,YACJ,EAAA;QACI,YAAA,CAAa,WAAc,GAAA,YAAA,CAAA;IAAA,CAC/B;IAGS,QAAA,CAAA,IAAA,CAAK,WAAA,CAAY,OAAO,CAAA,CAAA;IAE3B,MAAA,aAAA,GAAgB,WAAW,qBAAsB,EAAA,CAAA;IAEvD,OAAA,CAAQ,MAAO,EAAA,CAAA;IAGT,MAAA,aAAA,GAAgB,MAAM,OAAU,GAAA,CAAA,CAAA;IAE/B,OAAA;QACH,KAAA,EAAO,cAAc,KAAQ,GAAA,aAAA;QAC7B,MAAA,EAAQ,cAAc,MAAS,GAAA,aAAA;IAAA,CACnC,CAAA;AACJ","debugId":null}},
    {"offset": {"line": 3645, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-html/HTMLTextSystem.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts"],"sourcesContent":["import { type ImageLike } from '../../environment/ImageLike';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { type CanvasAndContext, CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { type HTMLTextStyle } from './HTMLTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLText, HTMLTextOptions } from './HTMLText';\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @category rendering\n * @advanced\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    private readonly _activeTextures: Record<string, {\n        texture: Texture,\n        usageCount: number,\n        promise: Promise<Texture>,\n    }> = {};\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    /**\n     * @param options\n     * @deprecated Use getTexturePromise instead\n     */\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this.getTexturePromise(options);\n    }\n\n    /**\n     * Increases the reference count for a texture.\n     * @param text - The HTMLText instance associated with the texture.\n     */\n    public getManagedTexture(text: HTMLText): Promise<Texture>\n    {\n        const textKey = text.styleKey;\n\n        if (this._activeTextures[textKey])\n        {\n            this._increaseReferenceCount(textKey);\n\n            return this._activeTextures[textKey].promise;\n        }\n\n        const promise = this._buildTexturePromise(text)\n            .then((texture) =>\n            {\n                this._activeTextures[textKey].texture = texture;\n\n                return texture;\n            });\n\n        this._activeTextures[textKey] = {\n            texture: null,\n            promise,\n            usageCount: 1,\n        };\n\n        return promise;\n    }\n\n    /**\n     * Gets the current reference count for a texture associated with a text key.\n     * @param textKey - The unique key identifying the text style configuration\n     * @returns The number of Text instances currently using this texture\n     */\n    public getReferenceCount(textKey: string)\n    {\n        return this._activeTextures[textKey]?.usageCount ?? null;\n    }\n\n    private _increaseReferenceCount(textKey: string)\n    {\n        this._activeTextures[textKey].usageCount++;\n    }\n\n    /**\n     * Decreases the reference count for a texture.\n     * If the count reaches zero, the texture is cleaned up.\n     * @param textKey - The key associated with the HTMLText instance.\n     */\n    public decreaseReferenceCount(textKey: string)\n    {\n        const activeTexture = this._activeTextures[textKey];\n\n        if (!activeTexture) return;\n\n        activeTexture.usageCount--;\n\n        if (activeTexture.usageCount === 0)\n        {\n            if (activeTexture.texture)\n            {\n                this._cleanUp(activeTexture.texture);\n            }\n            else\n            {\n                // we did not resolve...\n                activeTexture.promise.then((texture) =>\n                {\n                    activeTexture.texture = texture;\n\n                    this._cleanUp(activeTexture.texture);\n                }).catch(() =>\n                {\n                    // #if _DEBUG\n                    warn('HTMLTextSystem: Failed to clean texture');\n                    // #endif\n                });\n            }\n\n            this._activeTextures[textKey] = null;\n        }\n    }\n\n    /**\n     * Returns a promise that resolves to a texture for the given HTMLText options.\n     * @param options - The options for the HTMLText.\n     * @returns A promise that resolves to a Texture.\n     */\n    public getTexturePromise(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(options);\n    }\n\n    private async _buildTexturePromise(options: HTMLTextOptions)\n    {\n        const { text, style, resolution, textureStyle } = options as {\n            text: string,\n            style: HTMLTextStyle,\n            resolution: number,\n            textureStyle?: TextureStyle,\n        };\n\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(fontFamilies);\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        // this off set will ensure we don't get any UV bleeding!\n        const uvSafeOffset = 2;\n\n        image.width = (width | 0) + uvSafeOffset;\n        image.height = (height | 0) + uvSafeOffset;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        const resource: ImageLike | HTMLCanvasElement = image;\n        let canvasAndContext: CanvasAndContext;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource,\n            image.width - uvSafeOffset,\n            image.height - uvSafeOffset,\n            resolution\n        );\n\n        if (textureStyle) texture.source.style = textureStyle;\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    public returnTexturePromise(texturePromise: Promise<Texture>)\n    {\n        texturePromise.then((texture) =>\n        {\n            this._cleanUp(texture);\n        }).catch(() =>\n        {\n            // #if _DEBUG\n            warn('HTMLTextSystem: Failed to clean texture');\n            // #endif\n        });\n    }\n\n    private _cleanUp(texture: Texture)\n    {\n        TexturePool.returnTexture(texture, true);\n        texture.source.resource = null;\n        texture.source.uploadMethodId = 'unknown';\n    }\n\n    public destroy()\n    {\n        // BOOM!\n        (this._renderer as null) = null;\n        for (const key in this._activeTextures)\n        {\n            if (this._activeTextures[key]) this.returnTexturePromise(this._activeTextures[key].promise);\n        }\n        (this._activeTextures as null) = null;\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3813, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/text-html/init.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/text-html/init.ts"],"sourcesContent":["import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n"],"names":[],"mappings":";;;;;;;;AAIA,oOAAA,CAAW,GAAA,CAAI,uPAAc,CAAA,CAAA;AAC7B,oOAAA,CAAW,GAAA,CAAI,mPAAY,CAAA","debugId":null}},
    {"offset": {"line": 3827, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/mesh/shared/MeshGeometry.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts"],"sourcesContent":["import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @category scene\n * @advanced\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. If not provided, they will be filled with 0 and match the size of the positions. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @category scene\n * @advanced\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n\n        let uvs = options.uvs;\n\n        if (!uvs)\n        {\n            if (options.positions)\n            {\n                uvs = new Float32Array(positions.length);\n            }\n            else\n            {\n                uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n            }\n        }\n\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the positions of the mesh.\n     * When setting the positions, its important that the uvs array is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The positions of the mesh.\n     */\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the UVs of the mesh.\n     * Its important that the uvs array you set is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The UVs of the mesh.\n     */\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3969, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts"],"sourcesContent":["/** @internal */\nexport const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\n/** @internal */\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\n/** @internal */\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n"],"names":[],"mappings":";;;;;;;;;AACO,MAAM,eAAkB,GAAA;IAC3B,IAAM,EAAA,mBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;;;QAAA,CAAA;QAUlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;QAAA,CAAA;QAIhB,GAAA,EAAA,QAAA,GAAe,CAAA;;;;;QAAA,CAAA;IAAA,CAMnB;AACJ,EAAA;AAIO,MAAM,qBAAwB,GAAA;IACjC,GAAG,eAAA;IACH,MAAQ,EAAA;QACJ,GAAG,eAAgB,CAAA,MAAA;QAAA,qBAAA;QAEnB,QAAQ,eAAgB,CAAA,MAAA,CAAO,MAAO,CAAA,OAAA,CAAQ,YAAY,UAAU,CAAA;IAAA,CACxE;AACJ,EAAA;AAGO,MAAM,iBAAoB,GAAA;IAC7B,IAAM,EAAA,mBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;QAMlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;QAAA,CAAA;QAIhB,GAAA,EAAA,QAAA,GAAe,CAAA;;;;;QAAA,CAAA;IAAA,CAMnB;AACJ","debugId":null}},
    {"offset": {"line": 4038, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/sprite-tiling/shader/tilingBit.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts"],"sourcesContent":["/** @internal */\nexport const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\n/** @internal */\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    }\n\n};\n"],"names":[],"mappings":";;;;;;;AACO,MAAM,SAAY,GAAA;IACrB,IAAM,EAAA,YAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;;;;;;QAAA,CAAA;QAalB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;;QAAA,CAAA;IAAA,CAMpB;IACA,QAAU,EAAA;QACN,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;;;;;;;;QAAA,CAAA;QAalB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;;;;;;;;;;;;;QAAA,CAAA;IAAA,CAgBpB;AAEJ,EAAA;AAGO,MAAM,WAAc,GAAA;IACvB,IAAM,EAAA,YAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;QAAA,CAAA;QAKlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;;QAAA,CAAA;IAAA,CAMpB;IACA,QAAU,EAAA;QACN,MAAA,EAAA,QAAA,GAAkB,CAAA;;;;;QAAA,CAAA;QAMlB,IAAA,EAAA,QAAA,GAAgB,CAAA;;;;;;;;;QAAA,CAAA;IAAA,CAUpB;AAEJ","debugId":null}},
    {"offset": {"line": 4138, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/sprite-tiling/shader/TilingSpriteShader.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts"],"sourcesContent":["import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/**\n * The shader used by the TilingSprite.\n * @internal\n */\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4271, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/sprite-tiling/utils/QuadGeometry.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts"],"sourcesContent":["import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\n/** @internal */\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAGO,MAAM,qBAAqB,qPAClC,CAAA;IACI,WACA,EAAA;QACU,KAAA,CAAA;YACF,SAAW,EAAA,IAAI,YAAa,CAAA;gBAAC,CAAG;gBAAA,CAAA;gBAAG,CAAG;gBAAA,CAAA;gBAAG,CAAG;gBAAA,CAAA;gBAAG,CAAG;gBAAA,CAAC;aAAC,CAAA;YACpD,GAAK,EAAA,IAAI,YAAa,CAAA;gBAAC,CAAG;gBAAA,CAAA;gBAAG,CAAG;gBAAA,CAAA;gBAAG,CAAG;gBAAA,CAAA;gBAAG,CAAG;gBAAA,CAAC;aAAC,CAAA;YAC9C,OAAA,EAAS,IAAI,WAAA,CAAY;gBAAC,CAAA;gBAAG;gBAAG,CAAG;gBAAA,CAAA;gBAAG,CAAG;gBAAA,CAAC;aAAC,CAAA;QAAA,CAC9C,CAAA,CAAA;IAAA,CACL;AACJ","debugId":null}},
    {"offset": {"line": 4318, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setPositions.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts"],"sourcesContent":["import type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param positions\n * @internal\n */\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n"],"names":[],"mappings":";;;;;AAOgB,SAAA,YAAA,CAAa,YAAA,EAA4B,SACzD,EAAA;IACU,MAAA,OAAA,GAAU,aAAa,MAAO,CAAA,CAAA,CAAA;IAC9B,MAAA,OAAA,GAAU,aAAa,MAAO,CAAA,CAAA,CAAA;IAEpC,SAAA,CAAU,CAAC,CAAA,GAAI,CAAC,OAAA,GAAU,YAAa,CAAA,KAAA,CAAA;IACvC,SAAA,CAAU,CAAC,CAAA,GAAI,CAAC,OAAA,GAAU,YAAa,CAAA,MAAA,CAAA;IACvC,SAAA,CAAU,CAAC,CAAA,GAAA,CAAK,CAAI,GAAA,OAAA,IAAW,YAAa,CAAA,KAAA,CAAA;IAC5C,SAAA,CAAU,CAAC,CAAA,GAAI,CAAC,OAAA,GAAU,YAAa,CAAA,MAAA,CAAA;IACvC,SAAA,CAAU,CAAC,CAAA,GAAA,CAAK,CAAI,GAAA,OAAA,IAAW,YAAa,CAAA,KAAA,CAAA;IAC5C,SAAA,CAAU,CAAC,CAAA,GAAA,CAAK,CAAI,GAAA,OAAA,IAAW,YAAa,CAAA,MAAA,CAAA;IAC5C,SAAA,CAAU,CAAC,CAAA,GAAI,CAAC,OAAA,GAAU,YAAa,CAAA,KAAA,CAAA;IACvC,SAAA,CAAU,CAAC,CAAA,GAAA,CAAK,CAAI,GAAA,OAAA,IAAW,YAAa,CAAA,MAAA,CAAA;AAChD","debugId":null}},
    {"offset": {"line": 4341, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/sprite-tiling/utils/applyMatrix.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts"],"sourcesContent":["import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\n/**\n * @param array\n * @param stride\n * @param offset\n * @param matrix\n * @internal\n */\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n"],"names":[],"mappings":";;;;;AAUO,SAAS,WAAY,CAAA,KAAA,EAAmB,MAAgB,EAAA,MAAA,EAAgB,MAC/E,EAAA;IACI,IAAI,KAAQ,GAAA,CAAA,CAAA;IACN,MAAA,IAAA,GAAO,KAAM,CAAA,MAAA,GAAA,CAAU,MAAU,IAAA,CAAA,CAAA,CAAA;IAEvC,MAAM,IAAI,MAAO,CAAA,CAAA,CAAA;IACjB,MAAM,IAAI,MAAO,CAAA,CAAA,CAAA;IACjB,MAAM,IAAI,MAAO,CAAA,CAAA,CAAA;IACjB,MAAM,IAAI,MAAO,CAAA,CAAA,CAAA;IACjB,MAAM,KAAK,MAAO,CAAA,EAAA,CAAA;IAClB,MAAM,KAAK,MAAO,CAAA,EAAA,CAAA;IAER,MAAA,IAAA,MAAA,CAAA;IAEV,MAAO,QAAQ,IACf,CAAA;QACU,MAAA,CAAA,GAAI,KAAA,CAAM,MAAM,CAAA,CAAA;QAChB,MAAA,CAAA,GAAI,KAAM,CAAA,MAAA,GAAS,CAAC,CAAA,CAAA;QAE1B,KAAA,CAAM,MAAM,CAAA,GAAK,CAAI,GAAA,CAAA,GAAM,IAAI,CAAK,GAAA,EAAA,CAAA;QACpC,KAAA,CAAM,SAAS,CAAC,CAAA,GAAK,CAAI,GAAA,CAAA,GAAM,IAAI,CAAK,GAAA,EAAA,CAAA;QAE9B,MAAA,IAAA,MAAA,CAAA;QAEV,KAAA,EAAA,CAAA;IAAA,CACJ;AACJ","debugId":null}},
    {"offset": {"line": 4371, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/sprite-tiling/utils/setUvs.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts"],"sourcesContent":["import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param uvs\n * @internal\n */\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite.applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n"],"names":[],"mappings":";;;;;;;;;AAUgB,SAAA,MAAA,CAAO,YAAA,EAA4B,GACnD,EAAA;IACI,MAAM,UAAU,YAAa,CAAA,OAAA,CAAA;IAEvB,MAAA,KAAA,GAAQ,QAAQ,KAAM,CAAA,KAAA,CAAA;IACtB,MAAA,MAAA,GAAS,QAAQ,KAAM,CAAA,MAAA,CAAA;IAE7B,IAAI,OAAU,GAAA,CAAA,CAAA;IACd,IAAI,OAAU,GAAA,CAAA,CAAA;IAEd,IAAI,aAAa,oBACjB,EAAA;QACI,OAAA,GAAU,aAAa,MAAO,CAAA,CAAA,CAAA;QAC9B,OAAA,GAAU,aAAa,MAAO,CAAA,CAAA,CAAA;IAAA,CAClC;IAEA,GAAA,CAAI,CAAC,CAAA,GAAI,GAAI,CAAA,CAAC,CAAA,GAAI,CAAC,OAAA,CAAA;IACnB,GAAA,CAAI,CAAC,CAAA,GAAI,GAAI,CAAA,CAAC,CAAA,GAAI,CAAI,GAAA,OAAA,CAAA;IACtB,GAAA,CAAI,CAAC,CAAA,GAAI,GAAI,CAAA,CAAC,CAAA,GAAI,CAAC,OAAA,CAAA;IACnB,GAAA,CAAI,CAAC,CAAA,GAAI,GAAI,CAAA,CAAC,CAAA,GAAI,CAAI,GAAA,OAAA,CAAA;IAEtB,MAAM,gBAAgB,iOAAO,CAAA,MAAA,CAAA;IAEf,aAAA,CAAA,QAAA,CAAS,YAAa,CAAA,cAAA,CAAe,MAAM,CAAA,CAAA;IAEzD,aAAA,CAAc,EAAA,IAAM,YAAa,CAAA,KAAA,CAAA;IACjC,aAAA,CAAc,EAAA,IAAM,YAAa,CAAA,MAAA,CAAA;IAEjC,aAAA,CAAc,MAAO,EAAA,CAAA;IAErB,aAAA,CAAc,KAAA,CAAM,YAAa,CAAA,KAAA,GAAQ,KAAO,EAAA,YAAA,CAAa,MAAA,GAAS,MAAM,CAAA,CAAA;QAEhE,8PAAA,EAAA,GAAA,EAAK,CAAG,EAAA,CAAA,EAAG,aAAa,CAAA,CAAA;AACxC","debugId":null}},
    {"offset": {"line": 4408, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/sprite-tiling/TilingSpritePipe.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\nconst sharedQuad = new QuadGeometry();\n\n/** @internal */\nexport class TilingSpriteGpuData\n{\n    public canBatch: boolean = true;\n    public renderable: TilingSprite;\n    public batchableMesh?: BatchableMesh;\n    public geometry?: MeshGeometry;\n    public shader?: TilingSpriteShader;\n\n    constructor()\n    {\n        this.geometry = new MeshGeometry({\n            indices: sharedQuad.indices.slice(),\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n        this.shader?.destroy();\n    }\n}\n\n/**\n * The TilingSpritePipe is a render pipe for rendering TilingSprites.\n * It handles the batching and rendering of TilingSprites using a shader.\n * @internal\n */\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _state: State = State.default2d;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                renderable.texture\n            );\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite.didViewUpdate)\n            {\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.renderable = tilingSprite;\n                batchableMesh.transform = tilingSprite.groupTransform;\n                batchableMesh.setTexture(tilingSprite._texture);\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._getTilingSpriteData(tilingSprite);\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: this._state,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh._batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite.didViewUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): TilingSpriteGpuData\n    {\n        return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): TilingSpriteGpuData\n    {\n        const gpuData = new TilingSpriteGpuData();\n\n        gpuData.renderable = tilingSprite;\n        tilingSprite._gpuData[this._renderer.uid] = gpuData;\n\n        return gpuData;\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4566, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/sprite-tiling/init.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/sprite-tiling/init.ts"],"sourcesContent":["import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n"],"names":[],"mappings":";;;;;;AAGA,oOAAA,CAAW,GAAA,CAAI,+PAAgB,CAAA","debugId":null}},
    {"offset": {"line": 4577, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/mesh-plane/PlaneGeometry.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts"],"sourcesContent":["import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link PlaneGeometry}\n * @category scene\n * @advanced\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @category scene\n * @advanced\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4658, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceGeometry.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts"],"sourcesContent":["import { type PointData } from '../../maths/point/PointData';\nimport { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @category scene\n * @advanced\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n\n    /** The anchor point of the NineSliceSprite. */\n    anchor?: PointData\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @category scene\n * @advanced\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    /** @internal */\n    public _leftWidth: number;\n    /** @internal */\n    public _rightWidth: number;\n    /** @internal */\n    public _topHeight: number;\n    /** @internal */\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n    private _anchorX: any;\n    private _anchorY: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this._anchorX = options.anchor?.x;\n        this._anchorY = options.anchor?.y;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const p = this.positions;\n        const {\n            width,\n            height,\n            _leftWidth,\n            _rightWidth,\n            _topHeight,\n            _bottomHeight,\n            _anchorX,\n            _anchorY,\n        } = this;\n\n        const w = _leftWidth + _rightWidth;\n        const scaleW = width > w ? 1.0 : width / w;\n\n        const h = _topHeight + _bottomHeight;\n        const scaleH = height > h ? 1.0 : height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        const anchorOffsetX = _anchorX * width;\n        const anchorOffsetY = _anchorY * height;\n\n        p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n        p[2] = p[10] = p[18] = p[26] = (_leftWidth * scale) - anchorOffsetX;\n        p[4] = p[12] = p[20] = p[28] = width - (_rightWidth * scale) - anchorOffsetX;\n        p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n\n        p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n        p[9] = p[11] = p[13] = p[15] = (_topHeight * scale) - anchorOffsetY;\n        p[17] = p[19] = p[21] = p[23] = height - (_bottomHeight * scale) - anchorOffsetY;\n        p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4748, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/sprite-nine-slice/NineSliceSpritePipe.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts"],"sourcesContent":["import { ExtensionType } from '../../extensions/Extensions';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\n/**\n * GPU data for NineSliceSprite.\n * @internal\n */\nexport class NineSliceSpriteGpuData extends BatchableMesh\n{\n    constructor()\n    {\n        super();\n        this.geometry = new NineSliceGeometry();\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n    }\n}\n\n/**\n * The NineSliceSpritePipe is a render pipe for rendering NineSliceSprites.\n * @internal\n */\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: NineSliceSprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture\n        );\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.setTexture(sprite._texture);\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n\n        const batchableMesh = gpuData;\n\n        batchableMesh.renderable = sprite;\n        batchableMesh.transform = sprite.groupTransform;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        // if the sprite has not been updated by the view, we need to update the batchable mesh now.\n        if (!sprite.didViewUpdate)\n        {\n            this._updateBatchableSprite(sprite, batchableMesh);\n        }\n\n        return gpuData;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAaO,MAAM,+BAA+B,uPAC5C,CAAA;IACI,WACA,EAAA;QACU,KAAA,EAAA,CAAA;QACD,IAAA,CAAA,QAAA,GAAW,IAAI,wQAAkB,EAAA,CAAA;IAAA,CAC1C;IAEO,OACP,GAAA;QACI,IAAA,CAAK,QAAA,CAAS,OAAQ,EAAA,CAAA;IAAA,CAC1B;AACJ,CAAA;AAMO,MAAM,mBACb,CAAA;IAaI,YAAY,QACZ,CAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,aAAA,CAAc,MAAA,EAAyB,cAC9C,EAAA;QACU,MAAA,SAAA,GAAY,IAAK,CAAA,aAAA,CAAc,MAAM,CAAA,CAAA;QAE3C,IAAI,MAAO,CAAA,aAAA,EAAoB,IAAA,CAAA,sBAAA,CAAuB,QAAQ,SAAS,CAAA,CAAA;QAEvE,IAAA,CAAK,SAAU,CAAA,WAAA,CAAY,KAAM,CAAA,UAAA,CAAW,WAAW,cAAc,CAAA,CAAA;IAAA,CACzE;IAEO,iBAAiB,MACxB,EAAA;QACU,MAAA,SAAA,GAAY,IAAK,CAAA,aAAA,CAAc,MAAM,CAAA,CAAA;QAE3C,IAAI,MAAO,CAAA,aAAA,EAAoB,IAAA,CAAA,sBAAA,CAAuB,QAAQ,SAAS,CAAA,CAAA;QAE7D,SAAA,CAAA,QAAA,CAAS,aAAA,CAAc,SAAS,CAAA,CAAA;IAAA,CAC9C;IAEO,mBAAmB,MAC1B,EAAA;QACU,MAAA,SAAA,GAAY,IAAK,CAAA,aAAA,CAAc,MAAM,CAAA,CAAA;QAEpC,OAAA,CAAC,UAAU,QAAS,CAAA,qBAAA,CACvB,SAAA,EACA,MAAO,CAAA,QAAA;IACX,CACJ;IAEQ,sBAAA,CAAuB,MAAA,EAAyB,eACxD,EAAA;QACK,eAAA,CAAgB,QACZ,CAAA,MAAA,CAAO,MAAM,CAAA,CAAA;QAGF,eAAA,CAAA,UAAA,CAAW,OAAO,QAAQ,CAAA,CAAA;IAAA,CAC9C;IAEQ,cAAc,MACtB,EAAA;QACW,OAAA,MAAA,CAAO,QAAA,CAAS,IAAK,CAAA,SAAA,CAAU,GAAG,CAAK,IAAA,IAAA,CAAK,cAAA,CAAe,MAAM,CAAA,CAAA;IAAA,CAC5E;IAEQ,eAAe,MACvB,EAAA;QACU,MAAA,OAAA,GAAU,OAAO,QAAS,CAAA,IAAA,CAAK,SAAA,CAAU,GAAG,CAAA,GAAI,IAAI,sBAAuB,EAAA,CAAA;QAEjF,MAAM,aAAgB,GAAA,OAAA,CAAA;QAEtB,aAAA,CAAc,UAAa,GAAA,MAAA,CAAA;QAC3B,aAAA,CAAc,SAAA,GAAY,MAAO,CAAA,cAAA,CAAA;QACjC,aAAA,CAAc,OAAA,GAAU,MAAO,CAAA,QAAA,CAAA;QAC/B,aAAA,CAAc,WAAe,GAAA,IAAA,CAAK,SAAU,CAAA,YAAA,GAAe,MAAO,CAAA,YAAA,CAAA;QAG9D,IAAA,CAAC,OAAO,aACZ,EAAA;YACS,IAAA,CAAA,sBAAA,CAAuB,QAAQ,aAAa,CAAA,CAAA;QAAA,CACrD;QAEO,OAAA,OAAA,CAAA;IAAA,CACX;IAEO,OACP,GAAA;QACK,IAAA,CAAK,SAAqB,GAAA,IAAA,CAAA;IAAA,CAC/B;AACJ,CAAA;AAAA,YAAA,GArFa,mBAAA,CAGK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,uOAAc,CAAA,UAAA;QACd,uOAAc,CAAA,WAAA;QACd,uOAAc,CAAA,WAAA;KAClB;IACA,IAAM,EAAA,iBAAA;AACV,CAAA","debugId":null}},
    {"offset": {"line": 4825, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/sprite-nine-slice/init.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts"],"sourcesContent":["import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n"],"names":[],"mappings":";;;;;;AAGA,oOAAA,CAAW,GAAA,CAAI,4QAAmB,CAAA","debugId":null}},
    {"offset": {"line": 4836, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/filters/FilterPipe.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/filters/FilterPipe.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n/** @internal */\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAUO,MAAM,UACb,CAAA;IAYI,YAAY,QACZ,CAAA;QACI,IAAA,CAAK,SAAY,GAAA,QAAA,CAAA;IAAA,CACrB;IAEO,IAAA,CAAK,YAAsB,EAAA,SAAA,EAAsB,cACxD,EAAA;QACU,MAAA,WAAA,GAAc,IAAA,CAAK,SAAU,CAAA,WAAA,CAAA;QAEvB,WAAA,CAAA,KAAA,CAAM,KAAA,CAAM,cAAc,CAAA,CAAA;QAEtC,cAAA,CAAe,GAAI,CAAA;YACf,YAAc,EAAA,QAAA;YACd,SAAW,EAAA,KAAA;YACX,MAAQ,EAAA,YAAA;YACR,SAAA;YACA,YAAA;QAAA,CACkB,CAAA,CAAA;IAAA,CAC1B;IAEO,GAAA,CAAI,aAAuB,EAAA,UAAA,EAAuB,cACzD,EAAA;QACI,IAAA,CAAK,SAAU,CAAA,WAAA,CAAY,KAAM,CAAA,KAAA,CAAM,cAAc,CAAA,CAAA;QAErD,cAAA,CAAe,GAAI,CAAA;YACf,YAAc,EAAA,QAAA;YACd,MAAQ,EAAA,WAAA;YACR,SAAW,EAAA,KAAA;QAAA,CACd,CAAA,CAAA;IAAA,CACL;IAEO,QAAQ,WACf,EAAA;QACQ,IAAA,WAAA,CAAY,MAAA,KAAW,YAC3B,EAAA;YACS,IAAA,CAAA,SAAA,CAAU,MAAO,CAAA,IAAA,CAAK,WAAW,CAAA,CAAA;QAAA,CAC1C,MAAA,IACS,WAAY,CAAA,MAAA,KAAW,WAChC,EAAA;YACS,IAAA,CAAA,SAAA,CAAU,MAAA,CAAO,GAAI,EAAA,CAAA;QAAA,CAC9B;IAAA,CACJ;IAEO,OACP,GAAA;QACI,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;IAAA,CACrB;AACJ,CAAA;AA5Da,UAAA,CAEK,SAAY,GAAA;IACtB,IAAM,EAAA;QACF,uOAAc,CAAA,UAAA;QACd,uOAAc,CAAA,WAAA;QACd,uOAAc,CAAA,WAAA;KAClB;IACA,IAAM,EAAA,QAAA;AACV,CAAA","debugId":null}},
    {"offset": {"line": 4891, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/scene/container/bounds/getRenderableBounds.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts"],"sourcesContent":["import { Matrix } from '../../../maths';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\n/**\n * This matrix is used for calculations of the bounds for renderables placed inside cacheAsTexture render groups.\n * @ignore\n * @internal\n */\nconst tempProjectionMatrix: Matrix = new Matrix();\n\n/**\n * @param renderables\n * @param bounds\n * @internal\n */\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const actualMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n\n        if (renderGroup?.isCachedAsTexture)\n        {\n            bounds.matrix = tempProjectionMatrix.copyFrom(renderGroup.textureOffsetInverseTransform)\n                .append(renderable.worldTransform);\n        }\n        else if (renderGroup?._parentCacheAsTextureRenderGroup)\n        {\n            bounds.matrix = tempProjectionMatrix\n                .copyFrom(renderGroup._parentCacheAsTextureRenderGroup.inverseWorldTransform)\n                .append(renderable.groupTransform);\n        }\n        else\n        {\n            bounds.matrix = renderable.worldTransform;\n        }\n\n        bounds.addBounds(renderable.bounds);\n    }\n\n    bounds.matrix = actualMatrix;\n\n    return bounds;\n}\n"],"names":[],"mappings":";;;;;;;;AAUA,MAAM,oBAAA,GAA+B,IAAI,iOAAO,EAAA,CAAA;AAOhC,SAAA,yBAAA,CAA0B,WAAA,EAA2B,MACrE,EAAA;IACI,MAAA,CAAO,KAAM,EAAA,CAAA;IAMb,MAAM,eAAe,MAAO,CAAA,MAAA,CAAA;IAE5B,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,CAAY,MAAA,EAAQ,CACxC,EAAA,CAAA;QACU,MAAA,UAAA,GAAa,WAAA,CAAY,CAAC,CAAA,CAAA;QAE5B,IAAA,UAAA,CAAW,mBAAA,GAAsB,CACrC,EAAA;YACI,SAAA;QAAA,CACJ;QAEM,MAAA,WAAA,GAAc,UAAW,CAAA,WAAA,IAAe,UAAW,CAAA,iBAAA,CAAA;QAEzD,IAAI,aAAa,iBACjB,EAAA;YACW,MAAA,CAAA,MAAA,GAAS,qBAAqB,QAAS,CAAA,WAAA,CAAY,6BAA6B,CAClF,CAAA,MAAA,CAAO,WAAW,cAAc,CAAA,CAAA;QAAA,CACzC,MAAA,IACS,aAAa,gCACtB,EAAA;YACW,MAAA,CAAA,MAAA,GAAS,qBACX,QAAS,CAAA,WAAA,CAAY,gCAAA,CAAiC,qBAAqB,CAAA,CAC3E,MAAO,CAAA,UAAA,CAAW,cAAc,CAAA,CAAA;QAAA,CAGzC,MAAA;YACI,MAAA,CAAO,MAAA,GAAS,UAAW,CAAA,cAAA,CAAA;QAAA,CAC/B;QAEO,MAAA,CAAA,SAAA,CAAU,WAAW,MAAM,CAAA,CAAA;IAAA,CACtC;IAEA,MAAA,CAAO,MAAS,GAAA,YAAA,CAAA;IAET,OAAA,MAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 4927, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/filters/FilterSystem.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/filters/FilterSystem.ts"],"sourcesContent":["import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { type Rectangle } from '../maths/shapes/Rectangle';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n * @internal\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: 'pushFilter' | 'popFilter',\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\n/**\n * Class representing the data required for applying filters.\n * This class holds various properties that are used during the filter application process.\n * @internal\n */\nclass FilterData\n{\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    public skip = false;\n\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    public inputTexture: Texture = null;\n\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    public backTexture?: Texture = null;\n\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    public filters: Filter[] = null;\n\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    public bounds = new Bounds();\n\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    public container: Container = null;\n\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    public blendRequired: boolean = false;\n\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    public outputRenderSurface: RenderSurface = null;\n\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    public globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n\n    /**\n     * Indicates whether antialiasing is enabled for the filter.\n     * @type {boolean}\n     */\n    public antialias: boolean;\n\n    /**\n     * The resolution of the filter.\n     * @type {number}\n     */\n    public resolution: number;\n}\n\n/**\n * System that manages the filter pipeline\n * @category rendering\n * @advanced\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    /**\n     * Pushes a filter instruction onto the filter stack.\n     * @param instruction - The instruction containing the filter effect and container.\n     * @internal\n     */\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        filterData.skip = false;\n\n        filterData.filters = filters as Filter[];\n        filterData.container = instruction.container;\n        filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds = filterData.bounds;\n\n        this._calculateFilterArea(instruction, bounds);\n\n        this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        const previousFilterData = this._getPreviousFilterData();\n\n        const globalResolution = this._findFilterResolution(rootResolution);\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (previousFilterData)\n        {\n            offsetX = previousFilterData.bounds.minX;\n            offsetY = previousFilterData.bounds.minY;\n        }\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        // set all the filter data\n\n        this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n    }\n\n    /**\n     * Applies filters to a texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture.\n     * @param {object} params - The parameters for applying filters.\n     * @param {Texture} params.texture - The texture to apply filters to.\n     * @param {Filter[]} params.filters - The filters to apply.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     * @example\n     *\n     * ```ts\n     * // Create a texture and a list of filters\n     * const texture = new Texture(...);\n     * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n     *\n     * // Apply the filters to the texture\n     * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n     *\n     * // Use the resulting texture\n     * sprite.texture = resultTexture;\n     * ```\n     *\n     * Key Points:\n     * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n     * 2. If all filters are disabled or skipped, the original texture is returned.\n     */\n    public generateFilteredTexture({ texture, filters }: {texture: Texture, filters: Filter[]}): Texture\n    {\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        this._activeFilterData = filterData;\n        filterData.skip = false;\n\n        filterData.filters = filters;\n\n        const colorTextureSource = texture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return texture;\n        }\n\n        const bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n\n        bounds.addRect(texture.frame);\n\n        this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n\n        if (filterData.skip)\n        {\n            return texture;\n        }\n\n        const globalResolution = rootResolution;\n        const offsetX = 0;\n        const offsetY = 0;\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        /// /////////\n\n        // set all the filter data\n        // get a P02 texture from our pool...\n        filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // TODO this might need looking at for padding!\n        filterData.inputTexture = texture;\n\n        /// ////////////// PART 2 POP //////////////////////\n\n        const renderer = this.renderer;\n\n        // TODO required? check with AA\n        renderer.renderTarget.finishRenderPass();\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        this._applyFiltersToTexture(filterData, true);\n\n        const outputTexture = filterData.outputRenderSurface as Texture;\n\n        outputTexture.source.alphaMode = 'premultiplied-alpha';\n\n        return outputTexture;\n    }\n\n    /** @internal */\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._popFilterData();\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        renderer.globalUniforms.pop();\n\n        renderer.renderTarget.finishRenderPass();\n\n        this._activeFilterData = filterData;\n\n        this._applyFiltersToTexture(filterData, false);\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(filterData.backTexture);\n        }\n\n        // return the texture to the pool so we can reuse the next frame\n        TexturePool.returnTexture(filterData.inputTexture);\n    }\n\n    /**\n     * Copies the last render surface to a texture.\n     * @param lastRenderSurface - The last render surface to copy from.\n     * @param bounds - The bounds of the area to copy.\n     * @param previousBounds - The previous bounds to use for offsetting the copy.\n     */\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    /**\n     * Applies a filter to a texture.\n     * @param filter - The filter to apply.\n     * @param input - The input texture.\n     * @param output - The output render surface.\n     * @param clear - Whether to clear the output surface before applying the filter.\n     */\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._activeFilterData;\n\n        const outputRenderSurface = filterData.outputRenderSurface;\n\n        const isFinalTarget = outputRenderSurface === output;\n\n        // Find the correct resolution by looking back through the filter stack\n        const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n        const resolution = this._findFilterResolution(rootResolution);\n\n        // Calculate the offset for both outputFrame and globalFrame\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (isFinalTarget)\n        {\n            const offset = this._findPreviousFilterOffset();\n\n            offsetX = offset.x;\n            offsetY = offset.y;\n        }\n\n        this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n\n        this._setupBindGroupsAndRender(filter, input, renderer);\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n\n        if (renderGroup && renderGroup.cacheToLocalTransform)\n        {\n            // get the matrix relative to the render group..\n            worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        }\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.orig.width,\n            1.0 / sprite.texture.orig.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy(): void\n    {\n        // BOOM!\n    }\n\n    /**\n     * Sets up the bind groups and renders the filter.\n     * @param filter - The filter to apply\n     * @param input - The input texture\n     * @param renderer - The renderer instance\n     */\n    private _setupBindGroupsAndRender(filter: Filter, input: Texture, renderer: Renderer): void\n    {\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(this._filterGlobalUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    /**\n     * Sets up the filter textures including input texture and back texture if needed.\n     * @param filterData - The filter data to update\n     * @param bounds - The bounds for the texture\n     * @param renderer - The renderer instance\n     * @param previousFilterData - The previous filter data for back texture calculation\n     */\n    private _setupFilterTextures(\n        filterData: FilterData,\n        bounds: Bounds,\n        renderer: Renderer,\n        previousFilterData: FilterData | null\n    ): void\n    {\n        // set all the filter data\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        // Very cryptic, but important(!) moment.\n        //\n        // If we try to pull texture from the pool for backTexture before inputTexture,\n        // it will be unbounded later by startRenderPass. It happens because in such a case - the current backTexture\n        // is actually inputTexture from the previous filter application (check `pop` method).\n        //\n        // So maintaining the order (inputTexture -> backTexture) helps us to prevent unwanted texture unbinding.\n        if (filterData.blendRequired)\n        {\n            renderer.renderTarget.finishRenderPass();\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n\n            filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n        }\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n\n        // set the global uniforms to take into account the bounds offset required\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    /**\n     * Calculates and sets the global frame for the filter.\n     * @param filterData - The filter data to update\n     * @param offsetX - The X offset\n     * @param offsetY - The Y offset\n     * @param globalResolution - The global resolution\n     * @param sourceWidth - The source texture width\n     * @param sourceHeight - The source texture height\n     */\n    private _calculateGlobalFrame(\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        globalResolution: number,\n        sourceWidth: number,\n        sourceHeight: number\n    ): void\n    {\n        const globalFrame = filterData.globalFrame;\n\n        globalFrame.x = offsetX * globalResolution;\n        globalFrame.y = offsetY * globalResolution;\n        globalFrame.width = sourceWidth * globalResolution;\n        globalFrame.height = sourceHeight * globalResolution;\n    }\n\n    /**\n     * Updates the filter uniforms with the current filter state.\n     * @param input - The input texture\n     * @param output - The output render surface\n     * @param filterData - The current filter data\n     * @param offsetX - The X offset for positioning\n     * @param offsetY - The Y offset for positioning\n     * @param resolution - The current resolution\n     * @param isFinalTarget - Whether this is the final render target\n     * @param clear - Whether to clear the output surface\n     */\n    private _updateFilterUniforms(\n        input: Texture,\n        output: RenderSurface,\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        resolution: number,\n        isFinalTarget: boolean,\n        clear: boolean\n    ): void\n    {\n        const uniforms = this._filterGlobalUniforms.uniforms;\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            outputFrame[0] = filterData.bounds.minX - offsetX;\n            outputFrame[1] = filterData.bounds.minY - offsetY;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offsetX * resolution;\n        globalFrame[1] = offsetY * resolution;\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // we are going to overwrite resource we can set it to null!\n        if (output instanceof Texture) output.source.resource = null;\n\n        // set the output texture - this is where we are going to render to\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        this.renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n\n        this._filterGlobalUniforms.update();\n    }\n\n    /**\n     * Finds the correct resolution by looking back through the filter stack.\n     * @param rootResolution - The fallback root resolution to use\n     * @returns The resolution from the previous filter or root resolution\n     */\n    private _findFilterResolution(rootResolution: number): number\n    {\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        return currentIndex > 0 && this._filterStack[currentIndex].inputTexture\n            ? this._filterStack[currentIndex].inputTexture.source._resolution\n            : rootResolution;\n    }\n\n    /**\n     * Finds the offset from the previous non-skipped filter in the stack.\n     * @returns The offset coordinates from the previous filter\n     */\n    private _findPreviousFilterOffset(): { x: number, y: number }\n    {\n        let offsetX = 0;\n        let offsetY = 0;\n        let lastIndex = this._filterStackIndex;\n\n        while (lastIndex > 0)\n        {\n            lastIndex--;\n            const prevFilterData = this._filterStack[lastIndex];\n\n            if (!prevFilterData.skip)\n            {\n                offsetX = prevFilterData.bounds.minX;\n                offsetY = prevFilterData.bounds.minY;\n                break;\n            }\n        }\n\n        return { x: offsetX, y: offsetY };\n    }\n\n    /**\n     * Calculates the filter area bounds based on the instruction type.\n     * @param instruction - The filter instruction\n     * @param bounds - The bounds object to populate\n     */\n    private _calculateFilterArea(instruction: FilterInstruction, bounds: Bounds): void\n    {\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            // we want to factor render layers to get the real visual bounds of this container.\n            // so the last param is true..\n            instruction.container.getFastGlobalBounds(true, bounds);\n        }\n\n        if (instruction.container)\n        {\n            // When a container is cached as a texture, its filters need to be applied relative to its\n            // cached parent's coordinate space rather than world space. This transform adjustment ensures\n            // filters are applied in the correct coordinate system.\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n\n            if (filterFrameTransform)\n            {\n                bounds.applyMatrix(filterFrameTransform);\n            }\n        }\n    }\n\n    private _applyFiltersToTexture(filterData: FilterData, clear: boolean)\n    {\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        const filters = filterData.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            filters[0].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            const tempTexture = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            // get another texture that we will render the next filter too\n            let flop = tempTexture;\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.outputRenderSurface, clear);\n\n            // return those textures for later!\n            TexturePool.returnTexture(tempTexture);\n        }\n    }\n\n    private _calculateFilterBounds(\n        filterData: FilterData,\n        viewPort: Rectangle,\n        rootAntialias: boolean,\n        rootResolution: number,\n        // a multiplier padding for the bounds calculation\n        // this prop is used when applying filters to textures\n        // as the should have padding applied to them already (until we fix padding when applying them to textures)\n        // set to 0 to remove padding from the bounds calculation\n        paddingMultiplier: number\n    )\n    {\n        const renderer = this.renderer;\n\n        const bounds = filterData.bounds;\n        const filters = filterData.filters;\n\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? rootResolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= rootAntialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired ||= filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        if (clipToViewport)\n        {\n            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        }\n\n        // round the bounds to the nearest pixel\n        bounds\n            .scale(resolution)\n            .ceil()\n            .scale(1 / resolution)\n            .pad((padding | 0) * paddingMultiplier);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set the global frame to the root texture\n\n        // get previous bounds.. we must take into account skipped filters also..\n\n        // // to find the previous resolution we need to account for the skipped filters\n        // // the following will find the last non skipped filter...\n\n        // store the values that will be used to apply the filters\n        filterData.antialias = antialias;\n        filterData.resolution = resolution;\n        filterData.blendRequired = blendRequired;\n    }\n\n    private _popFilterData(): FilterData\n    {\n        this._filterStackIndex--;\n\n        return this._filterStack[this._filterStackIndex];\n    }\n\n    private _getPreviousFilterData(): FilterData | null\n    {\n        let previousFilterData: FilterData;\n\n        let index = this._filterStackIndex - 1;\n\n        while (index > 0)\n        {\n            index--;\n            previousFilterData = this._filterStack[index];\n\n            if (!previousFilterData.skip)\n            {\n                break;\n            }\n        }\n\n        return previousFilterData;\n    }\n\n    private _pushFilterData(): FilterData\n    {\n        let filterData = this._filterStack[this._filterStackIndex];\n\n        if (!filterData)\n        {\n            filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n        }\n\n        this._filterStackIndex++;\n\n        return filterData;\n    }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 5532, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/filters/init.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/filters/init.ts"],"sourcesContent":["import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n"],"names":[],"mappings":";;;;;;;;AAIA,oOAAA,CAAW,GAAA,CAAI,qOAAY,CAAA,CAAA;AAC3B,oOAAA,CAAW,GAAA,CAAI,iOAAU,CAAA","debugId":null}},
    {"offset": {"line": 5546, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs","sources":[],"sourcesContent":[],"names":[],"mappings":"","debugId":null}}]
}