{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureStyle.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureStyle.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { COMPARE_FUNCTION, SCALE_MODE, WRAP_MODE } from './const';\n\nconst idHash: Record<string, number> = Object.create(null);\n\n/**\n * This takes a shader string and maps it to a resource id.\n * This is a little different than regular resource ids as these ids\n * are not unique to the resource. But must not overlap with other (non sampler) resources Ids.\n * @param value - the string to turn into a resource id\n * @returns a unique resource id\n */\nfunction createResourceIdFromString(value: string): number\n{\n    const id = idHash[value];\n\n    if (id === undefined)\n    {\n        idHash[value] = uid('resource');\n    }\n\n    return id;\n}\n\n/**\n * The options for the texture style.\n * @category rendering\n * @advanced\n */\nexport interface TextureStyleOptions extends Partial<TextureStyle>\n{\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    addressMode?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeU?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeW?: WRAP_MODE;\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    scaleMode?: SCALE_MODE;\n\n    /** specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    magFilter?: SCALE_MODE;\n    /** specifies the sampling behavior when the sample footprint is larger than one texel. */\n    minFilter?: SCALE_MODE;\n    /** specifies behavior for sampling between mipmap levels. */\n    mipmapFilter?: SCALE_MODE;\n\n    /** specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link COMPARE_FUNCTION}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link TextureStyle#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link TextureStyle#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     *\n     * setting this to anything higher than 1 will set scale modes to 'linear'\n     */\n    maxAnisotropy?: number;\n}\n\n/**\n * A texture style describes how a texture should be sampled by a shader.\n * @category rendering\n * @advanced\n */\nexport class TextureStyle extends EventEmitter<{\n    change: TextureStyle,\n    destroy: TextureStyle,\n}> implements BindResource\n{\n    /** @internal */\n    public _resourceType = 'textureSampler';\n    /** @internal */\n    public _touched = 0;\n    private _sharedResourceId: number;\n\n    /** default options for the style */\n    public static readonly defaultOptions: TextureStyleOptions = {\n        addressMode: 'clamp-to-edge',\n        scaleMode: 'linear'\n    };\n\n    /** */\n    public addressModeU?: WRAP_MODE;\n    /** */\n    public addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    public addressModeW?: WRAP_MODE;\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    public magFilter?: SCALE_MODE;\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    public minFilter?: SCALE_MODE;\n    /** Specifies behavior for sampling between mipmap levels. */\n    public mipmapFilter?: SCALE_MODE;\n    /** */\n    public lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    public lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link COMPARE_FUNCTION}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    public compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link TextureStyle#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link TextureStyle#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     */\n    public _maxAnisotropy?: number = 1;\n\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * @param options - options for the style\n     */\n    constructor(options: TextureStyleOptions = {})\n    {\n        super();\n\n        options = { ...TextureStyle.defaultOptions, ...options };\n\n        this.addressMode = options.addressMode;\n\n        this.addressModeU = options.addressModeU ?? this.addressModeU;\n        this.addressModeV = options.addressModeV ?? this.addressModeV;\n        this.addressModeW = options.addressModeW ?? this.addressModeW;\n\n        this.scaleMode = options.scaleMode;\n\n        this.magFilter = options.magFilter ?? this.magFilter;\n        this.minFilter = options.minFilter ?? this.minFilter;\n        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n\n        this.lodMinClamp = options.lodMinClamp;\n        this.lodMaxClamp = options.lodMaxClamp;\n\n        this.compare = options.compare;\n\n        this.maxAnisotropy = options.maxAnisotropy ?? 1;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this.addressModeU = value;\n        this.addressModeV = value;\n        this.addressModeW = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this.addressModeU;\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'TextureStyle.wrapMode is now TextureStyle.addressMode');\n        // #endif\n\n        this.addressMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this.addressMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this.magFilter = value;\n        this.minFilter = value;\n        this.mipmapFilter = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this.magFilter;\n    }\n\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */\n    set maxAnisotropy(value: number)\n    {\n        this._maxAnisotropy = Math.min(value, 16);\n\n        if (this._maxAnisotropy > 1)\n        {\n            this.scaleMode = 'linear';\n        }\n    }\n\n    get maxAnisotropy(): number\n    {\n        return this._maxAnisotropy;\n    }\n\n    // TODO - move this to WebGL?\n    get _resourceId(): number\n    {\n        return this._sharedResourceId || this._generateResourceId();\n    }\n\n    public update()\n    {\n        // manage the resource..\n        this.emit('change', this);\n        this._sharedResourceId = null;\n    }\n\n    private _generateResourceId(): number\n    {\n        // eslint-disable-next-line max-len\n        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n\n        this._sharedResourceId = createResourceIdFromString(bigKey);\n\n        return this._resourceId;\n    }\n\n    /** Destroys the style */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this.removeAllListeners();\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/TextureSource.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/TextureSource.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps';\nimport { uid } from '../../../../../utils/data/uid';\nimport { TextureStyle } from '../TextureStyle';\n\nimport type { BindResource } from '../../../gpu/shader/BindResource';\nimport type { ALPHA_MODES, SCALE_MODE, TEXTURE_DIMENSIONS, TEXTURE_FORMATS, WRAP_MODE } from '../const';\nimport type { TextureStyleOptions } from '../TextureStyle';\nimport type { TextureResourceOrOptions } from '../utils/textureFrom';\n\n/**\n * options for creating a new TextureSource\n * @category rendering\n * @advanced\n */\nexport interface TextureSourceOptions<T extends Record<string, any> = any> extends TextureStyleOptions\n{\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    resource?: T;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    width?: number;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    height?: number;\n    /** the resolution of the texture. */\n    resolution?: number;\n    /** the format that the texture data has */\n    format?: TEXTURE_FORMATS;\n    /**\n     * Used by internal textures\n     * @ignore\n     */\n    sampleCount?: number;\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    antialias?: boolean;\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    dimensions?: TEXTURE_DIMENSIONS;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    mipLevelCount?: number;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    autoGenerateMipmaps?: boolean;\n    /** the alpha mode of the texture */\n    alphaMode?: ALPHA_MODES;\n    /** optional label, can be used for debugging */\n    label?: string;\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    autoGarbageCollect?: boolean;\n}\n\n/**\n * A TextureSource stores the information that represents an image.\n * All textures have require TextureSource, which contains information about the source.\n * Therefore you can have many textures all using a single TextureSource (eg a sprite sheet)\n *\n * This is an class is extended depending on the source of the texture.\n * Eg if you are using an an image as your resource, then an ImageSource is used.\n * @category rendering\n * @advanced\n */\nexport class TextureSource<T extends Record<string, any> = any> extends EventEmitter<{\n    change: BindResource;\n    update: TextureSource;\n    unload: TextureSource;\n    destroy: TextureSource;\n    resize: TextureSource;\n    styleChange: TextureSource;\n    updateMipmaps: TextureSource;\n    error: Error;\n}> implements BindResource\n{\n    /** The default options used when creating a new TextureSource. override these to add your own defaults */\n    public static defaultOptions: TextureSourceOptions = {\n        resolution: 1,\n        format: 'bgra8unorm',\n        alphaMode: 'premultiply-alpha-on-upload',\n        dimensions: '2d',\n        mipLevelCount: 1,\n        autoGenerateMipmaps: false,\n        sampleCount: 1,\n        antialias: false,\n        autoGarbageCollect: false,\n    };\n\n    /** unique id for this Texture source */\n    public readonly uid: number = uid('textureSource');\n    /** optional label, can be used for debugging */\n    public label: string;\n\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @internal\n     */\n    public readonly _resourceType = 'textureSource';\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     * @internal\n     */\n    public _resourceId = uid('resource');\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @internal\n     */\n    public uploadMethodId = 'unknown';\n\n    /** @internal */\n    public _resolution = 1;\n\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelHeight = 1;\n\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    public width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    public height = 1;\n\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    public resource: T;\n\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     */\n    public sampleCount = 1;\n\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    public mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    public autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    public format: TEXTURE_FORMATS = 'rgba8unorm';\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    public dimension: TEXTURE_DIMENSIONS = '2d';\n    /** the alpha mode of the texture */\n    public alphaMode: ALPHA_MODES;\n    private _style: TextureStyle;\n\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    public antialias = false;\n\n    /**\n     * Has the source been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    public _touched = 0;\n\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    public _batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    public _textureBindLocation = -1;\n\n    public isPowerOfTwo: boolean;\n\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    public autoGarbageCollect: boolean;\n\n    /**\n     * used internally to know where a texture came from. Usually assigned by the asset loader!\n     * @ignore\n     */\n    public _sourceOrigin: string;\n\n    /**\n     * @param options - options for creating a new TextureSource\n     */\n    constructor(protected readonly options: TextureSourceOptions<T> = {})\n    {\n        super();\n\n        options = { ...TextureSource.defaultOptions, ...options };\n\n        this.label = options.label ?? '';\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n\n        if (options.width)\n        {\n            this.pixelWidth = options.width * this._resolution;\n        }\n        else\n        {\n            this.pixelWidth = this.resource ? (this.resourceWidth ?? 1) : 1;\n        }\n\n        if (options.height)\n        {\n            this.pixelHeight = options.height * this._resolution;\n        }\n        else\n        {\n            this.pixelHeight = this.resource ? (this.resourceHeight ?? 1) : 1;\n        }\n\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n\n        this.style = new TextureStyle(definedProps(options));\n\n        this.destroyed = false;\n\n        this._refreshPOT();\n    }\n\n    /** returns itself */\n    get source(): TextureSource\n    {\n        return this;\n    }\n\n    /** the style of the texture */\n    get style(): TextureStyle\n    {\n        return this._style;\n    }\n\n    set style(value: TextureStyle)\n    {\n        if (this.style === value) return;\n\n        this._style?.off('change', this._onStyleChange, this);\n        this._style = value;\n        this._style?.on('change', this._onStyleChange, this);\n\n        this._onStyleChange();\n    }\n\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */\n    set maxAnisotropy(value: number)\n    {\n        this._style.maxAnisotropy = value;\n    }\n\n    get maxAnisotropy(): number\n    {\n        return this._style.maxAnisotropy;\n    }\n\n    /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */\n    get repeatMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set repeatMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    get magFilter(): SCALE_MODE\n    {\n        return this._style.magFilter;\n    }\n\n    set magFilter(value: SCALE_MODE)\n    {\n        this._style.magFilter = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    get minFilter(): SCALE_MODE\n    {\n        return this._style.minFilter;\n    }\n\n    set minFilter(value: SCALE_MODE)\n    {\n        this._style.minFilter = value;\n    }\n\n    /** Specifies behavior for sampling between mipmap levels. */\n    get mipmapFilter(): SCALE_MODE\n    {\n        return this._style.mipmapFilter;\n    }\n\n    set mipmapFilter(value: SCALE_MODE)\n    {\n        this._style.mipmapFilter = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMinClamp(): number\n    {\n        return this._style.lodMinClamp;\n    }\n\n    set lodMinClamp(value: number)\n    {\n        this._style.lodMinClamp = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMaxClamp(): number\n    {\n        return this._style.lodMaxClamp;\n    }\n\n    set lodMaxClamp(value: number)\n    {\n        this._style.lodMaxClamp = value;\n    }\n\n    private _onStyleChange()\n    {\n        this.emit('styleChange', this);\n    }\n\n    /** call this if you have modified the texture outside of the constructor */\n    public update()\n    {\n        // update resource...\n        if (this.resource)\n        {\n            const resolution = this._resolution;\n\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n\n            // no need to dispatch the update we resized as that will\n            // notify the texture systems anyway\n            if (didResize) return;\n        }\n\n        this.emit('update', this);\n    }\n\n    /** Destroys this texture source */\n    public destroy()\n    {\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        if (this._style)\n        {\n            this._style.destroy();\n            this._style = null;\n        }\n\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n\n    /**\n     * This will unload the Texture source from the GPU. This will free up the GPU memory\n     * As soon as it is required fore rendering, it will be re-uploaded.\n     */\n    public unload()\n    {\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n        this.emit('unload', this);\n    }\n\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n    public get resourceWidth(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */\n    public get resourceHeight(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n\n    /**\n     * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n     * but will the size of the texture when rendered.\n     *\n     * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n     * density will have increased)\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(resolution: number)\n    {\n        if (this._resolution === resolution) return;\n\n        this._resolution = resolution;\n\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n\n    /**\n     * Resize the texture, this is handy if you want to use the texture as a render texture\n     * @param width - the new width of the texture\n     * @param height - the new height of the texture\n     * @param resolution - the new resolution of the texture\n     * @returns - if the texture was resized\n     */\n    public resize(width?: number, height?: number, resolution?: number): boolean\n    {\n        resolution ||= this._resolution;\n        width ||= this.width;\n        height ||= this.height;\n\n        // make sure we work with rounded pixels\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n\n        this._resolution = resolution;\n\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight)\n        {\n            return false;\n        }\n\n        this._refreshPOT();\n\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n\n        this.emit('resize', this);\n\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n\n        return true;\n    }\n\n    /**\n     * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n     * This is only important for RenderTexture instances, as standard Texture instances will have their\n     * mipmaps generated on upload. You should call this method after you make any change to the texture\n     *\n     * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n     * We want you, the developer to specify when this action should happen.\n     *\n     * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n     */\n    public updateMipmaps()\n    {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1)\n        {\n            this.emit('updateMipmaps', this);\n        }\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        this._style.wrapMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this._style.wrapMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this._style.scaleMode = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this._style.scaleMode;\n    }\n\n    /**\n     * Refresh check for isPowerOfTwo texture based on size\n     * @private\n     */\n    protected _refreshPOT(): void\n    {\n        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n    }\n\n    public static test(_resource: any): any\n    {\n        // this should be overridden by other sources..\n        throw new Error('Unimplemented');\n    }\n\n    /**\n     * A helper function that creates a new TextureSource based on the resource you provide.\n     * @param resource - The resource to create the texture source from.\n     */\n    public static from: (resource: TextureResourceOrOptions) => TextureSource;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 440, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/BufferImageSource.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/BufferImageSource.ts"],"sourcesContent":["import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * Options for creating a BufferImageSource.\n * @category rendering\n * @advanced\n */\nexport interface BufferSourceOptions extends TextureSourceOptions<TypedArray | ArrayBuffer>\n{\n    width: number;\n    height: number;\n}\n\n/**\n * A texture source that uses a TypedArray or ArrayBuffer as its resource.\n * It automatically determines the format based on the type of TypedArray provided.\n * @category rendering\n * @advanced\n */\nexport class BufferImageSource extends TextureSource<TypedArray | ArrayBuffer>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'buffer';\n\n    constructor(options: BufferSourceOptions)\n    {\n        const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n        let format = options.format;\n\n        if (!format)\n        {\n            if (buffer instanceof Float32Array)\n            {\n                format = 'rgba32float';\n            }\n            else if (buffer instanceof Int32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Uint32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Int16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Uint16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Int8Array)\n            {\n                format = 'bgra8unorm';\n            }\n            else\n            {\n                format = 'bgra8unorm';\n            }\n        }\n\n        super({\n            ...options,\n            resource: buffer,\n            format,\n        });\n    }\n\n    public static test(resource: any): resource is TypedArray | ArrayBuffer\n    {\n        return resource instanceof Int8Array\n        || resource instanceof Uint8Array\n        || resource instanceof Uint8ClampedArray\n        || resource instanceof Int16Array\n        || resource instanceof Uint16Array\n        || resource instanceof Int32Array\n        || resource instanceof Uint32Array\n        || resource instanceof Float32Array;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AAwBO,MAAM,0BAA0B,yRACvC,CAAA;IAiDI,OAAc,KAAK,QACnB,EAAA;QACI,OAAO,QAAoB,YAAA,SAAA,IACxB,QAAoB,YAAA,UAAA,IACpB,oBAAoB,iBACpB,IAAA,QAAA,YAAoB,UACpB,IAAA,QAAA,YAAoB,WACpB,IAAA,QAAA,YAAoB,UACpB,IAAA,QAAA,YAAoB,eACpB,QAAoB,YAAA,YAAA,CAAA;IAAA,CAC3B;IAtDA,YAAY,OACZ,CAAA;QACU,MAAA,MAAA,GAAS,QAAQ,QAAY,IAAA,IAAI,aAAa,OAAQ,CAAA,KAAA,GAAQ,OAAQ,CAAA,MAAA,GAAS,CAAC,CAAA,CAAA;QACtF,IAAI,SAAS,OAAQ,CAAA,MAAA,CAAA;QAErB,IAAI,CAAC,MACL,EAAA;YACI,IAAI,kBAAkB,YACtB,EAAA;gBACa,MAAA,GAAA,aAAA,CAAA;YAAA,CACb,MAAA,IACS,kBAAkB,UAC3B,EAAA;gBACa,MAAA,GAAA,YAAA,CAAA;YAAA,CACb,MAAA,IACS,kBAAkB,WAC3B,EAAA;gBACa,MAAA,GAAA,YAAA,CAAA;YAAA,CACb,MAAA,IACS,kBAAkB,UAC3B,EAAA;gBACa,MAAA,GAAA,YAAA,CAAA;YAAA,CACb,MAAA,IACS,kBAAkB,WAC3B,EAAA;gBACa,MAAA,GAAA,YAAA,CAAA;YAAA,CACb,MAAA,IACS,kBAAkB,SAC3B,EAAA;gBACa,MAAA,GAAA,YAAA,CAAA;YAAA,CAGb,MAAA;gBACa,MAAA,GAAA,YAAA,CAAA;YAAA,CACb;QAAA,CACJ;QAEM,KAAA,CAAA;YACF,GAAG,OAAA;YACH,QAAU,EAAA,MAAA;YACV,MAAA;QAAA,CACH,CAAA,CAAA;QA3CL,IAAA,CAAO,cAAiB,GAAA,QAAA,CAAA;IAAA,CA4CxB;AAaJ,CAAA;AA7Da,iBAAA,CAEK,SAAA,GAA+B,0OAAc,CAAA,aAAA","debugId":null}},
    {"offset": {"line": 488, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureMatrix.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureMatrix.ts"],"sourcesContent":["import { Matrix } from '../../../../maths/matrix/Matrix';\n\nimport type { Texture } from './Texture';\n\nconst tempMat = new Matrix();\n\n/**\n * Class controls uv mapping from Texture normal space to BaseTexture normal space.\n *\n * Takes `trim` and `rotate` into account. May contain clamp settings for Meshes and TilingSprite.\n *\n * Can be used in Texture `uvMatrix` field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * Takes track of Texture changes through `_lastTextureID` private field.\n * Use `update()` method call to track it from outside.\n * @see Texture\n * @see Mesh\n * @see TilingSprite\n * @category rendering\n * @advanced\n */\nexport class TextureMatrix\n{\n    /**\n     * Matrix operation that converts texture region coords to texture coords\n     * @readonly\n     */\n    public mapCoord: Matrix;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n     * @default 0\n     */\n    public clampOffset: number;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     */\n    public clampMargin: number;\n\n    /**\n     * Clamp region for normalized coords, left-top pixel center in xy , bottom-right in zw.\n     * Calculated based on clampOffset.\n     */\n    public readonly uClampFrame: Float32Array;\n\n    /** Normalized clamp offset. Calculated based on clampOffset. */\n    public readonly uClampOffset: Float32Array;\n\n    /**\n     * Tracks Texture frame changes.\n     * @ignore\n     */\n    public _updateID: number;\n\n    /**\n     * Tracks Texture frame changes.\n     * @protected\n     */\n    protected _textureID: number;\n\n    protected _texture: Texture;\n\n    /**\n     * If texture size is the same as baseTexture.\n     * @default false\n     * @readonly\n     */\n    public isSimple: boolean;\n\n    /**\n     * @param texture - observed texture\n     * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n     */\n    constructor(texture: Texture, clampMargin?: number)\n    {\n        this.mapCoord = new Matrix();\n        this.uClampFrame = new Float32Array(4);\n        this.uClampOffset = new Float32Array(2);\n        this._textureID = -1;\n        this._updateID = 0;\n\n        this.clampOffset = 0;\n\n        if ((typeof clampMargin === 'undefined'))\n        {\n            this.clampMargin = (texture.width < 10) ? 0 : 0.5;\n        }\n        else\n        {\n            this.clampMargin = clampMargin;\n        }\n\n        this.isSimple = false;\n\n        this.texture = texture;\n    }\n\n    /** Texture property. */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    set texture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this._texture?.removeListener('update', this.update, this);\n        this._texture = value;\n        this._texture.addListener('update', this.update, this);\n\n        this.update();\n    }\n\n    /**\n     * Multiplies uvs array to transform\n     * @param uvs - mesh uvs\n     * @param [out=uvs] - output\n     * @returns - output\n     */\n    public multiplyUvs(uvs: Float32Array, out?: Float32Array): Float32Array\n    {\n        if (out === undefined)\n        {\n            out = uvs;\n        }\n\n        const mat = this.mapCoord;\n\n        for (let i = 0; i < uvs.length; i += 2)\n        {\n            const x = uvs[i];\n            const y = uvs[i + 1];\n\n            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;\n            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;\n        }\n\n        return out;\n    }\n\n    /**\n     * Updates matrices if texture was changed\n     * @returns - whether or not it was updated\n     */\n    public update(): boolean\n    {\n        const tex = this._texture;\n\n        this._updateID++;\n\n        const uvs = tex.uvs;\n\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n\n        const orig = tex.orig;\n        const trim = tex.trim;\n\n        if (trim)\n        {\n            tempMat.set(\n                orig.width / trim.width,\n                0, 0, orig.height / trim.height,\n                -trim.x / trim.width,\n                -trim.y / trim.height\n            );\n\n            this.mapCoord.append(tempMat);\n        }\n\n        const texBase = tex.source;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase._resolution;\n        const offset = this.clampOffset / texBase._resolution;\n\n        frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n\n        this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n        this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n\n        this.isSimple = tex.frame.width === texBase.width\n            && tex.frame.height === texBase.height\n            && tex.rotate === 0;\n\n        return true;\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 578, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/Texture.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/texture/Texture.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { NOOP } from '../../../../utils/misc/NOOP';\nimport { BufferImageSource } from './sources/BufferImageSource';\nimport { TextureSource } from './sources/TextureSource';\nimport { TextureMatrix } from './TextureMatrix';\n\nimport type { TextureResourceOrOptions } from './utils/textureFrom';\n\n/**\n * Stores the width of the non-scalable borders, for example when used with {@link NineSlicePlane} texture.\n * @category rendering\n * @advanced\n */\nexport interface TextureBorders\n{\n    /** left border in pixels */\n    left: number;\n    /** top border in pixels */\n    top: number;\n    /** right border in pixels */\n    right: number;\n    /** bottom border in pixels */\n    bottom: number;\n}\n\n/**\n * The UVs data structure for a texture.\n * @category rendering\n * @advanced\n */\nexport type UVs = {\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    x3: number;\n    y3: number;\n};\n\n/**\n * The options that can be passed to a new Texture\n * @category rendering\n * @standard\n */\nexport interface TextureOptions<TextureSourceType extends TextureSource = TextureSource>\n{\n    /** the underlying texture data that this texture will use  */\n    source?: TextureSourceType;\n    /** optional label, for debugging */\n    label?: string;\n    /** The rectangle frame of the texture to show */\n    frame?: Rectangle;\n    /** The area of original texture */\n    orig?: Rectangle;\n    /** Trimmed rectangle of original texture */\n    trim?: Rectangle;\n    /** Default anchor point used for sprite placement / rotation */\n    defaultAnchor?: { x: number; y: number };\n    /** Default borders used for 9-slice scaling {@link NineSlicePlane}*/\n    defaultBorders?: TextureBorders;\n    /** indicates how the texture was rotated by texture packer. See {@link groupD8} */\n    rotate?: number;\n    /**\n     * Set to true if you plan on modifying this texture's frame, UVs, or swapping its source at runtime.\n     * This is false by default as it improves performance. Generally, it's recommended to create new\n     * textures and swap those rather than modifying an existing texture's properties unless you are\n     * working with a dynamic frames.\n     * Not setting this to true when modifying the texture can lead to visual artifacts.\n     *\n     * If this is false and you modify the texture, you can manually update the sprite's texture by calling\n     * `sprite.onViewUpdate()`.\n     */\n    dynamic?: boolean;\n}\n\n/**\n * A texture that can be bound to a shader as it has a texture source.\n * @category rendering\n * @advanced\n */\nexport interface BindableTexture\n{\n    source: TextureSource;\n}\n\n/**\n * A texture source can be a string, an image, a video, a canvas, or a texture resource.\n * @category rendering\n * @advanced\n * @see {@link TextureSource}\n * @see {@link TextureResourceOrOptions}\n * @see {@link Texture.from}\n */\nexport type TextureSourceLike = TextureSource | TextureResourceOrOptions | string;\n\n/**\n * A texture stores the information that represents an image or part of an image.\n *\n * A texture must have a loaded resource passed to it to work. It does not contain any\n * loading mechanisms.\n *\n * The Assets class can be used to load a texture from a file. This is the recommended\n * way as it will handle the loading and caching for you.\n *\n * ```js\n *\n * const texture = await Assets.load('assets/image.png');\n *\n * // once Assets has loaded the image it will be available via the from method\n * const sameTexture = Texture.from('assets/image.png');\n * // another way to access the texture once loaded\n * const sameAgainTexture = Assets.get('assets/image.png');\n *\n * const sprite1 = new Sprite(texture);\n *\n * ```\n *\n * It cannot be added to the display list directly; instead use it as the texture for a Sprite.\n * If no frame is provided for a texture, then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * import { Sprite, Texture } from 'pixi.js';\n *\n * const texture = await Assets.load('assets/image.png');\n * const sprite1 = new Sprite(texture);\n * const sprite2 = new Sprite(texture);\n * ```\n *\n * If you didn't pass the texture frame to constructor, it enables `noFrame` mode:\n * it subscribes on baseTexture events, it automatically resizes at the same time as baseTexture.\n * @category rendering\n * @class\n * @standard\n */\nexport class Texture<TextureSourceType extends TextureSource = TextureSource> extends EventEmitter<{\n    update: Texture\n    destroy: Texture\n}> implements BindableTexture\n{\n    /**\n     * Helper function that creates a returns Texture based on the source you provide.\n     * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n     * @param id - String or Source to create texture from\n     * @param skipCache - Skip adding the texture to the cache\n     * @returns The texture based on the Id provided\n     */\n    public static from: (id: TextureSourceLike, skipCache?: boolean) => Texture;\n\n    /** label used for debugging */\n    public label?: string;\n    /** unique id for this texture */\n    public readonly uid: number = uid('texture');\n    /**\n     * Has the texture been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /** @internal */\n    public _source: TextureSourceType;\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link groupD8} for explanation\n     */\n    public readonly rotate: number;\n    /** A uvs object based on the given frame and the texture source */\n    public readonly uvs: UVs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * Anchor point that is used as default if sprite is created with this texture.\n     * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n     * @default {0,0}\n     */\n    public readonly defaultAnchor?: { x: number; y: number };\n    /**\n     * Default width of the non-scalable border that is used if 9-slice plane is created with this texture.\n     * @since 7.2.0\n     * @see NineSliceSprite\n     */\n    public readonly defaultBorders?: TextureBorders;\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    public readonly frame = new Rectangle();\n    /** This is the area of original texture, before it was put in atlas. */\n    public readonly orig: Rectangle;\n    /**\n     * This is the trimmed area of original texture, before it was put in atlas\n     * Please call `updateUvs()` after you change coordinates of `trim` manually.\n     */\n    public readonly trim: Rectangle;\n\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    public noFrame = false;\n\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    public dynamic = false;\n\n    private _textureMatrix: TextureMatrix;\n\n    /** is it a texture? yes! used for type checking */\n    public readonly isTexture = true;\n\n    /**\n     * @param {TextureOptions} options - Options for the texture\n     */\n    constructor({\n        source,\n        label,\n        frame,\n        orig,\n        trim,\n        defaultAnchor,\n        defaultBorders,\n        rotate,\n        dynamic\n    }: TextureOptions<TextureSourceType> = {})\n    {\n        super();\n\n        this.label = label;\n        this.source = (source?.source ?? new TextureSource()) as TextureSourceType;\n\n        this.noFrame = !frame;\n\n        if (frame)\n        {\n            this.frame.copyFrom(frame);\n        }\n        else\n        {\n            const { width, height } = this._source;\n\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n\n        this.orig = orig || this.frame;\n        this.trim = trim;\n\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n\n        this.destroyed = false;\n        this.dynamic = dynamic || false;\n\n        this.updateUvs();\n    }\n\n    set source(value: TextureSourceType)\n    {\n        if (this._source)\n        {\n            this._source.off('resize', this.update, this);\n        }\n\n        this._source = value;\n\n        value.on('resize', this.update, this);\n\n        this.emit('update', this);\n    }\n\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */\n    get source(): TextureSourceType\n    {\n        return this._source;\n    }\n\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n    get textureMatrix()\n    {\n        if (!this._textureMatrix)\n        {\n            this._textureMatrix = new TextureMatrix(this);\n        }\n\n        return this._textureMatrix;\n    }\n\n    /** The width of the Texture in pixels. */\n    get width(): number\n    {\n        return this.orig.width;\n    }\n\n    /** The height of the Texture in pixels. */\n    get height(): number\n    {\n        return this.orig.height;\n    }\n\n    /** Call this function when you have modified the frame of this texture. */\n    public updateUvs()\n    {\n        const { uvs, frame } = this;\n        const { width, height } = this._source;\n\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n\n        let rotate = this.rotate;\n\n        if (rotate)\n        {\n            // width and height div 2 div baseFrame size\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n\n            // coordinates of center\n            const cX = nX + w2;\n            const cY = nY + h2;\n\n            rotate = groupD8.add(rotate, groupD8.NW); // NW is top-left corner\n            uvs.x0 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y0 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n            uvs.x1 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y1 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x2 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y2 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x3 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y3 = cY + (h2 * groupD8.uY(rotate));\n        }\n\n        else\n        {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n\n    /**\n     * Destroys this texture\n     * @param destroySource - Destroy the source when the texture is destroyed.\n     */\n    public destroy(destroySource = false)\n    {\n        if (this._source)\n        {\n            if (destroySource)\n            {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.removeAllListeners();\n    }\n\n    /**\n     * Call this if you have modified the `texture outside` of the constructor.\n     *\n     * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.\n     */\n    public update(): void\n    {\n        if (this.noFrame)\n        {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n\n        this.updateUvs();\n        this.emit('update', this);\n    }\n\n    /** @deprecated since 8.0.0 */\n    get baseTexture(): TextureSource\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Texture.baseTexture is now Texture.source');\n        // #endif\n\n        return this._source;\n    }\n\n    /** an Empty Texture used internally by the engine */\n    public static EMPTY: Texture;\n    /** a White texture used internally by the engine */\n    public static WHITE: Texture<BufferImageSource>;\n}\n\nTexture.EMPTY = new Texture({\n    label: 'EMPTY',\n    source: new TextureSource({\n        label: 'EMPTY',\n    })\n});\n\nTexture.EMPTY.destroy = NOOP;\n\nTexture.WHITE = new Texture({\n    source: new BufferImageSource({\n        resource: new Uint8Array([255, 255, 255, 255]),\n        width: 1,\n        height: 1,\n        alphaMode: 'premultiply-alpha-on-upload',\n        label: 'WHITE',\n    }),\n    label: 'WHITE',\n});\n\nTexture.WHITE.destroy = NOOP;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 780, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/mask/MaskEffectManager.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/mask/MaskEffectManager.ts"],"sourcesContent":["import { extensions, ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\n\nimport type { Effect, EffectConstructor } from '../../scene/container/Effect';\nimport type { PoolItem, PoolItemConstructor } from '../../utils/pool/Pool';\n\ninterface MaskConversionTest\n{\n    test: (item: any) => boolean;\n    maskClass: new (item: any) => Effect & PoolItem;\n}\n\n/**\n * Represents a mask effect that can be applied to a container.\n * @category rendering\n * @advanced\n */\nexport type MaskEffect = {mask: unknown} & Effect;\n\n/**\n * A class that manages the conversion of masks to mask effects.\n * @category rendering\n * @ignore\n */\nexport class MaskEffectManagerClass\n{\n    /** @private */\n    public readonly _effectClasses: EffectConstructor[] = [];\n    private readonly _tests: MaskConversionTest[] = [];\n    private _initialized = false;\n\n    public init()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n\n        this._effectClasses.forEach((test) =>\n        {\n            this.add({\n                test: test.test,\n                maskClass: test\n            });\n        });\n    }\n\n    public add(test: MaskConversionTest)\n    {\n        this._tests.push(test);\n    }\n\n    public getMaskEffect(item: any): MaskEffect\n    {\n        if (!this._initialized) this.init();\n\n        for (let i = 0; i < this._tests.length; i++)\n        {\n            const test = this._tests[i];\n\n            if (test.test(item))\n            {\n                return BigPool.get(test.maskClass as PoolItemConstructor<MaskEffect & PoolItem>, item);\n            }\n        }\n\n        return item;\n    }\n\n    public returnMaskEffect(effect: Effect & PoolItem)\n    {\n        BigPool.return(effect);\n    }\n}\n\n/**\n * A class that manages the conversion of masks to mask effects.\n * @class\n * @category rendering\n * @advanced\n */\nexport const MaskEffectManager = new MaskEffectManagerClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n"],"names":[],"mappings":";;;;;;;;;;;AAwBO,MAAM,sBACb,CAAA;IAMW,IACP,GAAA;QACI,IAAI,IAAK,CAAA,YAAA,EAAc,OAAA;QAEvB,IAAA,CAAK,YAAe,GAAA,IAAA,CAAA;QAEf,IAAA,CAAA,cAAA,CAAe,OAAQ,CAAA,CAAC,IAC7B,KAAA;YACI,IAAA,CAAK,GAAI,CAAA;gBACL,MAAM,IAAK,CAAA,IAAA;gBACX,SAAW,EAAA,IAAA;YAAA,CACd,CAAA,CAAA;QAAA,CACJ,CAAA,CAAA;IAAA,CACL;IAEO,IAAI,IACX,EAAA;QACS,IAAA,CAAA,MAAA,CAAO,IAAA,CAAK,IAAI,CAAA,CAAA;IAAA,CACzB;IAEO,cAAc,IACrB,EAAA;QACI,IAAI,CAAC,IAAK,CAAA,YAAA,EAAc,IAAA,CAAK,IAAK,EAAA,CAAA;QAElC,IAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,MAAA,CAAO,MAAA,EAAQ,CACxC,EAAA,CAAA;YACU,MAAA,IAAA,GAAO,IAAK,CAAA,MAAA,CAAO,CAAC,CAAA,CAAA;YAEtB,IAAA,IAAA,CAAK,IAAK,CAAA,IAAI,CAClB,EAAA;gBACI,OAAO,sOAAQ,CAAA,GAAA,CAAI,IAAK,CAAA,SAAA,EAAyD,IAAI,CAAA,CAAA;YAAA,CACzF;QAAA,CACJ;QAEO,OAAA,IAAA,CAAA;IAAA,CACX;IAEO,iBAAiB,MACxB,EAAA;QACI,sOAAA,CAAQ,MAAA,CAAO,MAAM,CAAA,CAAA;IAAA,CACzB;IA/CG,WAAA,EAAA;QAGH,aAAA,GAAA,IAAA,CAAgB,cAAA,GAAsC,EAAC,CAAA;QACvD,IAAA,CAAiB,MAAA,GAA+B,EAAC,CAAA;QACjD,IAAA,CAAQ,YAAe,GAAA,KAAA,CAAA;IAAA,CAAA;AA2C3B,CAAA;AAQa,MAAA,iBAAA,GAAoB,IAAI,sBAAuB,GAAA;AAG5D,uOAAA,CACK,YAAa,CAAA,0OAAA,CAAc,UAAY,EAAA,iBAAA,CAAkB,cAAc,CAAA","debugId":null}},
    {"offset": {"line": 832, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/instructions/InstructionSet.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/instructions/InstructionSet.ts"],"sourcesContent":["import { uid } from '../../../../utils/data/uid';\n\nimport type { Renderable } from '../Renderable';\nimport type { Instruction } from './Instruction';\n\n/**\n * A set of instructions that can be executed by the renderer.\n * Basically wraps an array, but with some extra properties that help the renderer\n * to keep things nice and optimised.\n *\n * Note:\n * InstructionSet.instructions contains all the instructions, but does not resize (for performance).\n * So for the true length of the instructions you need to use InstructionSet.instructionSize\n * @category rendering\n * @advanced\n */\nexport class InstructionSet\n{\n    /** a unique id for this instruction set used through the renderer */\n    public readonly uid: number = uid('instructionSet');\n    /** the array of instructions */\n    public readonly instructions: Instruction[] = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    public instructionSize = 0;\n    /** allows for access to the render pipes of the renderer */\n    public renderPipes: any;\n\n    public renderables: Renderable[] = [];\n    /** used by the garbage collector to track when the instruction set was last used */\n    public gcTick = 0;\n\n    /** reset the instruction set so it can be reused set size back to 0 */\n    public reset()\n    {\n        this.instructionSize = 0;\n    }\n\n    /**\n     * Destroy the instruction set, clearing the instructions and renderables.\n     * @internal\n     */\n    public destroy()\n    {\n        this.instructions.length = 0;\n        this.renderables.length = 0;\n\n        this.renderPipes = null;\n        this.gcTick = 0;\n    }\n\n    /**\n     * Add an instruction to the set\n     * @param instruction - add an instruction to the set\n     */\n    public add(instruction: Instruction)\n    {\n        this.instructions[this.instructionSize++] = instruction;\n    }\n\n    /**\n     * Log the instructions to the console (for debugging)\n     * @internal\n     */\n    public log()\n    {\n        this.instructions.length = this.instructionSize;\n        // eslint-disable-next-line no-console\n        console.table(this.instructions, ['type', 'action']);\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAgBO,MAAM,cACb,CAAA;IAYoB,qEAAA,GAGT,KACP,GAAA;QACI,IAAA,CAAK,eAAkB,GAAA,CAAA,CAAA;IAAA,CAC3B;IAAA;;;GAAA,GAMO,OACP,GAAA;QACI,IAAA,CAAK,YAAA,CAAa,MAAS,GAAA,CAAA,CAAA;QAC3B,IAAA,CAAK,WAAA,CAAY,MAAS,GAAA,CAAA,CAAA;QAE1B,IAAA,CAAK,WAAc,GAAA,IAAA,CAAA;QACnB,IAAA,CAAK,MAAS,GAAA,CAAA,CAAA;IAAA,CAClB;IAAA;;;GAAA,GAMO,IAAI,WACX,EAAA;QACS,IAAA,CAAA,YAAA,CAAa,IAAK,CAAA,eAAA,EAAiB,CAAI,GAAA,WAAA,CAAA;IAAA,CAChD;IAAA;;;GAAA,GAMO,GACP,GAAA;QACS,IAAA,CAAA,YAAA,CAAa,MAAA,GAAS,IAAK,CAAA,eAAA,CAAA;QAEhC,OAAA,CAAQ,KAAA,CAAM,IAAK,CAAA,YAAA,EAAc;YAAC,MAAA;YAAQ,QAAQ;SAAC,CAAA,CAAA;IAAA,CACvD;IApDG,WAAA,EAAA;QAGH,mEAAA,GAAgB,IAAA,CAAA,GAAA,OAAc,4NAAA,EAAI,gBAAgB,CAAA,CAAA;QAElD,8BAAA,GAAA,IAAA,CAAgB,YAAA,GAA8B,EAAC,CAAA;QAE/C,kFAAA,GAAA,IAAA,CAAO,eAAkB,GAAA,CAAA,CAAA;QAIzB,IAAA,CAAO,WAAA,GAA4B,EAAC,CAAA;QAEpC,kFAAA,GAAA,IAAA,CAAO,MAAS,GAAA,CAAA,CAAA;IAAA,CAAA;AAwCpB","debugId":null}},
    {"offset": {"line": 882, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts"],"sourcesContent":["import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { GlobalResourceRegistry } from '../../../../utils/pool/GlobalResourceRegistry';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\nimport { TextureStyle } from './TextureStyle';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @category rendering\n * @advanced\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /** The default texture style for the pool */\n    public textureStyle: TextureStyle;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n        this.textureStyle = new TextureStyle(this.textureOptions);\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: false,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool. Optionally reset the style of the texture to the default texture style.\n     * useful if you modified the style of the texture after getting it from the pool.\n     * @param renderTexture - The renderTexture to free\n     * @param resetStyle - Whether to reset the style of the texture to the default texture style\n     */\n    public returnTexture(renderTexture: Texture, resetStyle = false): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        // we can skip the copy if we don't need to reset the style\n        if (resetStyle)\n        {\n            renderTexture.source.style = this.textureStyle;\n        }\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\n/**\n * The default texture pool instance.\n * @category rendering\n * @advanced\n */\nexport const TexturePool = new TexturePoolClass();\nGlobalResourceRegistry.register(TexturePool);\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAQA,IAAI,KAAQ,GAAA,CAAA,CAAA;AAYL,MAAM,gBACb,CAAA;IA4BI;;;;;GAAA,GAQO,aAAA,CAAc,UAAoB,EAAA,WAAA,EAAqB,SAC9D,EAAA;QACU,MAAA,aAAA,GAAgB,IAAI,yRAAc,CAAA;YACpC,GAAG,IAAK,CAAA,cAAA;YAER,KAAO,EAAA,UAAA;YACP,MAAQ,EAAA,WAAA;YACR,UAAY,EAAA,CAAA;YACZ,SAAA;YACA,kBAAoB,EAAA,KAAA;QAAA,CACvB,CAAA,CAAA;QAED,OAAO,IAAI,kQAAQ,CAAA;YACf,MAAQ,EAAA,aAAA;YACR,KAAA,EAAO,eAAsB,CAAA,MAAP,KAAO,EAAA;QAAA,CAChC,CAAA,CAAA;IAAA,CACL;IAAA;;;;;;;GAAA,GAUO,iBAAkB,CAAA,UAAA,EAAoB,WAAqB,EAClE;YADkE,UAAA,oEAAa,GAAG,SAClF;QACI,IAAI,QAAW,GAAA,IAAA,CAAK,IAAM,CAAA,UAAA,GAAa,aAAc,IAAI,CAAA,CAAA;QACzD,IAAI,SAAY,GAAA,IAAA,CAAK,IAAM,CAAA,WAAA,GAAc,aAAc,IAAI,CAAA,CAAA;QAE3D,QAAA,OAAW,kOAAA,EAAS,QAAQ,CAAA,CAAA;QAC5B,SAAA,GAAY,sOAAA,EAAS,SAAS,CAAA,CAAA;QAE9B,MAAM,MAAA,CAAO,QAAY,IAAA,EAAA,IAAA,CAAO,SAAa,IAAA,CAAA,CAAA,GAAA,CAAM,YAAY,CAAI,GAAA,CAAA,CAAA,CAAA;QAEnE,IAAI,CAAC,IAAA,CAAK,YAAa,CAAA,GAAG,CAC1B,EAAA;YACS,IAAA,CAAA,YAAA,CAAa,GAAG,CAAA,GAAI,EAAC,CAAA;QAAA,CAC9B;QAEA,IAAI,OAAU,GAAA,IAAA,CAAK,YAAa,CAAA,GAAG,CAAA,CAAE,GAAI,EAAA,CAAA;QAEzC,IAAI,CAAC,OACL,EAAA;YACI,OAAA,GAAU,IAAK,CAAA,aAAA,CAAc,QAAU,EAAA,SAAA,EAAW,SAAS,CAAA,CAAA;QAAA,CAC/D;QAEA,OAAA,CAAQ,MAAA,CAAO,WAAc,GAAA,UAAA,CAAA;QACrB,OAAA,CAAA,MAAA,CAAO,KAAA,GAAQ,QAAW,GAAA,UAAA,CAAA;QAC1B,OAAA,CAAA,MAAA,CAAO,MAAA,GAAS,SAAY,GAAA,UAAA,CAAA;QACpC,OAAA,CAAQ,MAAA,CAAO,UAAa,GAAA,QAAA,CAAA;QAC5B,OAAA,CAAQ,MAAA,CAAO,WAAc,GAAA,SAAA,CAAA;QAG7B,OAAA,CAAQ,KAAA,CAAM,CAAI,GAAA,CAAA,CAAA;QAClB,OAAA,CAAQ,KAAA,CAAM,CAAI,GAAA,CAAA,CAAA;QAClB,OAAA,CAAQ,KAAA,CAAM,KAAQ,GAAA,UAAA,CAAA;QACtB,OAAA,CAAQ,KAAA,CAAM,MAAS,GAAA,WAAA,CAAA;QAEvB,OAAA,CAAQ,SAAU,EAAA,CAAA;QAEb,IAAA,CAAA,YAAA,CAAa,OAAQ,CAAA,GAAG,CAAI,GAAA,GAAA,CAAA;QAE1B,OAAA,OAAA,CAAA;IAAA,CACX;IAAA;;;;;GAAA,GAQO,kBAAA,CAAmB,OAAkB,EAC5C;wBAD4C,SAAA,wDAAY,KACxD;QACI,MAAM,SAAS,OAAQ,CAAA,MAAA,CAAA;QAEhB,OAAA,IAAA,CAAK,iBAAA,CAAkB,OAAQ,CAAA,KAAA,EAAO,QAAQ,MAAQ,EAAA,MAAA,CAAO,WAAA,EAAa,SAAS,CAAA,CAAA;IAAA,CAC9F;IAAA;;;;;GAAA,GAQO,aAAA,CAAc,aAAwB,EAC7C;yBAD6C,UAAA,uDAAa,KAC1D;QACI,MAAM,GAAM,GAAA,IAAA,CAAK,YAAa,CAAA,aAAA,CAAc,GAAG,CAAA,CAAA;QAG/C,IAAI,UACJ,EAAA;YACkB,aAAA,CAAA,MAAA,CAAO,KAAA,GAAQ,IAAK,CAAA,YAAA,CAAA;QAAA,CACtC;QAEA,IAAA,CAAK,YAAa,CAAA,GAAG,CAAE,CAAA,IAAA,CAAK,aAAa,CAAA,CAAA;IAAA,CAC7C;IAAA;;;GAAA,GAMO,MAAM,eACb,EAAA;QACI,eAAA,GAAkB,eAAoB,KAAA,KAAA,CAAA;QACtC,IAAI,eACJ,EAAA;YACe,IAAA,MAAA,CAAA,IAAK,IAAA,CAAK,YACrB,CAAA;gBACU,MAAA,QAAA,GAAW,IAAK,CAAA,YAAA,CAAa,CAAC,CAAA,CAAA;gBAEpC,IAAI,QACJ,EAAA;oBACI,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,QAAA,CAAS,MAAA,EAAQ,CACrC,EAAA,CAAA;wBACa,QAAA,CAAA,CAAC,CAAE,CAAA,OAAA,CAAQ,IAAI,CAAA,CAAA;oBAAA,CAC5B;gBAAA,CACJ;YAAA,CACJ;QAAA,CACJ;QAEA,IAAA,CAAK,YAAA,GAAe,CAAA,CAAC,CAAA;IAAA,CACzB;IA/JJ;;;GAAA,GAsBI,YAAY,cACZ,CAAA;QAPQ,IAAA,CAAA,YAAA,GAAA,aAAA,GAA8C,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;QAQ7D,IAAA,CAAK,YAAA,GAAe,CAAA,CAAC,CAAA;QAChB,IAAA,CAAA,cAAA,GAAiB,kBAAkB,CAAA,CAAC,CAAA;QACzC,IAAA,CAAK,gBAAmB,GAAA,KAAA,CAAA;QACxB,IAAA,CAAK,YAAe,GAAA,IAAI,4QAAa,CAAA,IAAA,CAAK,cAAc,CAAA,CAAA;IAAA,CAC5D;AAoIJ,CAAA;AAOa,MAAA,WAAA,GAAc,IAAI,gBAAiB,GAAA;AAChD,kQAAA,CAAuB,QAAA,CAAS,WAAW,CAAA","debugId":null}},
    {"offset": {"line": 1013, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/mask/utils/addMaskBounds.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/mask/utils/addMaskBounds.ts"],"sourcesContent":["import { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\n\nimport type { Container } from '../../../scene/container/Container';\n\nconst tempBounds = new Bounds();\n\n/**\n * @param mask\n * @param bounds\n * @param skipUpdateTransform\n * @internal\n */\nexport function addMaskBounds(mask: Container, bounds: Bounds, skipUpdateTransform: boolean): void\n{\n    const boundsToMask = tempBounds;\n\n    mask.measurable = true;\n\n    getGlobalBounds(mask, skipUpdateTransform, boundsToMask);\n\n    bounds.addBoundsMask(boundsToMask);\n\n    mask.measurable = false;\n}\n\n"],"names":[],"mappings":";;;;;;;;;AAKA,MAAM,UAAA,GAAa,IAAI,iPAAO,EAAA,CAAA;AAQd,SAAA,aAAA,CAAc,IAAiB,EAAA,MAAA,EAAgB,mBAC/D,EAAA;IACI,MAAM,YAAe,GAAA,UAAA,CAAA;IAErB,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;QAEF,mQAAA,EAAA,IAAA,EAAM,qBAAqB,YAAY,CAAA,CAAA;IAEvD,MAAA,CAAO,aAAA,CAAc,YAAY,CAAA,CAAA;IAEjC,IAAA,CAAK,UAAa,GAAA,KAAA,CAAA;AACtB","debugId":null}},
    {"offset": {"line": 1036, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/mask/utils/addMaskLocalBounds.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/mask/utils/addMaskLocalBounds.ts"],"sourcesContent":["import { getLocalBounds } from '../../../scene/container/bounds/getLocalBounds';\nimport { boundsPool, matrixPool } from '../../../scene/container/bounds/utils/matrixAndBoundsPool';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\n\n/**\n * @param mask\n * @param bounds\n * @param localRoot\n * @internal\n */\nexport function addMaskLocalBounds(mask: Container, bounds: Bounds, localRoot: Container): void\n{\n    const boundsToMask = boundsPool.get();\n\n    mask.measurable = true;\n\n    const tempMatrix = matrixPool.get().identity();\n\n    const relativeMask = getMatrixRelativeToParent(mask, localRoot, tempMatrix);\n\n    getLocalBounds(mask, boundsToMask, relativeMask);\n\n    mask.measurable = false;\n\n    bounds.addBoundsMask(boundsToMask);\n\n    matrixPool.return(tempMatrix);\n    boundsPool.return(boundsToMask);\n}\n\nfunction getMatrixRelativeToParent(target: Container, root: Container, matrix: Matrix): Matrix\n{\n    if (!target)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Mask bounds, renderable is not inside the root container');\n        // #endif\n\n        return matrix;\n    }\n\n    if (target !== root)\n    {\n        getMatrixRelativeToParent(target.parent, root, matrix);\n\n        target.updateLocalTransform();\n\n        matrix.append(target.localTransform);\n    }\n\n    return matrix;\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAcgB,SAAA,kBAAA,CAAmB,IAAiB,EAAA,MAAA,EAAgB,SACpE,EAAA;IACU,MAAA,YAAA,GAAe,2QAAA,CAAW,GAAI,EAAA,CAAA;IAEpC,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;IAElB,MAAM,UAAa,GAAA,2QAAA,CAAW,GAAI,EAAA,CAAE,QAAS,EAAA,CAAA;IAE7C,MAAM,YAAe,GAAA,yBAAA,CAA0B,IAAM,EAAA,SAAA,EAAW,UAAU,CAAA,CAAA;QAE3D,iQAAA,EAAA,IAAA,EAAM,cAAc,YAAY,CAAA,CAAA;IAE/C,IAAA,CAAK,UAAa,GAAA,KAAA,CAAA;IAElB,MAAA,CAAO,aAAA,CAAc,YAAY,CAAA,CAAA;IAEjC,2QAAA,CAAW,MAAA,CAAO,UAAU,CAAA,CAAA;IAC5B,2QAAA,CAAW,MAAA,CAAO,YAAY,CAAA,CAAA;AAClC,CAAA;AAEA,SAAS,yBAAA,CAA0B,MAAmB,EAAA,IAAA,EAAiB,MACvE,EAAA;IACI,IAAI,CAAC,MACL,EAAA;YAGI,iOAAA,EAAK,0DAA0D,CAAA,CAAA;QAGxD,OAAA,MAAA,CAAA;IAAA,CACX;IAEA,IAAI,WAAW,IACf,EAAA;QAC8B,yBAAA,CAAA,MAAA,CAAO,MAAQ,EAAA,IAAA,EAAM,MAAM,CAAA,CAAA;QAErD,MAAA,CAAO,oBAAqB,EAAA,CAAA;QAErB,MAAA,CAAA,MAAA,CAAO,OAAO,cAAc,CAAA,CAAA;IAAA,CACvC;IAEO,OAAA,MAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 1076, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMask.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/mask/alpha/AlphaMask.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * AlphaMask is an effect that applies a mask to a container using the alpha channel of a sprite.\n * It can be used to create complex masking effects by using a sprite as the mask.\n * The mask can be inverted, and it can render the mask to a texture if the mask is not a sprite.\n * @category rendering\n * @advanced\n */\nexport class AlphaMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public inverse: boolean = false;\n    public pipe = 'alphaMask';\n    public renderMaskToTexture: boolean;\n\n    constructor(options?: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n\n        // TODO - might want to change this to adjust on the fly\n        // user may add children to the sprite..\n        this.renderMaskToTexture = !(mask instanceof Sprite);\n\n        this.mask.renderable = this.renderMaskToTexture;\n        this.mask.includeInBuild = !this.renderMaskToTexture;\n\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform?: boolean): void\n    {\n        if (!this.inverse)\n        {\n            addMaskBounds(this.mask, bounds, skipUpdateTransform);\n        }\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Sprite;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAmBO,MAAM,SACb,CAAA;IAiBW,KAAK,IACZ,EAAA;QACI,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;QAIP,IAAA,CAAA,mBAAA,GAAsB,CAAA,CAAE,IAAgB,YAAA,oOAAA,CAAA,CAAA;QAExC,IAAA,CAAA,IAAA,CAAK,UAAA,GAAa,IAAK,CAAA,mBAAA,CAAA;QACvB,IAAA,CAAA,IAAA,CAAK,cAAiB,GAAA,CAAC,IAAK,CAAA,mBAAA,CAAA;QAEjC,IAAA,CAAK,IAAA,CAAK,UAAa,GAAA,KAAA,CAAA;IAAA,CAC3B;IAEO,KACP,GAAA;QACI,IAAA,CAAK,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;QACvB,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;IAAA,CAChB;IAEO,SAAA,CAAU,MAAA,EAAgB,mBACjC,EAAA;QACQ,IAAA,CAAC,IAAA,CAAK,OACV,EAAA;gBACkB,6PAAA,EAAA,IAAA,CAAK,IAAM,EAAA,MAAA,EAAQ,mBAAmB,CAAA,CAAA;QAAA,CACxD;IAAA,CACJ;IAEO,cAAA,CAAe,MAAA,EAAgB,SACtC,EAAA;QACuB,2QAAA,EAAA,IAAA,CAAK,IAAM,EAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;IAAA,CACnD;IAEO,aAAA,CAAc,KAAA,EAAc,SACnC,EAAA;QACI,MAAM,OAAO,IAAK,CAAA,IAAA,CAAA;QAGX,OAAA,SAAA,CAAU,MAAM,KAAK,CAAA,CAAA;IAAA,CAChC;IAEO,OACP,GAAA;QACI,IAAA,CAAK,KAAM,EAAA,CAAA;IAAA,CACf;IAEA,OAAc,KAAK,IACnB,EAAA;QACI,OAAO,IAAgB,YAAA,oOAAA,CAAA;IAAA,CAC3B;IAzDA,YAAY,OACZ,CAAA;QAPA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;QAElB,IAAA,CAAO,OAAmB,GAAA,KAAA,CAAA;QAC1B,IAAA,CAAO,IAAO,GAAA,WAAA,CAAA;QAKV,sDAAI,QAAS,IACb,EAAA;YACS,IAAA,CAAA,IAAA,CAAK,QAAQ,IAAI,CAAA,CAAA;QAAA,CAC1B;IAAA,CACJ;AAoDJ,CAAA;AApEa,SAAA,CAEK,SAAA,GAA+B,0OAAc,CAAA,UAAA","debugId":null}},
    {"offset": {"line": 1135, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/mask/color/ColorMask.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/mask/color/ColorMask.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * The ColorMask effect allows you to apply a color mask to the rendering process.\n * This can be useful for selectively rendering certain colors or for creating\n * effects based on color values.\n * @category rendering\n * @advanced\n */\nexport class ColorMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: number;\n    public pipe = 'colorMask';\n\n    constructor(options: {mask: number})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: number): void\n    {\n        this.mask = mask;\n    }\n\n    public destroy(): void\n    {\n        // nothing to destroy\n    }\n\n    public static test(mask: any): boolean\n    {\n        return typeof mask === 'number';\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAaO,MAAM,SACb,CAAA;IAeW,KAAK,IACZ,EAAA;QACI,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;IAAA,CAChB;IAEO,OACP,GAAA,CAAA,CAEA;IAEA,OAAc,KAAK,IACnB,EAAA;QACI,OAAO,OAAO,IAAS,KAAA,QAAA,CAAA;IAAA,CAC3B;IArBA,YAAY,OACZ,CAAA;QALA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;QAElB,IAAA,CAAO,IAAO,GAAA,WAAA,CAAA;QAIV,sDAAI,QAAS,IACb,EAAA;YACS,IAAA,CAAA,IAAA,CAAK,QAAQ,IAAI,CAAA,CAAA;QAAA,CAC1B;IAAA,CACJ;AAgBJ,CAAA;AA9Ba,SAAA,CAEK,SAAA,GAA+B,0OAAc,CAAA,UAAA","debugId":null}},
    {"offset": {"line": 1165, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/mask/stencil/StencilMask.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/mask/stencil/StencilMask.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Container } from '../../../scene/container/Container';\nimport { addMaskBounds } from '../utils/addMaskBounds';\nimport { addMaskLocalBounds } from '../utils/addMaskLocalBounds';\n\nimport type { ExtensionMetadata } from '../../../extensions/Extensions';\nimport type { Point } from '../../../maths/point/Point';\nimport type { Bounds } from '../../../scene/container/bounds/Bounds';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\n\n/**\n * A mask that uses the stencil buffer to clip the rendering of a container.\n * This is useful for complex masks that cannot be achieved with simple shapes.\n * It is more performant than using a `Graphics` mask, but requires WebGL support.\n * It is also useful for masking with `Container` objects that have complex shapes.\n * @category rendering\n * @advanced\n */\nexport class StencilMask implements Effect, PoolItem\n{\n    public static extension: ExtensionMetadata = ExtensionType.MaskEffect;\n\n    public priority = 0;\n    public mask: Container;\n    public pipe = 'stencilMask';\n\n    constructor(options: {mask: Container})\n    {\n        if (options?.mask)\n        {\n            this.init(options.mask);\n        }\n    }\n\n    public init(mask: Container): void\n    {\n        this.mask = mask;\n        this.mask.includeInBuild = false;\n        this.mask.measurable = false;\n    }\n\n    public reset()\n    {\n        this.mask.measurable = true;\n        this.mask.includeInBuild = true;\n        this.mask = null;\n    }\n\n    public addBounds(bounds: Bounds, skipUpdateTransform: boolean): void\n    {\n        addMaskBounds(this.mask, bounds, skipUpdateTransform);\n    }\n\n    public addLocalBounds(bounds: Bounds, localRoot: Container): void\n    {\n        addMaskLocalBounds(this.mask, bounds, localRoot);\n    }\n\n    public containsPoint(point: Point, hitTestFn: (container: Container, point: Point) => boolean): boolean\n    {\n        const mask = this.mask as any;\n\n        // if the point is in the mask, yay!\n        return hitTestFn(mask, point);\n    }\n\n    public destroy(): void\n    {\n        this.reset();\n    }\n\n    public static test(mask: any): boolean\n    {\n        return mask instanceof Container;\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAmBO,MAAM,WACb,CAAA;IAeW,KAAK,IACZ,EAAA;QACI,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;QACZ,IAAA,CAAK,IAAA,CAAK,cAAiB,GAAA,KAAA,CAAA;QAC3B,IAAA,CAAK,IAAA,CAAK,UAAa,GAAA,KAAA,CAAA;IAAA,CAC3B;IAEO,KACP,GAAA;QACI,IAAA,CAAK,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;QACvB,IAAA,CAAK,IAAA,CAAK,cAAiB,GAAA,IAAA,CAAA;QAC3B,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;IAAA,CAChB;IAEO,SAAA,CAAU,MAAA,EAAgB,mBACjC,EAAA;YACkB,6PAAA,EAAA,IAAA,CAAK,IAAM,EAAA,MAAA,EAAQ,mBAAmB,CAAA,CAAA;IAAA,CACxD;IAEO,cAAA,CAAe,MAAA,EAAgB,SACtC,EAAA;QACuB,2QAAA,EAAA,IAAA,CAAK,IAAM,EAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;IAAA,CACnD;IAEO,aAAA,CAAc,KAAA,EAAc,SACnC,EAAA;QACI,MAAM,OAAO,IAAK,CAAA,IAAA,CAAA;QAGX,OAAA,SAAA,CAAU,MAAM,KAAK,CAAA,CAAA;IAAA,CAChC;IAEO,OACP,GAAA;QACI,IAAA,CAAK,KAAM,EAAA,CAAA;IAAA,CACf;IAEA,OAAc,KAAK,IACnB,EAAA;QACI,OAAO,IAAgB,YAAA,6OAAA,CAAA;IAAA,CAC3B;IAhDA,YAAY,OACZ,CAAA;QALA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;QAElB,IAAA,CAAO,IAAO,GAAA,aAAA,CAAA;QAIV,sDAAI,QAAS,IACb,EAAA;YACS,IAAA,CAAA,IAAA,CAAK,QAAQ,IAAI,CAAA,CAAA;QAAA,CAC1B;IAAA,CACJ;AA2CJ,CAAA;AAzDa,WAAA,CAEK,SAAA,GAA+B,0OAAc,CAAA,UAAA","debugId":null}},
    {"offset": {"line": 1220, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/CanvasSource.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/CanvasSource.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * Options for creating a CanvasSource.\n * @category rendering\n * @advanced\n */\nexport interface CanvasSourceOptions extends TextureSourceOptions<ICanvas>\n{\n    /**\n     * Should the canvas be resized to preserve its screen width and height regardless\n     * of the resolution of the renderer, this is only supported for HTMLCanvasElement\n     * and will be ignored if the canvas is an OffscreenCanvas.\n     */\n    autoDensity?: boolean;\n    /** if true, this canvas will be set up to be transparent where possible */\n    transparent?: boolean;\n}\n\n/**\n * A texture source that uses a canvas as its resource.\n * It automatically resizes the canvas based on the width, height, and resolution.\n * It also provides a 2D rendering context for drawing.\n * @category rendering\n * @advanced\n */\nexport class CanvasSource extends TextureSource<ICanvas>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'image';\n    public autoDensity: boolean;\n    public transparent: boolean;\n\n    private _context2D: CanvasRenderingContext2D;\n\n    constructor(options: CanvasSourceOptions)\n    {\n        if (!options.resource)\n        {\n            options.resource = DOMAdapter.get().createCanvas();\n        }\n\n        if (!options.width)\n        {\n            options.width = options.resource.width;\n\n            if (!options.autoDensity)\n            {\n                options.width /= options.resolution;\n            }\n        }\n\n        if (!options.height)\n        {\n            options.height = options.resource.height;\n\n            if (!options.autoDensity)\n            {\n                options.height /= options.resolution;\n            }\n        }\n\n        super(options);\n\n        this.autoDensity = options.autoDensity;\n\n        this.resizeCanvas();\n\n        this.transparent = !!options.transparent;\n    }\n\n    public resizeCanvas()\n    {\n        if (this.autoDensity && 'style' in this.resource)\n        {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n\n        // only resize if wee need to, as this clears the canvas (even if values are set to the same)\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight)\n        {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n\n    public resize(width = this.width, height = this.height, resolution = this._resolution): boolean\n    {\n        const didResize = super.resize(width, height, resolution);\n\n        if (didResize)\n        {\n            this.resizeCanvas();\n        }\n\n        return didResize;\n    }\n\n    public static test(resource: any): resource is ICanvas\n    {\n        return (globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement)\n        || (globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas);\n    }\n\n    /**\n     * Returns the 2D rendering context for the canvas.\n     * Caches the context after creating it.\n     * @returns The 2D rendering context of the canvas.\n     */\n    get context2D(): CanvasRenderingContext2D\n    {\n        return this._context2D || (this._context2D = this.resource.getContext('2d') as CanvasRenderingContext2D);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAgCO,MAAM,qBAAqB,yRAClC,CAAA;IA6CW,YACP,GAAA;QACI,IAAI,IAAK,CAAA,WAAA,IAAe,OAAW,IAAA,IAAA,CAAK,QACxC,EAAA;YACI,IAAA,CAAK,QAAS,CAAA,KAAA,CAAM,KAAQ,GAAA,UAAG,IAAA,CAAK,KAAK,EAAA,EAAA,CAAA,CAAA;YACzC,IAAA,CAAK,QAAS,CAAA,KAAA,CAAM,MAAS,GAAA,UAAG,IAAA,CAAK,MAAM,EAAA,EAAA,CAAA,CAAA;QAAA,CAC/C;QAGI,IAAA,IAAA,CAAK,QAAA,CAAS,KAAU,KAAA,IAAA,CAAK,UAAA,IAAc,IAAK,CAAA,QAAA,CAAS,MAAW,KAAA,IAAA,CAAK,WAC7E,EAAA;YACS,IAAA,CAAA,QAAA,CAAS,KAAA,GAAQ,IAAK,CAAA,UAAA,CAAA;YACtB,IAAA,CAAA,QAAA,CAAS,MAAA,GAAS,IAAK,CAAA,WAAA,CAAA;QAAA,CAChC;IAAA,CACJ;IAEO,MAAA,GACP;oBADc,iEAAQ,IAAK,CAAA,KAAA,WAAO,iEAAS,IAAK,CAAA,MAAA,eAAQ,UAAa,uDAAA,IAAA,CAAK,WAC1E;QACI,MAAM,SAAY,GAAA,KAAA,CAAM,MAAO,CAAA,KAAA,EAAO,QAAQ,UAAU,CAAA,CAAA;QAExD,IAAI,SACJ,EAAA;YACI,IAAA,CAAK,YAAa,EAAA,CAAA;QAAA,CACtB;QAEO,OAAA,SAAA,CAAA;IAAA,CACX;IAEA,OAAc,KAAK,QACnB,EAAA;QACI,OAAQ,WAAW,iBAAqB,IAAA,QAAA,YAAoB,iBACxD,IAAA,UAAA,CAAW,eAAA,IAAmB,QAAoB,YAAA,eAAA,CAAA;IAAA,CAC1D;IAAA;;;;GAAA,GAOA,IAAI,SACJ,GAAA;QACI,OAAO,IAAA,CAAK,UAAe,IAAA,CAAA,IAAA,CAAK,UAAA,GAAa,IAAK,CAAA,QAAA,CAAS,UAAA,CAAW,IAAI,CAAA,CAAA,CAAA;IAAA,CAC9E;IA9EA,YAAY,OACZ,CAAA;QACQ,IAAA,CAAC,QAAQ,QACb,EAAA;YACI,OAAA,CAAQ,QAAW,GAAA,qOAAA,CAAW,GAAI,EAAA,CAAE,YAAa,EAAA,CAAA;QAAA,CACrD;QAEI,IAAA,CAAC,QAAQ,KACb,EAAA;YACY,OAAA,CAAA,KAAA,GAAQ,QAAQ,QAAS,CAAA,KAAA,CAAA;YAE7B,IAAA,CAAC,QAAQ,WACb,EAAA;gBACI,OAAA,CAAQ,KAAA,IAAS,OAAQ,CAAA,UAAA,CAAA;YAAA,CAC7B;QAAA,CACJ;QAEI,IAAA,CAAC,QAAQ,MACb,EAAA;YACY,OAAA,CAAA,MAAA,GAAS,QAAQ,QAAS,CAAA,MAAA,CAAA;YAE9B,IAAA,CAAC,QAAQ,WACb,EAAA;gBACI,OAAA,CAAQ,MAAA,IAAU,OAAQ,CAAA,UAAA,CAAA;YAAA,CAC9B;QAAA,CACJ;QAEA,KAAA,CAAM,OAAO,CAAA,CAAA;QAjCjB,IAAA,CAAO,cAAiB,GAAA,OAAA,CAAA;QAmCpB,IAAA,CAAK,WAAA,GAAc,OAAQ,CAAA,WAAA,CAAA;QAE3B,IAAA,CAAK,YAAa,EAAA,CAAA;QAEb,IAAA,CAAA,WAAA,GAAc,CAAC,CAAC,OAAQ,CAAA,WAAA,CAAA;IAAA,CACjC;AA6CJ,CAAA;AAzFa,YAAA,CAEK,SAAA,GAA+B,0OAAc,CAAA,aAAA","debugId":null}},
    {"offset": {"line": 1290, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/ImageSource.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/ImageSource.ts"],"sourcesContent":["import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * The type of image-like resource that can be used as a texture source.\n *\n * - `ImageBitmap` is used for bitmap images.\n * - `HTMLCanvasElement` and `OffscreenCanvas` are used for canvas elements.\n * - `ICanvas` is an interface for canvas-like objects.\n * - `VideoFrame` is used for video frames.\n * - `HTMLImageElement` is used for HTML image elements.\n * - `HTMLVideoElement` is used for HTML video elements.\n * @category rendering\n * @advanced\n */\nexport type ImageResource =\nImageBitmap\n| HTMLCanvasElement\n| OffscreenCanvas\n| ICanvas\n| VideoFrame\n| HTMLImageElement\n| HTMLVideoElement;\n\n/**\n * A texture source that uses an image-like resource as its resource.\n * It can handle HTMLImageElement, ImageBitmap, VideoFrame, and HTMLVideoElement.\n * It is used for textures that can be uploaded to the GPU.\n * @category rendering\n * @advanced\n */\nexport class ImageSource extends TextureSource<ImageResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n    public uploadMethodId = 'image';\n\n    constructor(options: TextureSourceOptions<ImageResource>)\n    {\n        super(options);\n\n        this.autoGarbageCollect = true;\n    }\n\n    public static test(resource: any): resource is ImageResource\n    {\n        return (globalThis.HTMLImageElement && resource instanceof HTMLImageElement)\n        || (typeof ImageBitmap !== 'undefined' && resource instanceof ImageBitmap)\n        || (globalThis.VideoFrame && resource instanceof VideoFrame);\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;AAmCO,MAAM,oBAAoB,yRACjC,CAAA;IAWI,OAAc,KAAK,QACnB,EAAA;QACY,OAAA,UAAA,CAAW,gBAAoB,IAAA,QAAA,YAAoB,gBACvD,IAAA,OAAO,WAAgB,KAAA,WAAA,IAAe,QAAoB,YAAA,WAAA,IAC1D,UAAW,CAAA,UAAA,IAAc,QAAoB,YAAA,UAAA,CAAA;IAAA,CACrD;IAZA,YAAY,OACZ,CAAA;QACI,KAAA,CAAM,OAAO,CAAA,CAAA;QAJjB,IAAA,CAAO,cAAiB,GAAA,OAAA,CAAA;QAMpB,IAAA,CAAK,kBAAqB,GAAA,IAAA,CAAA;IAAA,CAC9B;AAQJ,CAAA;AAlBa,WAAA,CAEK,SAAA,GAA+B,0OAAc,CAAA,aAAA","debugId":null}},
    {"offset": {"line": 1316, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/sources/VideoSource.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/VideoSource.ts"],"sourcesContent":["// VideoSource.ts\n\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { Ticker } from '../../../../../ticker/Ticker';\nimport { detectVideoAlphaMode } from '../../../../../utils/browser/detectVideoAlphaMode';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { Dict } from '../../../../../utils/types';\nimport type { ALPHA_MODES } from '../const';\nimport type { TextureSourceOptions } from './TextureSource';\n\n/**\n * The type of resource used for video textures.\n * This is typically an HTMLVideoElement.\n * @category rendering\n * @advanced\n */\nexport type VideoResource = HTMLVideoElement;\n\n/**\n * Options for video sources.\n * @category rendering\n * @advanced\n */\nexport interface VideoSourceOptions extends TextureSourceOptions<VideoResource>\n{\n    /** If true, the video will start loading immediately. */\n    autoLoad?: boolean;\n    /** If true, the video will start playing as soon as it is loaded. */\n    autoPlay?: boolean;\n    /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n    updateFPS?: number;\n    /** If true, the video will be loaded with the `crossorigin` attribute. */\n    crossorigin?: boolean | string;\n    /** If true, the video will loop when it ends. */\n    loop?: boolean;\n    /** If true, the video will be muted. */\n    muted?: boolean;\n    /** If true, the video will play inline. */\n    playsinline?: boolean;\n    /** If true, the video will be preloaded. */\n    preload?: boolean;\n    /** The time in milliseconds to wait for the video to preload before timing out. */\n    preloadTimeoutMs?: number;\n    /** The alpha mode of the video. */\n    alphaMode?: ALPHA_MODES;\n}\n\n/**\n * A texture source that uses a video as its resource.\n * It automatically resizes the texture based on the video dimensions.\n * It also provides methods to control playback and handle video events.\n * This class supports automatic loading, playback, and frame updates.\n * It can also handle cross-origin videos and provides options for looping, muting, and inline playback.\n * @category rendering\n * @advanced\n */\nexport class VideoSource extends TextureSource<VideoResource>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    /** The default options for video sources. */\n    public static defaultOptions: VideoSourceOptions = {\n        ...TextureSource.defaultOptions,\n        /** If true, the video will start loading immediately. */\n        autoLoad: true,\n        /** If true, the video will start playing as soon as it is loaded. */\n        autoPlay: true,\n        /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */\n        updateFPS: 0,\n        /** If true, the video will be loaded with the `crossorigin` attribute. */\n        crossorigin: true,\n        /** If true, the video will loop when it ends. */\n        loop: false,\n        /** If true, the video will be muted. */\n        muted: true,\n        /** If true, the video will play inline. */\n        playsinline: true,\n        /** If true, the video will be preloaded. */\n        preload: false,\n    };\n\n    // Public\n    /** Whether or not the video is ready to play. */\n    public isReady = false;\n    /** The upload method for this texture. */\n    public uploadMethodId = 'video';\n\n    // Protected\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     * @default true\n     */\n    protected autoPlay: boolean;\n\n    // Private\n    /**\n     * `true` to use Ticker.shared to auto update the base texture.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update the base texture.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /**\n     * Promise when loading.\n     * @default null\n     */\n    private _load: Promise<this>;\n\n    private _msToNextUpdate: number;\n    private _preloadTimeout: number;\n\n    /** Callback when completed with load. */\n    private _resolve: (value?: this | PromiseLike<this>) => void;\n    private _reject: (error: ErrorEvent) => void;\n\n    private _updateFPS: number;\n    private _videoFrameRequestCallbackHandle: number | null;\n\n    constructor(\n        options: VideoSourceOptions\n    )\n    {\n        super(options);\n\n        // Merge provided options with default ones\n        options = {\n            ...VideoSource.defaultOptions,\n            ...options\n        };\n\n        this._autoUpdate = true;\n        this._isConnectedToTicker = false;\n        this._updateFPS = options.updateFPS || 0;\n        this._msToNextUpdate = 0;\n        this.autoPlay = options.autoPlay !== false;\n        this.alphaMode = options.alphaMode ?? 'premultiply-alpha-on-upload';\n\n        // Binding for frame updates\n        this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);\n        this._videoFrameRequestCallbackHandle = null;\n\n        this._load = null;\n        this._resolve = null;\n        this._reject = null;\n\n        // Bind for listeners\n        this._onCanPlay = this._onCanPlay.bind(this);\n        this._onCanPlayThrough = this._onCanPlayThrough.bind(this);\n        this._onError = this._onError.bind(this);\n        this._onPlayStart = this._onPlayStart.bind(this);\n        this._onPlayStop = this._onPlayStop.bind(this);\n        this._onSeeked = this._onSeeked.bind(this);\n\n        if (options.autoLoad !== false)\n        {\n            void this.load();\n        }\n    }\n\n    /** Update the video frame if the source is not destroyed and meets certain conditions. */\n    protected updateFrame(): void\n    {\n        if (this.destroyed)\n        {\n            return;\n        }\n\n        if (this._updateFPS)\n        {\n            // Account for if video has had its playbackRate changed\n            const elapsedMS = Ticker.shared.elapsedMS * this.resource.playbackRate;\n\n            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);\n        }\n\n        if (!this._updateFPS || this._msToNextUpdate <= 0)\n        {\n            this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;\n        }\n\n        if (this.isValid)\n        {\n            this.update();\n        }\n    }\n\n    /** Callback to update the video frame and potentially request the next frame update. */\n    private _videoFrameRequestCallback(): void\n    {\n        this.updateFrame();\n\n        if (this.destroyed)\n        {\n            this._videoFrameRequestCallbackHandle = null;\n        }\n        else\n        {\n            this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                this._videoFrameRequestCallback\n            );\n        }\n    }\n\n    /**\n     * Checks if the resource has valid dimensions.\n     * @returns {boolean} True if width and height are set, otherwise false.\n     */\n    public get isValid(): boolean\n    {\n        return !!this.resource.videoWidth && !!this.resource.videoHeight;\n    }\n\n    /**\n     * Start preloading the video resource.\n     * @returns {Promise<this>} Handle the validate event\n     */\n    public async load(): Promise<this>\n    {\n        if (this._load)\n        {\n            return this._load;\n        }\n\n        const source = this.resource;\n        const options = this.options as VideoSourceOptions;\n\n        // Check if source data is enough and set it to complete if needed\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            (source as any).complete = true;\n        }\n\n        // Add event listeners related to playback and seeking\n        source.addEventListener('play', this._onPlayStart);\n        source.addEventListener('pause', this._onPlayStop);\n        source.addEventListener('seeked', this._onSeeked);\n\n        // Add or handle source readiness event listeners\n        if (!this._isSourceReady())\n        {\n            if (!options.preload)\n            {\n                // since this event fires early, only bind if not waiting for a preload event\n                source.addEventListener('canplay', this._onCanPlay);\n            }\n            source.addEventListener('canplaythrough', this._onCanPlayThrough);\n            source.addEventListener('error', this._onError, true);\n        }\n        else\n        {\n            // Source is already ready, so handle it immediately\n            this._mediaReady();\n        }\n\n        this.alphaMode = await detectVideoAlphaMode();\n\n        // Create and return the loading promise\n        this._load = new Promise((resolve, reject): void =>\n        {\n            if (this.isValid)\n            {\n                resolve(this);\n            }\n            else\n            {\n                this._resolve = resolve;\n                this._reject = reject;\n\n                if (options.preloadTimeoutMs !== undefined)\n                {\n                    this._preloadTimeout = setTimeout(() =>\n                    {\n                        this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));\n                    }) as unknown as number;\n                }\n                source.load();\n            }\n        });\n\n        return this._load;\n    }\n\n    /**\n     * Handle video error events.\n     * @param event - The error event\n     */\n    private _onError(event: ErrorEvent): void\n    {\n        this.resource.removeEventListener('error', this._onError, true);\n        this.emit('error', event);\n\n        if (this._reject)\n        {\n            this._reject(event);\n            this._reject = null;\n            this._resolve = null;\n        }\n    }\n\n    /**\n     * Checks if the underlying source is playing.\n     * @returns True if playing.\n     */\n    private _isSourcePlaying(): boolean\n    {\n        const source = this.resource;\n\n        return (!source.paused && !source.ended);\n    }\n\n    /**\n     * Checks if the underlying source is ready for playing.\n     * @returns True if ready.\n     */\n    private _isSourceReady(): boolean\n    {\n        const source = this.resource;\n\n        return source.readyState > 2;\n    }\n\n    /** Runs the update loop when the video is ready to play. */\n    private _onPlayStart(): void\n    {\n        // Handle edge case where video might not have received its \"can play\" event yet\n        if (!this.isValid)\n        {\n            this._mediaReady();\n        }\n\n        this._configureAutoUpdate();\n    }\n\n    /** Stops the update loop when a pause event is triggered. */\n    private _onPlayStop(): void\n    {\n        this._configureAutoUpdate();\n    }\n\n    /** Handles behavior when the video completes seeking to the current playback position. */\n    private _onSeeked(): void\n    {\n        if (this._autoUpdate && !this._isSourcePlaying())\n        {\n            this._msToNextUpdate = 0;\n            this.updateFrame();\n            this._msToNextUpdate = 0;\n        }\n    }\n\n    private _onCanPlay(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplay', this._onCanPlay);\n\n        this._mediaReady();\n    }\n\n    private _onCanPlayThrough(): void\n    {\n        const source = this.resource;\n\n        // Remove event listeners\n        source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        if (this._preloadTimeout)\n        {\n            clearTimeout(this._preloadTimeout);\n            this._preloadTimeout = undefined;\n        }\n\n        this._mediaReady();\n    }\n\n    /** Fired when the video is loaded and ready to play. */\n    private _mediaReady(): void\n    {\n        const source = this.resource;\n\n        if (this.isValid)\n        {\n            this.isReady = true;\n            this.resize(source.videoWidth, source.videoHeight);\n        }\n\n        // Reset update timers and perform a frame update\n        this._msToNextUpdate = 0;\n        this.updateFrame();\n        this._msToNextUpdate = 0;\n\n        // Resolve the loading promise if it exists\n        if (this._resolve)\n        {\n            this._resolve(this);\n            this._resolve = null;\n            this._reject = null;\n        }\n\n        // Handle play behavior based on current source status\n        if (this._isSourcePlaying())\n        {\n            this._onPlayStart();\n        }\n        else if (this.autoPlay)\n        {\n            void this.resource.play();\n        }\n    }\n\n    /** Cleans up resources and event listeners associated with this texture. */\n    public destroy()\n    {\n        this._configureAutoUpdate();\n\n        const source = this.resource;\n\n        if (source)\n        {\n            // Remove event listeners\n            source.removeEventListener('play', this._onPlayStart);\n            source.removeEventListener('pause', this._onPlayStop);\n            source.removeEventListener('seeked', this._onSeeked);\n            source.removeEventListener('canplay', this._onCanPlay);\n            source.removeEventListener('canplaythrough', this._onCanPlayThrough);\n            source.removeEventListener('error', this._onError, true);\n\n            // Clear the video source and pause\n            source.pause();\n            source.src = '';\n            source.load();\n        }\n\n        super.destroy();\n    }\n\n    /** Should the base texture automatically update itself, set to true by default. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * How many times a second to update the texture from the video.\n     * Leave at 0 to update at every render.\n     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.\n     */\n    get updateFPS(): number\n    {\n        return this._updateFPS;\n    }\n\n    set updateFPS(value: number)\n    {\n        if (value !== this._updateFPS)\n        {\n            this._updateFPS = value;\n            this._configureAutoUpdate();\n        }\n    }\n\n    /**\n     * Configures the updating mechanism based on the current state and settings.\n     *\n     * This method decides between using the browser's native video frame callback or a custom ticker\n     * for updating the video frame. It ensures optimal performance and responsiveness\n     * based on the video's state, playback status, and the desired frames-per-second setting.\n     *\n     * - If `_autoUpdate` is enabled and the video source is playing:\n     *   - It will prefer the native video frame callback if available and no specific FPS is set.\n     *   - Otherwise, it will use a custom ticker for manual updates.\n     * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.\n     */\n    private _configureAutoUpdate(): void\n    {\n        // Check if automatic updating is enabled and if the source is currently playing\n        if (this._autoUpdate && this._isSourcePlaying())\n        {\n            // Determine if we should use the browser's native video frame callback (generally for better performance)\n            if (!this._updateFPS && this.resource.requestVideoFrameCallback)\n            {\n                // If connected to a custom ticker, remove the update frame function from it\n                if (this._isConnectedToTicker)\n                {\n                    Ticker.shared.remove(this.updateFrame, this);\n                    this._isConnectedToTicker = false;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n\n                // Check if we haven't already requested a video frame callback, and if not, request one\n                if (this._videoFrameRequestCallbackHandle === null)\n                {\n                    this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(\n                        this._videoFrameRequestCallback\n                    );\n                }\n            }\n            else\n            {\n                // If a video frame request callback exists, cancel it, as we are switching to manual ticker-based updates\n                if (this._videoFrameRequestCallbackHandle !== null)\n                {\n                    this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                    this._videoFrameRequestCallbackHandle = null;\n                }\n\n                // If not connected to the custom ticker, add the update frame function to it\n                if (!this._isConnectedToTicker)\n                {\n                    Ticker.shared.add(this.updateFrame, this);\n                    this._isConnectedToTicker = true;\n                    // Reset the time until the next update\n                    this._msToNextUpdate = 0;\n                }\n            }\n        }\n        else\n        {\n            // If automatic updating is disabled or the source isn't playing, perform cleanup\n\n            // Cancel any existing video frame callback request\n            if (this._videoFrameRequestCallbackHandle !== null)\n            {\n                this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle);\n                this._videoFrameRequestCallbackHandle = null;\n            }\n\n            // Remove the update frame function from the custom ticker\n            if (this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.updateFrame, this);\n                this._isConnectedToTicker = false;\n                // Reset the time until the next update\n                this._msToNextUpdate = 0;\n            }\n        }\n    }\n\n    /**\n     * Map of video MIME types that can't be directly derived from file extensions.\n     * @readonly\n     */\n    public static MIME_TYPES: Dict<string>\n        = {\n            ogv: 'video/ogg',\n            mov: 'video/quicktime',\n            m4v: 'video/mp4',\n        };\n\n    public static test(resource: any): resource is VideoResource\n    {\n        return (globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement);\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1621, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/textureFrom.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/textureFrom.ts"],"sourcesContent":["import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferImageSource';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer | ICanvas): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\n/**\n * The type of resource or options that can be used to create a texture source.\n * This includes ImageResource, TextureSourceOptions, BufferSourceOptions, and CanvasSourceOptions.\n * @category rendering\n * @advanced\n */\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions\n  | CanvasSourceOptions;\n\n/**\n * @param options\n * @deprecated since v8.2.0\n * @see TextureSource.from\n * @category rendering\n * @internal\n */\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    return textureSourceFrom(options);\n}\n\n/**\n * Creates a texture source from the options provided\n * @param options - The options to create the texture source from. This can be\n */\nfunction textureSourceFrom(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\n/**\n * @param options\n * @param skipCache\n * @internal\n */\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: textureSourceFrom(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n * @category utils\n * @internal\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\nTextureSource.from = textureSourceFrom;\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAmBA,MAAM,UAAsC,EAAC,CAAA;AAE7C,uOAAW,CAAA,YAAA,CAAa,0OAAc,CAAA,aAAA,EAAe,OAAO,CAAA,CAAA;AAqB5C,SAAA,gBAAA;kBAAiB,OAAoC,0DAAA,CAAA,CACrE,EAAA;IACI,OAAO,kBAAkB,OAAO,CAAA,CAAA;AACpC,CAAA;AAMA,SAAS,iBAAA;kBAAkB,OAAoC,0DAAA,CAAA,CAC/D,EAAA;IACU,MAAA,WAAA,GAAc,WAAY,OAAiC,CAAA,QAAA,CAAA;IAC3D,MAAA,GAAA,GAAM,WAAe,GAAA,OAAA,CAAiC,QAAW,GAAA,OAAA,CAAA;IACvE,MAAM,IAAO,GAAA,WAAA,GAAc,OAAkC,GAAA;QAAE,UAAU,OAAQ;IAAA,CAAA,CAAA;IAEjF,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,OAAA,CAAQ,MAAA,EAAQ,CACpC,EAAA,CAAA;QACU,MAAA,MAAA,GAAS,OAAA,CAAQ,CAAC,CAAA,CAAA;QAEpB,IAAA,MAAA,CAAO,IAAK,CAAA,GAAG,CACnB,EAAA;YACW,OAAA,IAAI,OAAO,IAAI,CAAA,CAAA;QAAA,CAC1B;IAAA,CACJ;IAEA,MAAM,IAAI,KAAA,CAAM,AAA8C,2CAAA,GAAe,CAAA,CAAA,CAAA,IAAf,IAAA,CAAK,QAAQ;AAC/E,CAAA;AAOO,SAAS,iBACZ;kBAAA,OAAA,0DAAoC,CAAA,CAAC,cACrC,iEAAY,KAEhB,EAAA;IACU,MAAA,WAAA,GAAc,WAAY,OAAiC,CAAA,QAAA,CAAA;IAC3D,MAAA,QAAA,GAAW,WAAe,GAAA,OAAA,CAAiC,QAAW,GAAA,OAAA,CAAA;IAC5E,MAAM,IAAO,GAAA,WAAA,GAAc,OAAkC,GAAA;QAAE,UAAU,OAAQ;IAAA,CAAA,CAAA;IAEjF,IAAI,CAAC,SAAA,IAAa,kOAAM,CAAA,GAAA,CAAI,QAAQ,CACpC,EAAA;QACW,OAAA,kOAAA,CAAM,GAAA,CAAI,QAAQ,CAAA,CAAA;IAAA,CAC7B;IAEM,MAAA,OAAA,GAAU,IAAI,kQAAQ,CAAA;QAAE,QAAQ,iBAAkB,CAAA,IAAI;IAAA,CAAG,CAAA,CAAA;IAEvD,OAAA,CAAA,EAAA,CAAG,WAAW,MACtB;QACQ,IAAA,kOAAA,CAAM,GAAI,CAAA,QAAQ,CACtB,EAAA;YACI,kOAAA,CAAM,MAAA,CAAO,QAAQ,CAAA,CAAA;QAAA,CACzB;IAAA,CACH,CAAA,CAAA;IAED,IAAI,CAAC,SACL,EAAA;QACU,kOAAA,CAAA,GAAA,CAAI,UAAU,OAAO,CAAA,CAAA;IAAA,CAC/B;IAEO,OAAA,OAAA,CAAA;AACX,CAAA;AAWgB,SAAA,WAAA,CAAY,EAAuB;oBAAA,SAAA,wDAAY,KAC/D,EAAA;IACQ,IAAA,OAAO,OAAO,QAClB,EAAA;QACW,OAAA,kOAAA,CAAM,GAAA,CAAI,EAAE,CAAA,CAAA;IAAA,CACvB,MAAA,IACS,cAAc,yRACvB,EAAA;QACI,OAAO,IAAI,kQAAA,CAAQ;YAAE,MAAA,EAAQ;QAAA,CAAI,CAAA,CAAA;IAAA,CACrC;IAGO,OAAA,iBAAA,CAAkB,IAAI,SAAS,CAAA,CAAA;AAC1C,CAAA;AAEA,kQAAA,CAAQ,IAAO,GAAA,WAAA,CAAA;AACf,yRAAA,CAAc,IAAO,GAAA,iBAAA","debugId":null}},
    {"offset": {"line": 1701, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/init.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/init.ts"],"sourcesContent":["import { extensions } from '../extensions/Extensions';\nimport { AlphaMask } from './mask/alpha/AlphaMask';\nimport { ColorMask } from './mask/color/ColorMask';\nimport { StencilMask } from './mask/stencil/StencilMask';\nimport { BufferImageSource } from './renderers/shared/texture/sources/BufferImageSource';\nimport { CanvasSource } from './renderers/shared/texture/sources/CanvasSource';\nimport { ImageSource } from './renderers/shared/texture/sources/ImageSource';\nimport { VideoSource } from './renderers/shared/texture/sources/VideoSource';\nimport './renderers/shared/texture/utils/textureFrom';\nimport './mask/MaskEffectManager';\n\nextensions.add(AlphaMask, ColorMask, StencilMask, VideoSource, ImageSource, CanvasSource, BufferImageSource);\n\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAWA,uOAAA,CAAW,GAAA,CAAI,qPAAW,EAAA,qPAAA,EAAW,2PAAA,EAAa,qRAAa,EAAA,qRAAA,EAAa,uRAAA,EAAc,iSAAiB,CAAA","debugId":null}},
    {"offset": {"line": 1727, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gl/const.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gl/const.ts"],"sourcesContent":["/**\n * Constants used by the renderer for clearing the screen or render textures.\n * @category rendering\n * @advanced\n */\nexport enum CLEAR\n{\n    /** No clear operation. */\n    NONE = 0,\n    /** Clear the color buffer. */\n    COLOR = 16384,\n    /** Clear the stencil buffer. */\n    STENCIL = 1024,\n    /** Clear the depth buffer. */\n    DEPTH = 256,\n\n    /** Clear the color and depth buffers. */\n    COLOR_DEPTH = COLOR | DEPTH,\n    /** Clear the color and stencil buffers. */\n    COLOR_STENCIL = COLOR | STENCIL,\n    /** Clear the depth and stencil buffers. */\n    DEPTH_STENCIL = DEPTH | STENCIL,\n    /** Clear the color, depth, and stencil buffers. */\n    ALL = COLOR | DEPTH | STENCIL,\n\n}\n\n/**\n * Used for clearing render textures. true is the same as `ALL` false is the same as `NONE`\n * @category rendering\n * @advanced\n */\nexport type CLEAR_OR_BOOL = CLEAR | boolean;\n"],"names":["CLEAR"],"mappings":";;;;;AAKY,IAAA,KAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,MAAL,KAAA;IAGHA,MAAAA,CAAAA,MAAAA,CAAA,OAAA,GAAO,CAAP,CAAA,GAAA,MAAA,CAAA;IAEAA,MAAAA,CAAAA,MAAAA,CAAA,QAAA,GAAQ,KAAR,CAAA,GAAA,OAAA,CAAA;IAEAA,MAAAA,CAAAA,MAAAA,CAAA,UAAA,GAAU,IAAV,CAAA,GAAA,SAAA,CAAA;IAEAA,MAAAA,CAAAA,MAAAA,CAAA,QAAA,GAAQ,GAAR,CAAA,GAAA,OAAA,CAAA;IAGAA,MAAAA,CAAAA,MAAAA,CAAA,cAAA,GAAc,KAAd,CAAA,GAAA,aAAA,CAAA;IAEAA,MAAAA,CAAAA,MAAAA,CAAA,gBAAA,GAAgB,KAAhB,CAAA,GAAA,eAAA,CAAA;IAEAA,MAAAA,CAAAA,MAAAA,CAAA,gBAAA,GAAgB,IAAhB,CAAA,GAAA,eAAA,CAAA;IAEAA,MAAAA,CAAAA,MAAAA,CAAA,MAAA,GAAM,KAAN,CAAA,GAAA,KAAA,CAAA;IAlBQA,OAAAA,MAAAA,CAAAA;AAAA,CAAA,EAAA,KAAA,IAAA,CAAA,CAAA","debugId":null}},
    {"offset": {"line": 1749, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/system/SystemRunner.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/system/SystemRunner.ts"],"sourcesContent":["/**\n * SystemRunner is used internally by the renderers as an efficient way for systems to\n * be notified about what the renderer is up to during the rendering phase.\n *\n * ```ts\n * import { SystemRunner } from 'pixi.js';\n *\n * const myObject = {\n *     loaded: new SystemRunner('loaded')\n * }\n *\n * const listener = {\n *     loaded: function(){\n *         // thin\n *     }\n * }\n *\n * myObject.loaded.add(listener);\n *\n * myObject.loaded.emit();\n * ```\n *\n * Or for handling calling the same function on many items\n * ```ts\n * import { SystemRunner } from 'pixi.js';\n *\n * const myGame = {\n *     update: new SystemRunner('update')\n * }\n *\n * const gameObject = {\n *     update: function(time){\n *         // update my gamey state\n *     }\n * }\n *\n * myGame.update.add(gameObject);\n *\n * myGame.update.emit(time);\n * ```\n * @category rendering\n * @internal\n */\nexport class SystemRunner\n{\n    public items: any[];\n    private _name: string;\n\n    /**\n     * @param name - The function name that will be executed on the listeners added to this Runner.\n     */\n    constructor(name: string)\n    {\n        this.items = [];\n        this._name = name;\n    }\n\n    /* jsdoc/check-param-names */\n    /**\n     * Dispatch/Broadcast Runner to all listeners added to the queue.\n     * @param {...any} params - (optional) parameters to pass to each listener\n     */\n    /* jsdoc/check-param-names */\n    public emit(a0?: unknown, a1?: unknown, a2?: unknown, a3?: unknown,\n        a4?: unknown, a5?: unknown, a6?: unknown, a7?: unknown): this\n    {\n        const { name, items } = this;\n\n        for (let i = 0, len = items.length; i < len; i++)\n        {\n            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add a listener to the Runner\n     *\n     * Runners do not need to have scope or functions passed to them.\n     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n     * as the name provided to the Runner when it was created.\n     *\n     * Eg A listener passed to this Runner will require a 'complete' function.\n     *\n     * ```ts\n     * import { Runner } from 'pixi.js';\n     *\n     * const complete = new Runner('complete');\n     * ```\n     *\n     * The scope used will be the object itself.\n     * @param {any} item - The object that will be listening.\n     */\n    public add(item: unknown): this\n    {\n        if ((item as any)[this._name])\n        {\n            this.remove(item);\n            this.items.push(item);\n        }\n\n        return this;\n    }\n\n    /**\n     * Remove a single listener from the dispatch queue.\n     * @param {any} item - The listener that you would like to remove.\n     */\n    public remove(item: unknown): this\n    {\n        const index = this.items.indexOf(item);\n\n        if (index !== -1)\n        {\n            this.items.splice(index, 1);\n        }\n\n        return this;\n    }\n\n    /**\n     * Check to see if the listener is already in the Runner\n     * @param {any} item - The listener that you would like to check.\n     */\n    public contains(item: unknown): boolean\n    {\n        return this.items.indexOf(item) !== -1;\n    }\n\n    /** Remove all listeners from the Runner */\n    public removeAll(): this\n    {\n        this.items.length = 0;\n\n        return this;\n    }\n\n    /** Remove all references, don't use after this. */\n    public destroy(): void\n    {\n        this.removeAll();\n        this.items = null;\n        this._name = null;\n    }\n\n    /**\n     * `true` if there are no this Runner contains no listeners\n     * @readonly\n     */\n    public get empty(): boolean\n    {\n        return this.items.length === 0;\n    }\n\n    /**\n     * The name of the runner.\n     * @readonly\n     */\n    public get name(): string\n    {\n        return this._name;\n    }\n}\n"],"names":[],"mappings":";;;;;AA2CO,MAAM,YACb,CAAA;IAWI,2BAAA,GAAA;;;GAAA,GAAA,2BAAA,GAQO,IAAA,CAAK,EAAA,EAAc,EAAc,EAAA,EAAA,EAAc,EAAA,EAClD,EAAc,EAAA,EAAA,EAAc,EAAA,EAAc,EAC9C,EAAA;QACU,MAAA,EAAE,IAAM,EAAA,KAAA,EAAU,GAAA,IAAA,CAAA;QAExB,IAAA,IAAS,IAAI,CAAG,EAAA,GAAA,GAAM,MAAM,MAAQ,EAAA,CAAA,GAAI,KAAK,CAC7C,EAAA,CAAA;YACU,KAAA,CAAA,CAAC,CAAE,CAAA,IAAI,CAAE,CAAA,EAAA,EAAI,EAAI,EAAA,EAAA,EAAI,EAAI,EAAA,EAAA,EAAI,EAAI,EAAA,EAAA,EAAI,EAAE,CAAA,CAAA;QAAA,CACjD;QAEO,OAAA,IAAA,CAAA;IAAA,CACX;IAAA;;;;;;;;;;;;;;;;;GAAA,GAoBO,IAAI,IACX,EAAA;QACS,IAAA,IAAA,CAAa,IAAK,CAAA,KAAK,CAC5B,EAAA;YACI,IAAA,CAAK,MAAA,CAAO,IAAI,CAAA,CAAA;YACX,IAAA,CAAA,KAAA,CAAM,IAAA,CAAK,IAAI,CAAA,CAAA;QAAA,CACxB;QAEO,OAAA,IAAA,CAAA;IAAA,CACX;IAAA;;;GAAA,GAMO,OAAO,IACd,EAAA;QACI,MAAM,KAAQ,GAAA,IAAA,CAAK,KAAM,CAAA,OAAA,CAAQ,IAAI,CAAA,CAAA;QAErC,IAAI,UAAU,CACd,CAAA,EAAA;YACS,IAAA,CAAA,KAAA,CAAM,MAAO,CAAA,KAAA,EAAO,CAAC,CAAA,CAAA;QAAA,CAC9B;QAEO,OAAA,IAAA,CAAA;IAAA,CACX;IAAA;;;GAAA,GAMO,SAAS,IAChB,EAAA;QACI,OAAO,IAAK,CAAA,KAAA,CAAM,OAAQ,CAAA,IAAI,CAAM,KAAA,CAAA,CAAA,CAAA;IAAA,CACxC;IAAA,yCAAA,GAGO,SACP,GAAA;QACI,IAAA,CAAK,KAAA,CAAM,MAAS,GAAA,CAAA,CAAA;QAEb,OAAA,IAAA,CAAA;IAAA,CACX;IAAA,iDAAA,GAGO,OACP,GAAA;QACI,IAAA,CAAK,SAAU,EAAA,CAAA;QACf,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAA;QACb,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAA;IAAA,CACjB;IAAA;;;GAAA,GAMA,IAAW,KACX,GAAA;QACW,OAAA,IAAA,CAAK,KAAA,CAAM,MAAW,KAAA,CAAA,CAAA;IAAA,CACjC;IAAA;;;GAAA,GAMA,IAAW,IACX,GAAA;QACI,OAAO,IAAK,CAAA,KAAA,CAAA;IAAA,CAChB;IAtHJ;;GAAA,GAOI,YAAY,IACZ,CAAA;QACI,IAAA,CAAK,KAAA,GAAQ,EAAC,CAAA;QACd,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAA;IAAA,CACjB;AA4GJ","debugId":null}},
    {"offset": {"line": 1839, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/system/AbstractRenderer.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/system/AbstractRenderer.ts"],"sourcesContent":["import { Color } from '../../../../color/Color';\nimport { loadEnvironmentExtensions } from '../../../../environment/autoDetectEnvironment';\nimport { Container } from '../../../../scene/container/Container';\nimport { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { GlobalResourceRegistry } from '../../../../utils/pool/GlobalResourceRegistry';\nimport { EventEmitter } from '../../../../utils/utils';\nimport { CLEAR } from '../../gl/const';\nimport { SystemRunner } from './SystemRunner';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { Renderer } from '../../types';\nimport type { BackgroundSystem } from '../background/BackgroundSystem';\nimport type { GenerateTextureOptions, GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport type { PipeConstructor } from '../instructions/RenderPipe';\nimport type { RenderSurface } from '../renderTarget/RenderTargetSystem';\nimport type { Texture } from '../texture/Texture';\nimport type { ViewSystem, ViewSystemDestroyOptions } from '../view/ViewSystem';\nimport type { SharedRendererOptions } from './SharedSystems';\nimport type { System, SystemConstructor } from './System';\n\n/**\n * The configuration for the renderer.\n * This is used to define the systems and render pipes that will be used by the renderer.\n * @category rendering\n * @advanced\n */\nexport interface RendererConfig\n{\n    type: number;\n    name: string;\n    runners?: string[];\n    systems: {name: string, value: SystemConstructor}[];\n    renderPipes: {name: string, value: PipeConstructor}[];\n    renderPipeAdaptors: {name: string, value: any}[];\n}\n\n/**\n * The options for rendering a view.\n * @category rendering\n * @standard\n */\nexport interface RenderOptions extends ClearOptions\n{\n    /** The container to render. */\n    container: Container;\n    /** the transform to apply to the container. */\n    transform?: Matrix;\n}\n\n/**\n * The options for clearing the render target.\n * @category rendering\n * @advanced\n */\nexport interface ClearOptions\n{\n    /**\n     * The render target to render. if this target is a canvas and  you are using the WebGL renderer,\n     * please ensure you have set `multiView` to `true` on renderer.\n     */\n    target?: RenderSurface;\n    /** The color to clear with. */\n    clearColor?: ColorSource;\n    /** The clear mode to use. */\n    clear?: CLEAR_OR_BOOL\n}\n\n/**\n * Options for destroying the renderer.\n * This can be a boolean or an object.\n * @category rendering\n * @standard\n */\nexport type RendererDestroyOptions = TypeOrBool<ViewSystemDestroyOptions & {\n    /** Whether to clean up global resource pools/caches */\n    releaseGlobalResources?: boolean;\n}>;\n\nconst defaultRunners = [\n    'init',\n    'destroy',\n    'contextChange',\n    'resolutionChange',\n    'resetState',\n    'renderEnd',\n    'renderStart',\n    'render',\n    'update',\n    'postrender',\n    'prerender'\n] as const;\n\ntype DefaultRunners = typeof defaultRunners[number];\ntype Runners = {[key in DefaultRunners]: SystemRunner} & {\n    [K: ({} & string) | ({} & symbol)]: SystemRunner;\n};\n\n/* eslint-disable max-len */\n/**\n * The base class for a PixiJS Renderer. It contains the shared logic for all renderers.\n *\n * You should not use this class directly, but instead use {@link WebGLRenderer}\n * or {@link WebGPURenderer}.\n * Alternatively, you can also use {@link autoDetectRenderer} if you want us to\n * determine the best renderer for you.\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a renderer:\n *\n *\n * | Generic Systems                      | Systems that manage functionality that all renderer types share               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link ViewSystem}              | This manages the main view of the renderer usually a Canvas              |\n * | {@link BackgroundSystem}        | This manages the main views background color and alpha                   |\n * | {@link EventSystem}           | This manages UI events.                                                       |\n * | {@link AccessibilitySystem} | This manages accessibility features. Requires `import 'pixi.js/accessibility'`|\n *\n * | Core Systems                   | Provide an optimised, easy to use API to work with WebGL/WebGPU               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link GlobalUniformSystem} | This manages shaders, programs that run on the GPU to calculate 'em pixels.   |\n * | {@link TextureGCSystem}     | This will automatically remove textures from the GPU if they are not used.    |\n *\n * | PixiJS High-Level Systems            | Set of specific systems designed to work with PixiJS objects                  |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link HelloSystem}               | Says hello, buy printing out the pixi version into the console log (along with the renderer type)       |\n * | {@link GenerateTextureSystem} | This adds the ability to generate textures from any Container       |\n * | {@link FilterSystem}          | This manages the filtering pipeline for post-processing effects.             |\n * | {@link PrepareSystem}               | This manages uploading assets to the GPU. Requires `import 'pixi.js/prepare'`|\n * | {@link ExtractSystem}               | This extracts image data from display objects.                               |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @abstract\n * @category rendering\n * @advanced\n * @property {HelloSystem} hello - HelloSystem instance.\n * @property {TextureGCSystem} textureGC - TextureGCSystem instance.\n * @property {FilterSystem} filter - FilterSystem instance.\n * @property {GlobalUniformSystem} globalUniforms - GlobalUniformSystem instance.\n * @property {TextureSystem} texture - TextureSystem instance.\n * @property {EventSystem} events - EventSystem instance.\n * @property {ExtractSystem} extract - ExtractSystem instance. Requires `import 'pixi.js/extract'`.\n * @property {PrepareSystem} prepare - PrepareSystem instance. Requires `import 'pixi.js/prepare'`.\n * @property {AccessibilitySystem} accessibility - AccessibilitySystem instance. Requires `import 'pixi.js/accessibility'`.\n */\nexport class AbstractRenderer<\n    PIPES, OPTIONS extends SharedRendererOptions, CANVAS extends ICanvas = HTMLCanvasElement\n> extends EventEmitter<{resize: [screenWidth: number, screenHeight: number, resolution: number]}>\n{\n    /** The default options for the renderer. */\n    public static defaultOptions = {\n        /**\n         * Default resolution / device pixel ratio of the renderer.\n         * @default 1\n         */\n        resolution: 1,\n        /**\n         * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n         * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n         * performance issues when using WebGL.\n         *\n         * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n         * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n         * driver version blacklisted by the\n         * browser.\n         *\n         * If your application requires high performance rendering, you may wish to set this to false.\n         * We recommend one of two options if you decide to set this flag to false:\n         *\n         * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n         *    not supported.\n         *\n         * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n         *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n         *    device & browser combination does not support high performance WebGL.\n         *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n         * @default false\n         */\n        failIfMajorPerformanceCaveat: false,\n        /**\n         * Should round pixels be forced when rendering?\n         * @default false\n         */\n        roundPixels: false\n    };\n\n    /** @internal */\n    public readonly type: number;\n    /** The name of the renderer. */\n    public readonly name: string;\n\n    /** @internal */\n    public readonly uid = uid('renderer');\n\n    /** @internal */\n    public _roundPixels: 0 | 1;\n\n    /** @internal */\n    public readonly runners: Runners = Object.create(null) as Runners;\n    /** @internal */\n    public readonly renderPipes = Object.create(null) as PIPES;\n    /** The view system manages the main canvas that is attached to the DOM */\n    public view!: ViewSystem;\n    /** The background system manages the background color and alpha of the main view. */\n    public background: BackgroundSystem;\n    /** System that manages the generation of textures from the renderer */\n    public textureGenerator: GenerateTextureSystem;\n\n    protected _initOptions: OPTIONS = {} as OPTIONS;\n    protected config: RendererConfig;\n\n    private _systemsHash: Record<string, System> = Object.create(null);\n    private _lastObjectRendered: Container;\n\n    /**\n     * Set up a system with a collection of SystemClasses and runners.\n     * Systems are attached dynamically to this class when added.\n     * @param config - the config for the system manager\n     */\n    constructor(config: RendererConfig)\n    {\n        super();\n        this.type = config.type;\n        this.name = config.name;\n        this.config = config;\n\n        const combinedRunners = [...defaultRunners, ...(this.config.runners ?? [])];\n\n        this._addRunners(...combinedRunners);\n        // Validation check that this environment support `new Function`\n        this._unsafeEvalCheck();\n    }\n\n    /**\n     * Initialize the renderer.\n     * @param options - The options to use to create the renderer.\n     */\n    public async init(options: Partial<OPTIONS> = {})\n    {\n        const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n\n        await loadEnvironmentExtensions(skip);\n\n        this._addSystems(this.config.systems);\n        this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n\n        // loop through all systems...\n        for (const systemName in this._systemsHash)\n        {\n            const system = this._systemsHash[systemName];\n\n            const defaultSystemOptions = (system.constructor as any).defaultOptions;\n\n            options = { ...defaultSystemOptions, ...options };\n        }\n\n        options = { ...AbstractRenderer.defaultOptions, ...options };\n        this._roundPixels = options.roundPixels ? 1 : 0;\n\n        // await emits..\n        for (let i = 0; i < this.runners.init.items.length; i++)\n        {\n            await this.runners.init.items[i].init(options);\n        }\n\n        // store options\n        this._initOptions = options as OPTIONS;\n    }\n\n    /**\n     * Renders the object to its view.\n     * @param options - The options to render with.\n     * @param options.container - The container to render.\n     * @param [options.target] - The target to render to.\n     */\n    public render(options: RenderOptions | Container): void;\n    /** @deprecated since 8.0.0 */\n    public render(container: Container, options: {renderTexture: any}): void;\n    public render(args: RenderOptions | Container, deprecated?: {renderTexture: any}): void\n    {\n        let options = args;\n\n        if (options instanceof Container)\n        {\n            options = { container: options };\n\n            if (deprecated)\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'passing a second argument is deprecated, please use render options instead');\n                // #endif\n\n                options.target = deprecated.renderTexture;\n            }\n        }\n\n        options.target ||= this.view.renderTarget;\n\n        // TODO: we should eventually fix events so that it can handle multiple canvas elements\n        if (options.target === this.view.renderTarget)\n        {\n            // TODO get rid of this\n            this._lastObjectRendered = options.container;\n\n            options.clearColor ??= this.background.colorRgba;\n            options.clear ??= this.background.clearBeforeRender;\n        }\n\n        if (options.clearColor)\n        {\n            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n\n            options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();\n        }\n\n        if (!options.transform)\n        {\n            options.container.updateLocalTransform();\n            options.transform = options.container.localTransform;\n        }\n\n        // Check if the container is visible before proceeding with rendering\n        if (!options.container.visible)\n        {\n            return;\n        }\n\n        // lets ensure this object is a render group so we can render it!\n        // the renderer only likes to render - render groups.\n        options.container.enableRenderGroup();\n\n        this.runners.prerender.emit(options);\n        this.runners.renderStart.emit(options);\n        this.runners.render.emit(options);\n        this.runners.renderEnd.emit(options);\n        this.runners.postrender.emit(options);\n    }\n\n    /**\n     * Resizes the WebGL view to the specified width and height.\n     * @param desiredScreenWidth - The desired width of the screen.\n     * @param desiredScreenHeight - The desired height of the screen.\n     * @param resolution - The resolution / device pixel ratio of the renderer.\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution?: number): void\n    {\n        const previousResolution = this.view.resolution;\n\n        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n        this.emit('resize', this.view.screen.width, this.view.screen.height, this.view.resolution);\n        if (resolution !== undefined && resolution !== previousResolution)\n        {\n            this.runners.resolutionChange.emit(resolution);\n        }\n    }\n\n    /**\n     * Clears the render target.\n     * @param options - The options to use when clearing the render target.\n     * @param options.target - The render target to clear.\n     * @param options.clearColor - The color to clear with.\n     * @param options.clear - The clear mode to use.\n     * @advanced\n     */\n    public clear(options: ClearOptions = {}): void\n    {\n        // override!\n        const renderer = this as unknown as Renderer;\n\n        options.target ||= renderer.renderTarget.renderTarget;\n        options.clearColor ||= this.background.colorRgba;\n        options.clear ??= CLEAR.ALL;\n\n        const { clear, clearColor, target } = options;\n\n        Color.shared.setValue(clearColor ?? this.background.colorRgba);\n\n        renderer.renderTarget.clear(target, clear, Color.shared.toArray() as RgbaArray);\n    }\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.view.resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.view.resolution = value;\n        this.runners.resolutionChange.emit(value);\n    }\n\n    /**\n     * Same as view.width, actual number of pixels in the canvas by horizontal.\n     * @type {number}\n     * @readonly\n     * @default 800\n     */\n    get width(): number\n    {\n        return this.view.texture.frame.width;\n    }\n\n    /**\n     * Same as view.height, actual number of pixels in the canvas by vertical.\n     * @default 600\n     */\n    get height(): number\n    {\n        return this.view.texture.frame.height;\n    }\n\n    // NOTE: this was `view` in v7\n    /**\n     * The canvas element that everything is drawn to.\n     * @type {environment.ICanvas}\n     */\n    get canvas(): CANVAS\n    {\n        return this.view.canvas as CANVAS;\n    }\n\n    /**\n     * the last object rendered by the renderer. Useful for other plugins like interaction managers\n     * @readonly\n     */\n    get lastObjectRendered(): Container\n    {\n        return this._lastObjectRendered;\n    }\n\n    /**\n     * Flag if we are rendering to the screen vs renderTexture\n     * @readonly\n     * @default true\n     */\n    get renderingToScreen(): boolean\n    {\n        const renderer = this as unknown as Renderer;\n\n        return renderer.renderTarget.renderingToScreen;\n    }\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    get screen(): Rectangle\n    {\n        return this.view.screen;\n    }\n\n    /**\n     * Create a bunch of runners based of a collection of ids\n     * @param runnerIds - the runner ids to add\n     */\n    private _addRunners(...runnerIds: string[]): void\n    {\n        runnerIds.forEach((runnerId) =>\n        {\n            this.runners[runnerId] = new SystemRunner(runnerId);\n        });\n    }\n\n    private _addSystems(systems: RendererConfig['systems']): void\n    {\n        let i: keyof typeof systems;\n\n        for (i in systems)\n        {\n            const val = systems[i];\n\n            this._addSystem(val.value, val.name);\n        }\n    }\n\n    /**\n     * Add a new system to the renderer.\n     * @param ClassRef - Class reference\n     * @param name - Property name for system, if not specified\n     *        will use a static `name` property on the class itself. This\n     *        name will be assigned as s property on the Renderer so make\n     *        sure it doesn't collide with properties on Renderer.\n     * @returns Return instance of renderer\n     */\n    private _addSystem(ClassRef: SystemConstructor, name: string): this\n    {\n        const system = new ClassRef(this as unknown as Renderer);\n\n        if ((this as any)[name])\n        {\n            throw new Error(`Whoops! The name \"${name}\" is already in use`);\n        }\n\n        (this as any)[name] = system;\n\n        this._systemsHash[name] = system;\n\n        for (const i in this.runners)\n        {\n            this.runners[i].add(system);\n        }\n\n        return this;\n    }\n\n    private _addPipes(pipes: RendererConfig['renderPipes'], pipeAdaptors: RendererConfig['renderPipeAdaptors']): void\n    {\n        const adaptors = pipeAdaptors.reduce((acc, adaptor) =>\n        {\n            acc[adaptor.name] = adaptor.value;\n\n            return acc;\n        }, {} as Record<string, any>);\n\n        pipes.forEach((pipe) =>\n        {\n            const PipeClass = pipe.value;\n            const name = pipe.name;\n\n            const Adaptor = adaptors[name];\n\n            // sorry typescript..\n            (this.renderPipes as any)[name] = new PipeClass(\n                this as unknown as Renderer,\n                Adaptor ? new Adaptor() : null\n            );\n\n            this.runners.destroy.add((this.renderPipes as any)[name]);\n        });\n    }\n\n    public destroy(options: RendererDestroyOptions = false): void\n    {\n        this.runners.destroy.items.reverse();\n        this.runners.destroy.emit(options);\n\n        // destroy all runners\n        Object.values(this.runners).forEach((runner) =>\n        {\n            runner.destroy();\n        });\n\n        if (options === true || (typeof options === 'object' && options.releaseGlobalResources))\n        {\n            GlobalResourceRegistry.release();\n        }\n\n        this._systemsHash = null;\n\n        // destroy all pipes\n        (this.renderPipes as null) = null;\n    }\n\n    /**\n     * Generate a texture from a container.\n     * @param options - options or container target to use when generating the texture\n     * @returns a texture\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): Texture\n    {\n        return this.textureGenerator.generateTexture(options);\n    }\n\n    /**\n     * Whether the renderer will round coordinates to whole pixels when rendering.\n     * Can be overridden on a per scene item basis.\n     */\n    get roundPixels(): boolean\n    {\n        return !!this._roundPixels;\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     * @ignore\n     */\n    public _unsafeEvalCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n               + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n    /**\n     * Resets the rendering state of the renderer.\n     * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state\n     * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi\n     * render will reset all internal caches and ensure it executes correctly.\n     *\n     * This is particularly useful when combining PixiJS with other rendering engines like Three.js:\n     * ```js\n     * // Reset Three.js state\n     * threeRenderer.resetState();\n     *\n     * // Render a Three.js scene\n     * threeRenderer.render(threeScene, threeCamera);\n     *\n     * // Reset PixiJS state since Three.js modified the WebGL context\n     * pixiRenderer.resetState();\n     *\n     * // Now render Pixi content\n     * pixiRenderer.render(pixiScene);\n     * ```\n     * @advanced\n     */\n    public resetState(): void\n    {\n        this.runners.resetState.emit();\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2196, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/autoDetectRenderer.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/autoDetectRenderer.ts"],"sourcesContent":["import { isWebGLSupported } from '../../utils/browser/isWebGLSupported';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer';\n\nimport type { WebGLOptions } from './gl/WebGLRenderer';\nimport type { WebGPUOptions } from './gpu/WebGPURenderer';\nimport type { Renderer, RendererOptions } from './types';\n\n/**\n * Options for {@link autoDetectRenderer}.\n * @category rendering\n * @advanced\n */\nexport interface AutoDetectOptions extends RendererOptions\n{\n    /** The preferred renderer type. WebGPU is recommended as its generally faster than WebGL. */\n    preference?: 'webgl' | 'webgpu'// | 'canvas';\n    /** Optional WebGPUOptions to pass only to WebGPU renderer. */\n    webgpu?: Partial<WebGPUOptions>;\n    /** Optional WebGLOptions to pass only to the WebGL renderer */\n    webgl?: Partial<WebGLOptions>;\n}\n\nconst renderPriority = ['webgl', 'webgpu', 'canvas'];\n\n/**\n * Automatically determines the most appropriate renderer for the current environment.\n *\n * The function will prioritize the WebGL renderer as it is the most tested safe API to use.\n * In the near future as WebGPU becomes more stable and ubiquitous, it will be prioritized over WebGL.\n *\n * The selected renderer's code is then dynamically imported to optimize\n * performance and minimize the initial bundle size.\n *\n * To maximize the benefits of dynamic imports, it's recommended to use a modern bundler\n * that supports code splitting. This will place the renderer code in a separate chunk,\n * which is loaded only when needed.\n * @example\n *\n * // create a renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   antialias: true,\n * });\n *\n * // custom for each renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   webgpu:{\n *     antialias: true,\n *     backgroundColor: 'red'\n *   },\n *   webgl:{\n *     antialias: true,\n *     backgroundColor: 'green'\n *   }\n *  });\n * @param options - A partial configuration object based on the `AutoDetectOptions` type.\n * @returns A Promise that resolves to an instance of the selected renderer.\n * @category rendering\n * @standard\n */\nexport async function autoDetectRenderer(options: Partial<AutoDetectOptions>): Promise<Renderer>\n{\n    let preferredOrder: string[] = [];\n\n    if (options.preference)\n    {\n        preferredOrder.push(options.preference);\n\n        renderPriority.forEach((item) =>\n        {\n            if (item !== options.preference)\n            {\n                preferredOrder.push(item);\n            }\n        });\n    }\n    else\n    {\n        preferredOrder = renderPriority.slice();\n    }\n\n    let RendererClass: new () => Renderer;\n    let finalOptions: Partial<AutoDetectOptions> = {};\n\n    for (let i = 0; i < preferredOrder.length; i++)\n    {\n        const rendererType = preferredOrder[i];\n\n        if (rendererType === 'webgpu' && (await isWebGPUSupported()))\n        {\n            const { WebGPURenderer } = await import('./gpu/WebGPURenderer');\n\n            RendererClass = WebGPURenderer;\n\n            finalOptions = { ...options, ...options.webgpu };\n\n            break;\n        }\n        else if (\n            rendererType === 'webgl'\n            && isWebGLSupported(\n                options.failIfMajorPerformanceCaveat\n                    ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n            )\n        )\n        {\n            const { WebGLRenderer } = await import('./gl/WebGLRenderer');\n\n            RendererClass = WebGLRenderer;\n\n            finalOptions = { ...options, ...options.webgl };\n\n            break;\n        }\n        else if (rendererType === 'canvas')\n        {\n            finalOptions = { ...options };\n\n            throw new Error('CanvasRenderer is not yet implemented');\n        }\n    }\n\n    delete finalOptions.webgpu;\n    delete finalOptions.webgl;\n\n    if (!RendererClass)\n    {\n        throw new Error('No available renderer for the current environment');\n    }\n\n    const renderer = new RendererClass();\n\n    await renderer.init(finalOptions);\n\n    return renderer;\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAuBA,MAAM,cAAiB,GAAA;IAAC,OAAS;IAAA,QAAA;IAAU,QAAQ;CAAA,CAAA;AAyCnD,eAAsB,mBAAmB,OACzC,EAAA;IACI,IAAI,iBAA2B,EAAC,CAAA;IAEhC,IAAI,QAAQ,UACZ,EAAA;QACmB,cAAA,CAAA,IAAA,CAAK,QAAQ,UAAU,CAAA,CAAA;QAEvB,cAAA,CAAA,OAAA,CAAQ,CAAC,IACxB,KAAA;YACQ,IAAA,IAAA,KAAS,QAAQ,UACrB,EAAA;gBACI,cAAA,CAAe,IAAA,CAAK,IAAI,CAAA,CAAA;YAAA,CAC5B;QAAA,CACH,CAAA,CAAA;IAAA,CAGL,MAAA;QACI,cAAA,GAAiB,eAAe,KAAM,EAAA,CAAA;IAAA,CAC1C;IAEI,IAAA,aAAA,CAAA;IACJ,IAAI,eAA2C,CAAA,CAAC,CAAA;IAEhD,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,cAAA,CAAe,MAAA,EAAQ,CAC3C,EAAA,CAAA;QACU,MAAA,YAAA,GAAe,cAAA,CAAe,CAAC,CAAA,CAAA;YAe7B,OAAA;QAbR,IAAI,YAAiB,KAAA,QAAA,IAAa,UAAM,2PAAA,EACxC,GAAA;YACI,MAAM,EAAE,cAAA,EAAmB,GAAA,MAAM,OAAO,0BAAsB,CAAA,CAAA;YAE9C,aAAA,GAAA,cAAA,CAAA;YAEhB,YAAA,GAAe;gBAAE,GAAG,OAAS;gBAAA,GAAG,QAAQ,MAAO;YAAA,CAAA,CAAA;YAE/C,MAAA;QAAA,CACJ,MAAA,IAEI,iBAAiB,OACd,QAAA,yPAAA,mDACS,4BACD,yGAAA,mRAAA,CAAiB,cAAe,CAAA,4BAAA,GAG/C;YACI,MAAM,EAAE,aAAA,EAAkB,GAAA,MAAM,OAAO,wBAAoB,CAAA,CAAA;YAE3C,aAAA,GAAA,aAAA,CAAA;YAEhB,YAAA,GAAe;gBAAE,GAAG,OAAS;gBAAA,GAAG,QAAQ,KAAM;YAAA,CAAA,CAAA;YAE9C,MAAA;QAAA,CACJ,MAAA,IACS,iBAAiB,QAC1B,EAAA;YACmB,YAAA,GAAA;gBAAE,GAAG,OAAQ;YAAA,CAAA,CAAA;YAEtB,MAAA,IAAI,MAAM,uCAAuC,CAAA,CAAA;QAAA,CAC3D;IAAA,CACJ;IAEA,OAAO,YAAa,CAAA,MAAA,CAAA;IACpB,OAAO,YAAa,CAAA,KAAA,CAAA;IAEpB,IAAI,CAAC,aACL,EAAA;QACU,MAAA,IAAI,MAAM,mDAAmD,CAAA,CAAA;IAAA,CACvE;IAEM,MAAA,QAAA,GAAW,IAAI,aAAc,EAAA,CAAA;IAE7B,MAAA,QAAA,CAAS,IAAA,CAAK,YAAY,CAAA,CAAA;IAEzB,OAAA,QAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 2267, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gpu/shader/BindGroup.ts"],"sourcesContent":["import type { BindResource } from './BindResource';\n\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @category rendering\n * @advanced\n */\nexport class BindGroup\n{\n    /** The resources that are bound together for use by a shader. */\n    public resources: Record<string, BindResource> = Object.create(null);\n    /**\n     * a key used internally to match it up to a WebGPU Bindgroup\n     * @internal\n     */\n    public _key: string;\n    private _dirty = true;\n\n    /**\n     * Create a new instance eof the Bind Group.\n     * @param resources - The resources that are bound together for use by a shader.\n     */\n    constructor(resources?: Record<string, BindResource>)\n    {\n        let index = 0;\n\n        for (const i in resources)\n        {\n            const resource: BindResource = resources[i];\n\n            this.setResource(resource, index++);\n        }\n\n        this._updateKey();\n    }\n\n    /**\n     * Updates the key if its flagged as dirty. This is used internally to\n     * match this bind group to a WebGPU BindGroup.\n     * @internal\n     */\n    public _updateKey(): void\n    {\n        if (!this._dirty) return;\n\n        this._dirty = false;\n\n        const keyParts = [];\n        let index = 0;\n\n        // TODO - lets use big ints instead of strings...\n        for (const i in this.resources)\n        {\n            // TODO make this consistent...\n            keyParts[index++] = this.resources[i]._resourceId;\n        }\n\n        this._key = keyParts.join('|');\n    }\n\n    /**\n     * Set a resource at a given index. this function will\n     * ensure that listeners will be removed from the current resource\n     * and added to the new resource.\n     * @param resource - The resource to set.\n     * @param index - The index to set the resource at.\n     */\n    public setResource(resource: BindResource, index: number): void\n    {\n        const currentResource = this.resources[index];\n\n        if (resource === currentResource) return;\n\n        if (currentResource)\n        {\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        resource.on?.('change', this.onResourceChange, this);\n\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n\n    /**\n     * Returns the resource at the current specified index.\n     * @param index - The index of the resource to get.\n     * @returns - The resource at the specified index.\n     */\n    public getResource(index: number): BindResource\n    {\n        return this.resources[index];\n    }\n\n    /**\n     * Used internally to 'touch' each resource, to ensure that the GC\n     * knows that all resources in this bind group are still being used.\n     * @param tick - The current tick.\n     * @internal\n     */\n    public _touch(tick: number)\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            resources[i]._touched = tick;\n        }\n    }\n\n    /** Destroys this bind group and removes all listeners. */\n    public destroy()\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            const resource = resources[i];\n\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        this.resources = null;\n    }\n\n    protected onResourceChange(resource: BindResource)\n    {\n        this._dirty = true;\n\n        // check if a resource has been destroyed, if it has then we need to destroy this bind group\n        // using this bind group with a destroyed resource will cause the renderer to explode :)\n        if (resource.destroyed)\n        {\n            // free up the resource\n            const resources = this.resources;\n\n            for (const i in resources)\n            {\n                if (resources[i] === resource)\n                {\n                    resources[i] = null;\n                }\n            }\n        }\n        else\n        {\n            this._updateKey();\n        }\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2365, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/batcher/gpu/getTextureBatchBindGroup.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/batcher/gpu/getTextureBatchBindGroup.ts"],"sourcesContent":["import { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\n\nimport type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\nconst cachedGroups: Record<number, BindGroup> = {};\n\n/**\n * @param textures\n * @param size\n * @param maxTextures\n * @internal\n */\nexport function getTextureBatchBindGroup(textures: TextureSource[], size: number, maxTextures: number)\n{\n    let uid = 2166136261; // FNV-1a 32-bit offset basis\n\n    for (let i = 0; i < size; i++)\n    {\n        uid ^= textures[i].uid;\n        uid = Math.imul(uid, 16777619);\n        uid >>>= 0;\n    }\n\n    return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid, maxTextures);\n}\n\nfunction generateTextureBatchBindGroup(textures: TextureSource[], size: number, key: number, maxTextures: number): BindGroup\n{\n    const bindGroupResources: Record<string, any> = {};\n\n    let bindIndex = 0;\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        const texture = i < size ? textures[i] : Texture.EMPTY.source;\n\n        bindGroupResources[bindIndex++] = texture.source;\n        bindGroupResources[bindIndex++] = texture.style;\n    }\n\n    // pad out with empty textures\n    const bindGroup = new BindGroup(bindGroupResources);\n\n    cachedGroups[key] = bindGroup;\n\n    return bindGroup;\n}\n\n"],"names":[],"mappings":";;;;;;;;;AAKA,MAAM,eAA0C,CAAA,CAAC,CAAA;AAQjC,SAAA,wBAAA,CAAyB,QAA2B,EAAA,IAAA,EAAc,WAClF,EAAA;IACI,IAAI,GAAM,GAAA,UAAA,CAAA;IAEV,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,EAAM,CAC1B,EAAA,CAAA;QACW,GAAA,IAAA,QAAA,CAAS,CAAC,CAAE,CAAA,GAAA,CAAA;QACb,GAAA,GAAA,IAAA,CAAK,IAAK,CAAA,GAAA,EAAK,QAAQ,CAAA,CAAA;QACpB,GAAA,MAAA,CAAA,CAAA;IAAA,CACb;IAEA,OAAO,YAAA,CAAa,GAAG,CAAA,IAAK,8BAA8B,QAAU,EAAA,IAAA,EAAM,KAAK,WAAW,CAAA,CAAA;AAC9F,CAAA;AAEA,SAAS,6BAA8B,CAAA,QAAA,EAA2B,IAAc,EAAA,GAAA,EAAa,WAC7F,EAAA;IACI,MAAM,qBAA0C,CAAA,CAAC,CAAA;IAEjD,IAAI,SAAY,GAAA,CAAA,CAAA;IAEhB,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CACjC,EAAA,CAAA;QACI,MAAM,UAAU,CAAI,GAAA,IAAA,GAAO,QAAA,CAAS,CAAC,CAAA,GAAI,kQAAA,CAAQ,KAAM,CAAA,MAAA,CAAA;QAEpC,kBAAA,CAAA,SAAA,EAAW,CAAA,GAAI,OAAQ,CAAA,MAAA,CAAA;QACvB,kBAAA,CAAA,SAAA,EAAW,CAAA,GAAI,OAAQ,CAAA,KAAA,CAAA;IAAA,CAC9C;IAGM,MAAA,SAAA,GAAY,IAAI,kQAAA,CAAU,kBAAkB,CAAA,CAAA;IAElD,YAAA,CAAa,GAAG,CAAI,GAAA,SAAA,CAAA;IAEb,OAAA,SAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 2402, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/buffer/utils/fastCopy.ts"],"sourcesContent":["/**\n * Copies from one buffer to another.\n * This is an optimised function that will use `Float64Array` window.\n * This means it can copy twice as fast!\n * @param sourceBuffer - the array buffer to copy from\n * @param destinationBuffer - the array buffer to copy to\n * @private\n */\nexport function fastCopy(sourceBuffer: ArrayBuffer, destinationBuffer: ArrayBuffer): void\n{\n    const lengthDouble = (sourceBuffer.byteLength / 8) | 0;\n\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n\n    // Use set for faster copying\n    destinationFloat64View.set(sourceFloat64View);\n\n    // copying over the remaining bytes\n    const remainingBytes = sourceBuffer.byteLength - (lengthDouble * 8);\n\n    if (remainingBytes > 0)\n    {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n\n        // Direct copy for remaining bytes\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n"],"names":[],"mappings":";;;;;AAQgB,SAAA,QAAA,CAAS,YAAA,EAA2B,iBACpD,EAAA;IACU,MAAA,YAAA,GAAgB,YAAa,CAAA,UAAA,GAAa,CAAK,GAAA,CAAA,CAAA;IAErD,MAAM,iBAAoB,GAAA,IAAI,YAAa,CAAA,YAAA,EAAc,GAAG,YAAY,CAAA,CAAA;IACxE,MAAM,sBAAyB,GAAA,IAAI,YAAa,CAAA,iBAAA,EAAmB,GAAG,YAAY,CAAA,CAAA;IAGlF,sBAAA,CAAuB,GAAA,CAAI,iBAAiB,CAAA,CAAA;IAGtC,MAAA,cAAA,GAAiB,YAAa,CAAA,UAAA,GAAc,YAAe,GAAA,CAAA,CAAA;IAEjE,IAAI,iBAAiB,CACrB,EAAA;QACI,MAAM,kBAAkB,IAAI,UAAA,CAAW,YAAc,EAAA,YAAA,GAAe,GAAG,cAAc,CAAA,CAAA;QACrF,MAAM,uBAAuB,IAAI,UAAA,CAAW,iBAAmB,EAAA,YAAA,GAAe,GAAG,cAAc,CAAA,CAAA;QAG/F,oBAAA,CAAqB,GAAA,CAAI,eAAe,CAAA,CAAA;IAAA,CAC5C;AACJ","debugId":null}},
    {"offset": {"line": 2425, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/state/const.ts"],"sourcesContent":["/**\n * Various blend modes supported by Pixi\n * @category filters\n * @standard\n */\nexport type BLEND_MODES = 'inherit'\n| 'normal'\n| 'add'\n| 'multiply'\n| 'screen'\n| 'darken'\n| 'lighten'\n| 'erase'\n| 'color-dodge'\n| 'color-burn'\n| 'linear-burn'\n| 'linear-dodge'\n| 'linear-light'\n| 'hard-light'\n| 'soft-light'\n| 'pin-light'\n| 'difference'\n| 'exclusion'\n| 'overlay'\n// | 'hue'\n| 'saturation'\n| 'color'\n| 'luminosity'\n| 'normal-npm'\n| 'add-npm'\n| 'screen-npm'\n| 'none'\n| 'subtract'\n| 'divide'\n| 'vivid-light'\n| 'hard-mix'\n| 'negation'\n| 'min'\n| 'max';\n\n/**\n * The map of blend modes supported by Pixi\n * @category rendering\n * @advanced\n */\nexport const BLEND_TO_NPM = {\n    normal: 'normal-npm',\n    add: 'add-npm',\n    screen: 'screen-npm',\n};\n\n/**\n * The stencil operation to perform when using the stencil buffer\n * @category rendering\n * @advanced\n */\nexport enum STENCIL_MODES\n{\n    DISABLED = 0,\n    RENDERING_MASK_ADD = 1,\n    MASK_ACTIVE = 2,\n    INVERSE_MASK_ACTIVE = 3,\n    RENDERING_MASK_REMOVE = 4,\n    NONE = 5,\n}\n\n/**\n * The culling mode to use. It can be either `none`, `front` or `back`.\n * @category rendering\n * @advanced\n */\nexport type CULL_MODES = 'none' | 'back' | 'front';\n\n"],"names":["STENCIL_MODES"],"mappings":";;;;;;;AA6CO,MAAM,YAAe,GAAA;IACxB,MAAQ,EAAA,YAAA;IACR,GAAK,EAAA,SAAA;IACL,MAAQ,EAAA,YAAA;AACZ,EAAA;AAOY,IAAA,aAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,cAAL,KAAA;IAEHA,cAAAA,CAAAA,cAAAA,CAAA,WAAA,GAAW,CAAX,CAAA,GAAA,UAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,qBAAA,GAAqB,CAArB,CAAA,GAAA,oBAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,cAAA,GAAc,CAAd,CAAA,GAAA,aAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,sBAAA,GAAsB,CAAtB,CAAA,GAAA,qBAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,wBAAA,GAAwB,CAAxB,CAAA,GAAA,uBAAA,CAAA;IACAA,cAAAA,CAAAA,cAAAA,CAAA,OAAA,GAAO,CAAP,CAAA,GAAA,MAAA,CAAA;IAPQA,OAAAA,cAAAA,CAAAA;AAAA,CAAA,EAAA,aAAA,IAAA,CAAA,CAAA","debugId":null}},
    {"offset": {"line": 2452, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/state/getAdjustedBlendModeBlend.ts"],"sourcesContent":["import { type BLEND_MODES, BLEND_TO_NPM } from './const';\n\nimport type { TextureSource } from '../texture/sources/TextureSource';\n\n/**\n * Adjusts a blend mode for the current alpha mode. Returns the blend mode that works with that format.\n * eg 'normal' blend mode will return 'normal-npm' when rendering with premultiplied alpha.\n * and 'normal' if the texture is already premultiplied (the default)\n * @param blendMode - The blend mode to get the adjusted blend mode for.\n * @param textureSource - The texture to test the format of.\n * @returns - the blend mode that should be used to render this texture correctly based on its alphaMode\n * @internal\n */\nexport function getAdjustedBlendModeBlend(blendMode: BLEND_MODES, textureSource: TextureSource): BLEND_MODES\n{\n    if (textureSource.alphaMode === 'no-premultiply-alpha')\n    {\n        return (BLEND_TO_NPM[blendMode as keyof typeof BLEND_TO_NPM] || blendMode) as BLEND_MODES;\n    }\n\n    return blendMode;\n}\n"],"names":[],"mappings":";;;;;;;AAagB,SAAA,yBAAA,CAA0B,SAAA,EAAwB,aAClE,EAAA;IACQ,IAAA,aAAA,CAAc,SAAA,KAAc,sBAChC,EAAA;QACY,OAAA,mQAAA,CAAa,SAAsC,CAAK,IAAA,SAAA,CAAA;IAAA,CACpE;IAEO,OAAA,SAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 2471, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getTestContext.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\n\nlet context: GlRenderingContext;\n\n/**\n * returns a little WebGL context to use for program inspection.\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext\n{\n    if (!context || context?.isContextLost())\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        context = canvas.getContext('webgl', {}) as GlRenderingContext;\n    }\n\n    return context;\n}\n"],"names":[],"mappings":";;;;;;;AAIA,IAAI,OAAA,CAAA;AAOG,SAAS,cAChB,GAAA;IACI,IAAI,CAAC,OAAA,uDAAW,OAAS,CAAA,aAAA,EACzB,GAAA;QACI,MAAM,MAAS,GAAA,qOAAA,CAAW,GAAI,EAAA,CAAE,YAAa,EAAA,CAAA;QAE7C,OAAA,GAAU,MAAO,CAAA,UAAA,CAAW,OAAS,EAAA,CAAA,CAAE,CAAA,CAAA;IAAA,CAC3C;IAEO,OAAA,OAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 2492, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.ts"],"sourcesContent":["import type { GlRenderingContext } from '../../../renderers/gl/context/GlRenderingContext';\n\nconst fragTemplate = [\n    'precision mediump float;',\n    'void main(void){',\n    'float test = 0.1;',\n    '%forloop%',\n    'gl_FragColor = vec4(0.0);',\n    '}',\n].join('\\n');\n\nfunction generateIfTestSrc(maxIfs: number): string\n{\n    let src = '';\n\n    for (let i = 0; i < maxIfs; ++i)\n    {\n        if (i > 0)\n        {\n            src += '\\nelse ';\n        }\n\n        if (i < maxIfs - 1)\n        {\n            src += `if(test == ${i}.0){}`;\n        }\n    }\n\n    return src;\n}\n\n/**\n * @param maxIfs\n * @param gl\n * @internal\n */\nexport function checkMaxIfStatementsInShader(maxIfs: number, gl: GlRenderingContext): number\n{\n    if (maxIfs === 0)\n    {\n        throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');\n    }\n\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\n\n    try\n    {\n        while (true)\n        {\n            const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n\n            gl.shaderSource(shader, fragmentSrc);\n            gl.compileShader(shader);\n\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n            {\n                maxIfs = (maxIfs / 2) | 0;\n            }\n            else\n            {\n                // valid!\n                break;\n            }\n        }\n    }\n    finally\n    {\n        gl.deleteShader(shader);\n    }\n\n    return maxIfs;\n}\n"],"names":[],"mappings":";;;;;AAEA,MAAM,YAAe,GAAA;IACjB,0BAAA;IACA,kBAAA;IACA,mBAAA;IACA,WAAA;IACA,2BAAA;IACA,GAAA;CACJ,CAAE,IAAA,CAAK,IAAI,CAAA,CAAA;AAEX,SAAS,kBAAkB,MAC3B,EAAA;IACI,IAAI,GAAM,GAAA,EAAA,CAAA;IAEV,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,EAAQ,EAAE,CAC9B,CAAA;QACI,IAAI,IAAI,CACR,EAAA;YACW,GAAA,IAAA,SAAA,CAAA;QAAA,CACX;QAEI,IAAA,CAAA,GAAI,SAAS,CACjB,EAAA;YACI,GAAA,IAAO,qBAAc,CAAC,EAAA,KAAA,CAAA,CAAA;QAAA,CAC1B;IAAA,CACJ;IAEO,OAAA,GAAA,CAAA;AACX,CAAA;AAOgB,SAAA,4BAAA,CAA6B,MAAA,EAAgB,EAC7D,EAAA;IACI,IAAI,WAAW,CACf,EAAA;QACU,MAAA,IAAI,MAAM,+DAA+D,CAAA,CAAA;IAAA,CACnF;IAEA,MAAM,MAAS,GAAA,EAAA,CAAG,YAAa,CAAA,EAAA,CAAG,eAAe,CAAA,CAAA;IAGjD,IAAA;QACI,MAAO,IACP,CAAA;YACI,MAAM,cAAc,YAAa,CAAA,OAAA,CAAQ,aAAe,EAAA,iBAAA,CAAkB,MAAM,CAAC,CAAA,CAAA;YAE9E,EAAA,CAAA,YAAA,CAAa,QAAQ,WAAW,CAAA,CAAA;YACnC,EAAA,CAAG,aAAA,CAAc,MAAM,CAAA,CAAA;YAEvB,IAAI,CAAC,EAAG,CAAA,kBAAA,CAAmB,MAAQ,EAAA,EAAA,CAAG,cAAc,CACpD,EAAA;gBACI,MAAA,GAAU,SAAS,CAAK,GAAA,CAAA,CAAA;YAAA,CAG5B,MAAA;gBAEI,MAAA;YAAA,CACJ;QAAA,CACJ;IAAA,CAEJ,QAAA;QAEI,EAAA,CAAG,YAAA,CAAa,MAAM,CAAA,CAAA;IAAA,CAC1B;IAEO,OAAA,MAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 2544, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/batcher/gl/utils/maxRecommendedTextures.ts"],"sourcesContent":["import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader';\n\nlet maxTexturesPerBatchCache: number | null = null;\n\n/**\n * Returns the maximum number of textures that can be batched. This uses WebGL1's `MAX_TEXTURE_IMAGE_UNITS`.\n * The response for this is that to get this info via WebGPU, we would need to make a context, which\n * would make this function async, and we want to avoid that.\n * @private\n * @deprecated Use `Renderer.limits.maxBatchableTextures` instead.\n * @returns {number} The maximum number of textures that can be batched\n */\nexport function getMaxTexturesPerBatch(): number\n{\n    if (maxTexturesPerBatchCache) return maxTexturesPerBatchCache;\n\n    const gl = getTestContext();\n\n    // step 1: first check max textures the GPU can handle.\n    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n    // step 2: check the maximum number of if statements the shader can have too..\n    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n        maxTexturesPerBatchCache, gl);\n\n    gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n    return maxTexturesPerBatchCache;\n}\n"],"names":[],"mappings":";;;;;;;;;AAGA,IAAI,wBAA0C,GAAA,IAAA,CAAA;AAUvC,SAAS,sBAChB,GAAA;;IACQ,IAAA,wBAAA,EAAiC,OAAA,wBAAA,CAAA;IAErC,MAAM,SAAK,sRAAe,EAAA,CAAA;IAGC,wBAAA,GAAA,EAAA,CAAG,YAAa,CAAA,EAAA,CAAG,uBAAuB,CAAA,CAAA;IAG1C,wBAAA,OAAA,oSAAA,EACvB,wBAAA,EAA0B,EAAA;2BAE3B,YAAA,CAAa,oBAAoB,CAAA,qDAAjC,EAAA,eAAoC,WAAY,EAAA,CAAA;IAE5C,OAAA,wBAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 2569, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/batcher/shared/BatchTextureArray.ts"],"sourcesContent":["import type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\n/**\n * Used by the batcher to build texture batches. Holds list of textures and their respective locations.\n * @category rendering\n * @advanced\n */\nexport class BatchTextureArray\n{\n    /** Inside textures array. */\n    public textures: TextureSource[];\n\n    /** Respective locations for textures. */\n    public ids: Record<number, number> = Object.create(null);\n\n    /** Number of filled elements. */\n    public count: number;\n\n    constructor()\n    {\n        this.textures = [];\n        this.count = 0;\n    }\n\n    /** Clear the textures and their locations. */\n    public clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            const t = this.textures[i];\n\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n\n        this.count = 0;\n    }\n}\n"],"names":[],"mappings":";;;;;AAOO,MAAM,iBACb,CAAA;IAcI,4CAAA,GAGO,KACP,GAAA;QACI,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,CAAK,KAAA,EAAO,CAChC,EAAA,CAAA;YACU,MAAA,CAAA,GAAI,IAAK,CAAA,QAAA,CAAS,CAAC,CAAA,CAAA;YAEpB,IAAA,CAAA,QAAA,CAAS,CAAC,CAAI,GAAA,IAAA,CAAA;YACd,IAAA,CAAA,GAAA,CAAI,CAAE,CAAA,GAAG,CAAI,GAAA,IAAA,CAAA;QAAA,CACtB;QAEA,IAAA,CAAK,KAAQ,GAAA,CAAA,CAAA;IAAA,CACjB;IAlBA,WACA,EAAA;QANA,uCAAA,GAAO,IAAA,CAAA,GAAA,GAAA,aAAA,GAAqC,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;QAOnD,IAAA,CAAK,QAAA,GAAW,EAAC,CAAA;QACjB,IAAA,CAAK,KAAQ,GAAA,CAAA,CAAA;IAAA,CACjB;AAeJ","debugId":null}},
    {"offset": {"line": 2595, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts"],"sourcesContent":["import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { GlobalResourceRegistry } from '../../../utils/pool/GlobalResourceRegistry';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\nimport { BatchTextureArray } from './BatchTextureArray';\n\nimport type { BoundsData } from '../../../scene/container/bounds/Bounds';\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { Topology } from '../../renderers/shared/geometry/const';\nimport type { Geometry, IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\n/**\n * The action types for a batch.\n * @category rendering\n * @advanced\n */\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @category rendering\n * @advanced\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray = new BatchTextureArray();\n\n    public blendMode: BLEND_MODES = 'normal';\n    public topology: Topology = 'triangle-strip';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\n// inlined pool for SPEEEEEEEEEED :D\nconst batchPool: Batch[] = [];\nlet batchPoolIndex = 0;\n\nGlobalResourceRegistry.register({\n    clear: () =>\n    {\n        // check if the first element has a destroy method\n        if (batchPool.length > 0)\n        {\n            for (const item of batchPool)\n            {\n                if (item) item.destroy();\n            }\n        }\n        batchPool.length = 0; // clear the array\n        batchPoolIndex = 0;\n    },\n});\n\nfunction getBatchFromPool()\n{\n    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\n\nfunction returnBatchToPool(batch: Batch)\n{\n    batchPool[batchPoolIndex++] = batch;\n}\n\n/**\n * Represents an element that can be batched for rendering.\n * @interface\n * @category rendering\n * @advanced\n */\nexport interface BatchableElement\n{\n    /**\n     * The name of the batcher to use. Must be registered.\n     * @type {string}\n     */\n    batcherName: string;\n\n    /**\n     * The texture to be used for rendering.\n     * @type {Texture}\n     */\n    texture: Texture;\n\n    /**\n     * The blend mode to be applied.\n     * @type {BLEND_MODES}\n     */\n    blendMode: BLEND_MODES;\n\n    /**\n     * The size of the index data.\n     * @type {number}\n     */\n    indexSize: number;\n\n    /**\n     * The size of the attribute data.\n     * @type {number}\n     */\n    attributeSize: number;\n\n    /**\n     * The topology to be used for rendering.\n     * @type {Topology}\n     */\n    topology: Topology\n\n    /**\n     * Whether the element should be packed as a quad for better performance.\n     * @type {boolean}\n     */\n    packAsQuad: boolean;\n\n    /**\n     * The texture ID, stored for efficient updating.\n     * @type {number}\n     * @private\n     */\n    _textureId: number;\n\n    /**\n     * The starting position in the attribute buffer.\n     * @type {number}\n     * @private\n     */\n    _attributeStart: number;\n\n    /**\n     * The starting position in the index buffer.\n     * @type {number}\n     * @private\n     */\n    _indexStart: number;\n\n    /**\n     * Reference to the batcher.\n     * @type {Batcher}\n     * @private\n     */\n    _batcher: Batcher;\n\n    /**\n     * Reference to the batch.\n     * @type {Batch}\n     * @private\n     */\n    _batch: Batch;\n\n}\n\n/**\n * Represents a batchable quad element.\n * @extends BatchableElement\n * @category rendering\n * @advanced\n */\nexport interface BatchableQuadElement extends BatchableElement\n{\n    /**\n     * Indicates that this element should be packed as a quad.\n     * @type {true}\n     */\n    packAsQuad: true;\n\n    /**\n     * The size of the attribute data for this quad element.\n     * @type {4}\n     */\n    attributeSize: 4;\n\n    /**\n     * The size of the index data for this quad element.\n     * @type {6}\n     */\n    indexSize: 6;\n\n    /**\n     * The bounds data for this quad element.\n     * @type {BoundsData}\n     */\n    bounds: BoundsData;\n}\n\n/**\n * Represents a batchable mesh element.\n * @extends BatchableElement\n * @category rendering\n * @advanced\n */\nexport interface BatchableMeshElement extends BatchableElement\n{\n    /**\n     * The UV coordinates of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    uvs: number[] | Float32Array;\n\n    /**\n     * The vertex positions of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    positions: number[] | Float32Array;\n\n    /**\n     * The indices of the mesh.\n     * @type {number[] | Uint16Array | Uint32Array}\n     */\n    indices: number[] | Uint16Array | Uint32Array;\n\n    /**\n     * The offset in the index buffer.\n     * @type {number}\n     */\n    indexOffset: number;\n\n    /**\n     * The offset in the attribute buffer.\n     * @type {number}\n     */\n    attributeOffset: number;\n\n    /**\n     * Indicates that this element should not be packed as a quad.\n     * @type {false}\n     */\n    packAsQuad: false;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @category rendering\n * @advanced\n */\nexport interface BatcherOptions\n{\n    /** The maximum number of textures per batch. */\n    maxTextures: number;\n    /** The initial size of the attribute buffer. */\n    attributesInitialSize?: number;\n    /** The initial size of the index buffer. */\n    indicesInitialSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * It is an abstract class that must be extended. see DefaultBatcher for an example.\n * @category rendering\n * @advanced\n */\nexport abstract class Batcher\n{\n    public static defaultOptions: Partial<BatcherOptions> = {\n        maxTextures: null,\n        attributesInitialSize: 4,\n        indicesInitialSize: 6,\n    };\n\n    /** unique id for this batcher */\n    public readonly uid: number = uid('batcher');\n\n    /** The buffer containing attribute data for all elements in the batch. */\n    public attributeBuffer: ViewableBuffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    /** The current size of the attribute data in the batch. */\n    public attributeSize: number;\n\n    /** The current size of the index data in the batch. */\n    public indexSize: number;\n\n    /** The total number of elements currently in the batch. */\n    public elementSize: number;\n\n    /** The starting index of elements in the current batch. */\n    public elementStart: number;\n\n    /** Indicates whether the batch data has been modified and needs updating. */\n    public dirty = true;\n\n    /** The current index of the batch being processed. */\n    public batchIndex = 0;\n\n    /** An array of all batches created during the current rendering process. */\n    public batches: Batch[] = [];\n\n    private _elements: BatchableElement[] = [];\n\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    /** The maximum number of textures per batch. */\n    public readonly maxTextures: number;\n\n    /** The name of the batcher. Must be implemented by subclasses. */\n    public abstract name: string;\n    /** The vertex size of the batcher. Must be implemented by subclasses. */\n    protected abstract vertexSize: number;\n\n    /** The geometry used by this batcher. Must be implemented by subclasses. */\n    public abstract geometry: Geometry;\n\n    /**\n     * The shader used by this batcher. Must be implemented by subclasses.\n     * this can be shared by multiple batchers of the same type.\n     */\n    public abstract shader: Shader;\n\n    /**\n     * Packs the attributes of a BatchableMeshElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packAttributes(\n        element: BatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    /**\n     * Packs the attributes of a BatchableQuadElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packQuadAttributes(\n        element: BatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    constructor(options: BatcherOptions)\n    {\n        options = { ...Batcher.defaultOptions, ...options };\n\n        if (!options.maxTextures)\n        {\n            deprecation('v8.8.0', 'maxTextures is a required option for Batcher now, please pass it in the options');\n            options.maxTextures = getMaxTexturesPerBatch();\n        }\n\n        const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n\n        this.indexBuffer = new Uint16Array(indicesInitialSize);\n\n        this.maxTextures = maxTextures;\n    }\n\n    public begin()\n    {\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n\n        for (let i = 0; i < this.batchIndex; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batchIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableElement)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject._indexStart = this.indexSize;\n        batchableObject._attributeStart = this.attributeSize;\n        batchableObject._batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.attributeSize) * this.vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableElement, texture: Texture): boolean\n    {\n        const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject._textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableElement)\n    {\n        this.dirty = true;\n\n        const attributeBuffer = this.attributeBuffer;\n\n        if (batchableObject.packAsQuad)\n        {\n            this.packQuadAttributes(\n                batchableObject as BatchableQuadElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n        else\n        {\n            this.packAttributes(\n                batchableObject as BatchableMeshElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        const elements = this._elements;\n\n        // length 0??!! (we broke without adding anything)\n        if (!elements[this.elementStart]) return;\n\n        let batch = getBatchFromPool();\n        let textureBatch = batch.textures;\n\n        textureBatch.clear();\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n        let topology = firstElement.topology;\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const indexBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n\n        const maxTextures = this.maxTextures;\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n\n            if (source._batchTick === BATCH_TICK && !breakRequired)\n            {\n                element._textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n\n                if (element.packAsQuad)\n                {\n                    this.packQuadAttributes(\n                        element as BatchableQuadElement,\n                        f32, u32,\n                        element._attributeStart, element._textureId\n                    );\n                    this.packQuadIndex(\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n                else\n                {\n                    this.packAttributes(\n                        element as BatchableMeshElement,\n                        f32, u32,\n                        element._attributeStart,\n                        element._textureId\n                    );\n                    this.packIndex(\n                        element as BatchableMeshElement,\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n\n                element._batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= maxTextures || breakRequired)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    topology,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n                topology = element.topology;\n\n                batch = getBatchFromPool();\n                textureBatch = batch.textures;\n                textureBatch.clear();\n\n                ++BATCH_TICK;\n            }\n\n            element._textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element._batch = batch;\n\n            size += element.indexSize;\n\n            if (element.packAsQuad)\n            {\n                this.packQuadAttributes(\n                    element as BatchableQuadElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n                this.packQuadIndex(\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n            else\n            {\n                this.packAttributes(element as BatchableMeshElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n\n                this.packIndex(\n                    element as BatchableMeshElement,\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                topology,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        topology: Topology,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.bindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n        batch.topology = topology;\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        // track for returning later!\n        this.batches[this.batchIndex++] = batch;\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public packQuadIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public packIndex(element: BatchableMeshElement, indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = element.indices;\n        const size = element.indexSize;\n        const indexOffset = element.indexOffset;\n        const attributeOffset = element.attributeOffset;\n\n        for (let i = 0; i < size; i++)\n        {\n            indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n        }\n    }\n\n    public destroy()\n    {\n        if (this.batches === null) return;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            if (this._elements[i]) this._elements[i]._batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2892, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/buffer/const.ts"],"sourcesContent":["/**\n * Buffer usage flags. they can be combined using the bitwise OR operator\n * eg : BufferUsage.VERTEX | BufferUsage.INDEX\n * @category rendering\n * @advanced\n */\nexport enum BufferUsage\n{\n    /**\n     * The buffer can be mapped for reading. (Example: calling mapAsync() with GPUMapMode.READ)\n     * May only be combined with COPY_DST.\n     */\n    MAP_READ = 0x0001,\n    /**\n     * The buffer can be mapped for writing. (Example: calling mapAsync() with GPUMapMode.WRITE)\n     * May only be combined with COPY_SRC.\n     */\n    MAP_WRITE = 0x0002,\n    /**\n     * The buffer can be used as the source of a copy operation.\n     * (Examples: as the source argument of a copyBufferToBuffer() or copyBufferToTexture() call.)\n     */\n    COPY_SRC = 0x0004,\n    /**\n     * The buffer can be used as the destination of a copy or write operation.\n     * (Examples: as the destination argument of a copyBufferToBuffer() or\n     * copyTextureToBuffer() call, or as the target of a writeBuffer() call.)\n     */\n    COPY_DST = 0x0008,\n    /** The buffer can be used as an index buffer. (Example: passed to setIndexBuffer().) */\n    INDEX = 0x0010,\n    /** The buffer can be used as a vertex buffer. (Example: passed to setVertexBuffer().) */\n    VERTEX = 0x0020,\n    /**\n     * The buffer can be used as a uniform buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"uniform\".)\n     */\n    UNIFORM = 0x0040,\n    /**\n     * The buffer can be used as a storage buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"storage\" or \"read-only-storage\".)\n     */\n    STORAGE = 0x0080,\n    /**\n     * The buffer can be used as to store indirect command arguments.\n     * (Examples: as the indirectBuffer argument of a drawIndirect() or dispatchWorkgroupsIndirect() call.)\n     */\n    INDIRECT = 0x0100,\n    /**\n     * The buffer can be used to capture query results.\n     * (Example: as the destination argument of a resolveQuerySet() call.)\n     */\n    QUERY_RESOLVE = 0x0200,\n    /** the buffer will not be updated frequently */\n    STATIC = 0x0400\n}\n"],"names":["BufferUsage"],"mappings":";;;;;AAMY,IAAA,WAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,YAAL,KAAA;IAMHA,YAAAA,CAAAA,YAAAA,CAAA,WAAA,GAAW,CAAX,CAAA,GAAA,UAAA,CAAA;IAKAA,YAAAA,CAAAA,YAAAA,CAAA,YAAA,GAAY,CAAZ,CAAA,GAAA,WAAA,CAAA;IAKAA,YAAAA,CAAAA,YAAAA,CAAA,WAAA,GAAW,CAAX,CAAA,GAAA,UAAA,CAAA;IAMAA,YAAAA,CAAAA,YAAAA,CAAA,WAAA,GAAW,CAAX,CAAA,GAAA,UAAA,CAAA;IAEAA,YAAAA,CAAAA,YAAAA,CAAA,QAAA,GAAQ,EAAR,CAAA,GAAA,OAAA,CAAA;IAEAA,YAAAA,CAAAA,YAAAA,CAAA,SAAA,GAAS,EAAT,CAAA,GAAA,QAAA,CAAA;IAKAA,YAAAA,CAAAA,YAAAA,CAAA,UAAA,GAAU,EAAV,CAAA,GAAA,SAAA,CAAA;IAKAA,YAAAA,CAAAA,YAAAA,CAAA,UAAA,GAAU,GAAV,CAAA,GAAA,SAAA,CAAA;IAKAA,YAAAA,CAAAA,YAAAA,CAAA,WAAA,GAAW,GAAX,CAAA,GAAA,UAAA,CAAA;IAKAA,YAAAA,CAAAA,YAAAA,CAAA,gBAAA,GAAgB,GAAhB,CAAA,GAAA,eAAA,CAAA;IAEAA,YAAAA,CAAAA,YAAAA,CAAA,SAAA,GAAS,IAAT,CAAA,GAAA,QAAA,CAAA;IAhDQA,OAAAA,YAAAA,CAAAA;AAAA,CAAA,EAAA,WAAA,IAAA,CAAA,CAAA","debugId":null}},
    {"offset": {"line": 2917, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/buffer/Buffer.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { BufferUsage } from './const';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\n\n/**\n * All the various typed arrays that exist in js\n * @category rendering\n * @advanced\n */\n// eslint-disable-next-line max-len\nexport type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;\n\n/**\n * Options for creating a buffer\n *\n * This interface defines the options that can be passed to the Buffer constructor.\n * It includes the data to initialize the buffer with, the size of the buffer,\n * the usage of the buffer, a label for debugging, and whether the buffer should shrink to fit\n * when the data becomes smaller.\n * @category rendering\n * @advanced\n */\nexport interface BufferOptions\n{\n    /**\n     * the data to initialize the buffer with, this can be a typed array,\n     * or a regular number array. If it is a number array, it will be converted to a Float32Array\n     */\n    data?: TypedArray | number[];\n    /** the size of the buffer in bytes, if not supplied, it will be inferred from the data */\n    size?: number;\n    /** the usage of the buffer, see {@link BufferUsage} */\n    usage: number;\n    /** a label for the buffer, this is useful for debugging */\n    label?: string;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    shrinkToFit?: boolean;\n}\n\n/** @internal */\nexport interface BufferDescriptor\n{\n    label?: string;\n    size: GPUSize64;\n    usage: BufferUsage;\n    mappedAtCreation?: boolean;\n}\n\n/**\n * A wrapper for a WebGPU/WebGL Buffer.\n * In PixiJS, the Buffer class is used to manage the data that is sent to the GPU rendering pipeline.\n * It abstracts away the underlying GPU buffer and provides an interface for uploading typed arrays or other data to the GPU,\n * They are used in the following places:\n * <br><br>\n * .1. {@link Geometry} as attribute data or index data for geometry\n * <br>\n * .2. {@link UniformGroup} as an underlying buffer for uniform data\n * <br>\n * .3. {@link BufferResource} as an underlying part of a buffer used directly by the GPU program\n * <br>\n *\n * It is important to note that you must provide a usage type when creating a buffer. This is because\n * the underlying GPU buffer needs to know how it will be used. For example, if you are creating a buffer\n * to hold vertex data, you would use `BufferUsage.VERTEX`. This will tell the GPU that this buffer will be\n * used as a vertex buffer. This is important because it will affect how you can use the buffer.\n *\n * Buffers are updated by calling the {@link Buffer.update} method. This immediately updates the buffer on the GPU.\n * Be mindful of calling this more often than you need to. It is recommended to update buffers only when needed.\n *\n * In WebGPU, a GPU buffer cannot resized. This limitation is abstracted away, but know that resizing a buffer means\n * creating a brand new one and destroying the old, so it is best to limit this if possible.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array([1, 2, 3, 4]),\n *     usage: BufferUsage.VERTEX,\n * });\n * @category rendering\n * @advanced\n */\nexport class Buffer extends EventEmitter<{\n    change: BindResource,\n    update: Buffer,\n    destroy: Buffer,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    public readonly _resourceType = 'buffer';\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    public _resourceId = uid('resource');\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    public _touched = 0;\n\n    /**\n     * a description of the buffer and how it should be set up on the GPU\n     * @internal\n     */\n    public readonly descriptor: BufferDescriptor;\n\n    /** @internal */\n    public _updateID = 1;\n\n    /** @internal */\n    public _updateSize: number;\n\n    private _data: TypedArray;\n\n    private _dataInt32: Int32Array = null;\n\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    public shrinkToFit = true;\n\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Creates a new Buffer with the given options\n     * @param options - the options for the buffer\n     */\n    constructor(options: BufferOptions)\n    {\n        let { data, size } = options;\n        const { usage, label, shrinkToFit } = options;\n\n        super();\n\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data as number[]);\n        }\n\n        this._data = data as TypedArray;\n\n        size ??= (data as TypedArray)?.byteLength;\n\n        const mappedAtCreation = !!data;\n\n        this.descriptor = {\n            size,\n            usage,\n            mappedAtCreation,\n            label,\n        };\n\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n\n    /** the data in the buffer */\n    get data()\n    {\n        return this._data;\n    }\n\n    set data(value: TypedArray)\n    {\n        this.setDataWithSize(value, value.length, true);\n    }\n\n    get dataInt32()\n    {\n        if (!this._dataInt32)\n        {\n            this._dataInt32 = new Int32Array((this.data as any).buffer);\n        }\n\n        return this._dataInt32;\n    }\n\n    /** whether the buffer is static or not */\n    get static()\n    {\n        return !!(this.descriptor.usage & BufferUsage.STATIC);\n    }\n\n    set static(value: boolean)\n    {\n        if (value)\n        {\n            this.descriptor.usage |= BufferUsage.STATIC;\n        }\n        else\n        {\n            this.descriptor.usage &= ~BufferUsage.STATIC;\n        }\n    }\n\n    /**\n     * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n     * If you only want to update a subset of the buffer, you can pass in the size of the data.\n     * @param value - the data to set\n     * @param size - the size of the data in bytes\n     * @param syncGPU - should the buffer be updated on the GPU immediately?\n     */\n    public setDataWithSize(value: TypedArray, size: number, syncGPU: boolean)\n    {\n        // Increment update ID\n        this._updateID++;\n\n        this._updateSize = (size * value.BYTES_PER_ELEMENT);\n\n        // If the data hasn't changed, early return after emitting 'update'\n        if (this._data === value)\n        {\n            if (syncGPU) this.emit('update', this);\n\n            return;\n        }\n\n        // Cache old data and update to new value\n        const oldData = this._data;\n\n        this._data = value;\n        this._dataInt32 = null;\n\n        // Event handling\n        if (!oldData || oldData.length !== value.length)\n        {\n            if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength)\n            {\n                if (syncGPU) this.emit('update', this);\n            }\n            else\n            {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = uid('resource');\n                this.emit('change', this);\n            }\n\n            return;\n        }\n\n        if (syncGPU) this.emit('update', this);\n    }\n\n    /**\n     * updates the buffer on the GPU to reflect the data in the buffer.\n     * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n     * you can pass in the size of the buffer to update.\n     * @param sizeInBytes - the new size of the buffer in bytes\n     */\n    public update(sizeInBytes?: number): void\n    {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n\n        this._updateID++;\n\n        this.emit('update', this);\n    }\n\n    /** Destroys the buffer */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this._data = null;\n        (this.descriptor as null) = null;\n\n        this.removeAllListeners();\n    }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3063, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/ensureIsBuffer.ts"],"sourcesContent":["import { Buffer } from '../../buffer/Buffer';\nimport { BufferUsage } from '../../buffer/const';\n\nimport type { TypedArray } from '../../buffer/Buffer';\n\n/**\n * Converts something into a buffer. If it is already a buffer it will pass it through\n * if it is a number array it will convert it to a float32 array before being passed into a buffer\n * the buffer will be created with the correct usage flags for geometry attributes\n * @param buffer - number array\n * @param index - is this an index buffer?\n * @returns a buffer\n * @category rendering\n * @internal\n */\nexport function ensureIsBuffer(buffer: Buffer | TypedArray | number[], index: boolean): Buffer\n{\n    if (!(buffer instanceof Buffer))\n    {\n        let usage: number = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n\n        // its an array!\n        if (buffer instanceof Array)\n        {\n            if (index)\n            {\n                buffer = new Uint32Array(buffer);\n                usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n            }\n\n            else\n            {\n                buffer = new Float32Array(buffer);\n                usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n            }\n        }\n\n        buffer = new Buffer({\n            data: buffer,\n            label: index ? 'index-mesh-buffer' : 'vertex-mesh-buffer',\n            usage\n        });\n    }\n\n    return buffer;\n}\n"],"names":[],"mappings":";;;;;;;;;AAegB,SAAA,cAAA,CAAe,MAAA,EAAwC,KACvE,EAAA;IACQ,IAAA,CAAA,CAAE,kBAAkB,+PACxB,CAAA,EAAA;QACI,IAAI,KAAgB,GAAA,KAAA,GAAQ,mQAAY,CAAA,KAAA,GAAQ,mQAAY,CAAA,MAAA,CAAA;QAG5D,IAAI,kBAAkB,KACtB,EAAA;YACI,IAAI,KACJ,EAAA;gBACa,MAAA,GAAA,IAAI,YAAY,MAAM,CAAA,CAAA;gBACvB,KAAA,GAAA,mQAAA,CAAY,KAAA,GAAQ,mQAAY,CAAA,QAAA,CAAA;YAAA,CAI5C,MAAA;gBACa,MAAA,GAAA,IAAI,aAAa,MAAM,CAAA,CAAA;gBACxB,KAAA,GAAA,mQAAA,CAAY,MAAA,GAAS,mQAAY,CAAA,QAAA,CAAA;YAAA,CAC7C;QAAA,CACJ;QAEA,MAAA,GAAS,IAAI,+PAAO,CAAA;YAChB,IAAM,EAAA,MAAA;YACN,KAAA,EAAO,QAAQ,mBAAsB,GAAA,oBAAA;YACrC,KAAA;QAAA,CACH,CAAA,CAAA;IAAA,CACL;IAEO,OAAA,MAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 3098, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getGeometryBounds.ts"],"sourcesContent":["import type { Bounds } from '../../../../../scene/container/bounds/Bounds';\nimport type { Geometry } from '../Geometry';\n\n/**\n * Gets the 2D bounds of a geometry, based on a specific attribute.\n * @param geometry - Geometry to to measure\n * @param attributeId - AttributeId that contains the x,y data\n * @param bounds - Bounds to store the result in\n * @returns the bounds\n * @internal\n */\nexport function getGeometryBounds(geometry: Geometry, attributeId: string, bounds: Bounds): Bounds\n{\n    const attribute = geometry.getAttribute(attributeId);\n\n    if (!attribute)\n    {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n\n        return bounds;\n    }\n\n    const data = attribute.buffer.data as Float32Array;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const byteSize = data.BYTES_PER_ELEMENT;\n\n    // stride and offset MAY have not been calculated yet.. so go with assumed defaults\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || (2 * 4)) / byteSize;\n\n    for (let i = offset; i < data.length; i += stride)\n    {\n        const x = data[i];\n        const y = data[i + 1];\n\n        if (x > maxX)maxX = x;\n        if (y > maxY)maxY = y;\n        if (x < minX)minX = x;\n        if (y < minY)minY = y;\n    }\n\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n\n    return bounds;\n}\n"],"names":[],"mappings":";;;;;AAWgB,SAAA,iBAAA,CAAkB,QAAoB,EAAA,WAAA,EAAqB,MAC3E,EAAA;IACU,MAAA,SAAA,GAAY,QAAS,CAAA,YAAA,CAAa,WAAW,CAAA,CAAA;IAEnD,IAAI,CAAC,SACL,EAAA;QACI,MAAA,CAAO,IAAO,GAAA,CAAA,CAAA;QACd,MAAA,CAAO,IAAO,GAAA,CAAA,CAAA;QACd,MAAA,CAAO,IAAO,GAAA,CAAA,CAAA;QACd,MAAA,CAAO,IAAO,GAAA,CAAA,CAAA;QAEP,OAAA,MAAA,CAAA;IAAA,CACX;IAEM,MAAA,IAAA,GAAO,UAAU,MAAO,CAAA,IAAA,CAAA;IAE9B,IAAI,IAAO,GAAA,QAAA,CAAA;IACX,IAAI,IAAO,GAAA,QAAA,CAAA;IACX,IAAI,IAAO,GAAA,CAAA,QAAA,CAAA;IACX,IAAI,IAAO,GAAA,CAAA,QAAA,CAAA;IAEX,MAAM,WAAW,IAAK,CAAA,iBAAA,CAAA;IAGhB,MAAA,MAAA,GAAA,CAAU,SAAU,CAAA,MAAA,IAAU,CAAK,IAAA,QAAA,CAAA;IACzC,MAAM,MAAU,GAAA,CAAA,SAAA,CAAU,MAAW,IAAA,CAAA,GAAI,CAAM,IAAA,QAAA,CAAA;IAE/C,IAAA,IAAS,IAAI,MAAQ,EAAA,CAAA,GAAI,IAAK,CAAA,MAAA,EAAQ,KAAK,MAC3C,CAAA;QACU,MAAA,CAAA,GAAI,IAAA,CAAK,CAAC,CAAA,CAAA;QACV,MAAA,CAAA,GAAI,IAAK,CAAA,CAAA,GAAI,CAAC,CAAA,CAAA;QAEpB,IAAI,CAAI,GAAA,IAAA,EAAY,IAAA,GAAA,CAAA,CAAA;QACpB,IAAI,CAAI,GAAA,IAAA,EAAY,IAAA,GAAA,CAAA,CAAA;QACpB,IAAI,CAAI,GAAA,IAAA,EAAY,IAAA,GAAA,CAAA,CAAA;QACpB,IAAI,CAAI,GAAA,IAAA,EAAY,IAAA,GAAA,CAAA,CAAA;IAAA,CACxB;IAEA,MAAA,CAAO,IAAO,GAAA,IAAA,CAAA;IACd,MAAA,CAAO,IAAO,GAAA,IAAA,CAAA;IACd,MAAA,CAAO,IAAO,GAAA,IAAA,CAAA;IACd,MAAA,CAAO,IAAO,GAAA,IAAA,CAAA;IAEP,OAAA,MAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 3140, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/geometry/Geometry.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { uid } from '../../../../utils/data/uid';\nimport { Buffer } from '../buffer/Buffer';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer';\nimport { getGeometryBounds } from './utils/getGeometryBounds';\n\nimport type { TypedArray } from '../buffer/Buffer';\nimport type { Topology, VertexFormat } from './const';\n\n/**\n * The index buffer array type used in geometries.\n * @category rendering\n * @advanced\n */\nexport type IndexBufferArray = Uint16Array | Uint32Array;\n\n/**\n * The attribute data for a geometries attributes\n * @category rendering\n * @advanced\n */\nexport interface Attribute\n{\n    /** the buffer that this attributes data belongs to */\n    buffer: Buffer;\n    /** the format of the attribute */\n    format?: VertexFormat;\n    /** the stride of the data in the buffer - in bytes*/\n    stride?: number;\n    /** the offset of the attribute from the buffer, defaults to 0 - in bytes*/\n    offset?: number;\n    /** is this an instanced buffer? (defaults to false) */\n    instance?: boolean;\n    /** the number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */\n    size?: number;\n    /**\n     * the starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     */\n    start?: number;\n    /**\n     * attribute divisor for instanced rendering. Note: this is a **WebGL-only** feature, the WebGPU renderer will\n     * issue a warning if one of the attributes has divisor set.\n     */\n    divisor?: number;\n}\n\n/**\n * The attribute option used by the constructor for adding geometries attributes\n * extends {@link Attribute} but allows for the buffer to be a typed or number array\n * @category rendering\n * @advanced\n */\nexport type AttributeOption = Omit<Attribute, 'buffer'> & { buffer: Buffer | TypedArray | number[]}\n| Buffer | TypedArray | number[];\n\n/**\n * The attribute options used by the constructor for adding geometries attributes\n * extends {@link Attribute} but allows for the buffer to be a typed or number array\n * @category rendering\n * @advanced\n */\nexport type AttributeOptions = Record<string, AttributeOption>;\n\n/**\n * the interface that describes the structure of the geometry\n * @category rendering\n * @advanced\n */\nexport interface GeometryDescriptor\n{\n    /** an optional label to easily identify the geometry */\n    label?: string;\n    /** the attributes that make up the geometry */\n    attributes?: AttributeOptions;\n    /** optional index buffer for this geometry */\n    indexBuffer?: Buffer | TypedArray | number[];\n    /** the topology of the geometry, defaults to 'triangle-list' */\n    topology?: Topology;\n\n    instanceCount?: number;\n}\nfunction ensureIsAttribute(attribute: AttributeOption): Attribute\n{\n    if (attribute instanceof Buffer || Array.isArray(attribute) || (attribute as TypedArray).BYTES_PER_ELEMENT)\n    {\n        attribute = {\n            buffer: attribute as Buffer | TypedArray | number[],\n        };\n    }\n\n    (attribute as Attribute).buffer = ensureIsBuffer(attribute.buffer as Buffer | TypedArray | number[], false);\n\n    return attribute as Attribute;\n}\n\n/**\n * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.\n * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.\n * Essentially, a Geometry object holds the data you'd send to a GPU buffer.\n *\n * A geometry is basically made of two components:\n * <br>\n * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,\n * texture coordinates, etc. They map directly to attributes in your vertex shaders.\n * <br>\n * <b>Indices</b>: An optional array that describes how the vertices are connected.\n * If not provided, vertices will be interpreted in the sequence they're given.\n * @example\n *\n * const geometry = new Geometry({\n *   attributes: {\n *     aPosition: [ // add some positions\n *       0, 0,\n *       0, 100,\n *       100, 100,\n *       100,   0,\n *     ],\n *     aUv: [ // add some uvs\n *       0, 0,\n *       0, 1,\n *       1, 1,\n *       1, 0,\n *     ]\n *   }\n * });\n * @category rendering\n * @advanced\n */\nexport class Geometry extends EventEmitter<{\n    update: Geometry,\n    destroy: Geometry,\n}>\n{\n    /** The topology of the geometry. */\n    public topology: Topology;\n    /** The unique id of the geometry. */\n    public readonly uid: number = uid('geometry');\n    /** A record of the attributes of the geometry. */\n    public readonly attributes: Record<string, Attribute>;\n    /** The buffers that the attributes use */\n    public readonly buffers: Buffer[];\n    /** The index buffer of the geometry */\n    public indexBuffer: Buffer;\n\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     */\n    public _layoutKey = 0;\n\n    /** the instance count of the geometry to draw */\n    public instanceCount = 1;\n\n    private readonly _bounds: Bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Create a new instance of a geometry\n     * @param options - The options for the geometry.\n     */\n    constructor(options: GeometryDescriptor = {})\n    {\n        super();\n\n        const { attributes, indexBuffer, topology } = options;\n\n        this.buffers = [];\n\n        this.attributes = {};\n\n        if (attributes)\n        {\n            for (const i in attributes)\n            {\n                this.addAttribute(i, attributes[i]);\n            }\n        }\n\n        this.instanceCount = options.instanceCount ?? 1;\n\n        if (indexBuffer)\n        {\n            this.addIndex(indexBuffer);\n        }\n\n        this.topology = topology || 'triangle-list';\n    }\n\n    protected onBufferUpdate(): void\n    {\n        this._boundsDirty = true;\n        this.emit('update', this);\n    }\n\n    /**\n     * Returns the requested attribute.\n     * @param id - The name of the attribute required\n     * @returns - The attribute requested.\n     */\n    public getAttribute(id: string): Attribute\n    {\n        return this.attributes[id];\n    }\n\n    /**\n     * Returns the index buffer\n     * @returns - The index buffer.\n     */\n    public getIndex(): Buffer\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * Returns the requested buffer.\n     * @param id - The name of the buffer required.\n     * @returns - The buffer requested.\n     */\n    public getBuffer(id: string): Buffer\n    {\n        return this.getAttribute(id).buffer;\n    }\n\n    /**\n     * Used to figure out how many vertices there are in this geometry\n     * @returns the number of vertices in the geometry\n     */\n    public getSize(): number\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n\n            // TODO use SIZE again like v7..\n            return (buffer.data as any).length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Adds an attribute to the geometry.\n     * @param name - The name of the attribute to add.\n     * @param attributeOption - The attribute option to add.\n     */\n    public addAttribute(name: string, attributeOption: AttributeOption): void\n    {\n        const attribute = ensureIsAttribute(attributeOption);\n\n        const bufferIndex = this.buffers.indexOf(attribute.buffer);\n\n        if (bufferIndex === -1)\n        {\n            this.buffers.push(attribute.buffer);\n\n            // two events here - one for a resize (new buffer change)\n            // and one for an update (existing buffer change)\n            attribute.buffer.on('update', this.onBufferUpdate, this);\n            attribute.buffer.on('change', this.onBufferUpdate, this);\n        }\n        this.attributes[name] = attribute;\n    }\n\n    /**\n     * Adds an index buffer to the geometry.\n     * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n     */\n    public addIndex(indexBuffer: Buffer | TypedArray | number[]): void\n    {\n        this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n        this.buffers.push(this.indexBuffer);\n    }\n\n    /** Returns the bounds of the geometry. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        return getGeometryBounds(this, 'aPosition', this._bounds);\n    }\n\n    /**\n     * destroys the geometry.\n     * @param destroyBuffers - destroy the buffers associated with this geometry\n     */\n    public destroy(destroyBuffers = false): void\n    {\n        this.emit('destroy', this);\n\n        this.removeAllListeners();\n\n        if (destroyBuffers)\n        {\n            this.buffers.forEach((buffer) => buffer.destroy());\n        }\n\n        (this.attributes as null) = null;\n        (this.buffers as null) = null;\n        (this.indexBuffer as null) = null;\n        (this._bounds as null) = null;\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3279, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/batcher/shared/BatchGeometry.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/batcher/shared/BatchGeometry.ts"],"sourcesContent":["import { Buffer } from '../../renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../renderers/shared/buffer/const';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry';\n\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\n\n/**\n * This class represents a geometry used for batching in the rendering system.\n * It defines the structure of vertex attributes and index buffers for batched rendering.\n * @category rendering\n * @advanced\n */\nexport class BatchGeometry extends Geometry\n{\n    constructor()\n    {\n        const vertexSize = 6;\n\n        const attributeBuffer = new Buffer({\n            data: placeHolderBufferData,\n            label: 'attribute-batch-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const indexBuffer = new Buffer({\n            data: placeHolderIndexData,\n            label: 'index-batch-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST, // | BufferUsage.STATIC,\n            shrinkToFit: false,\n        });\n\n        const stride = vertexSize * 4;\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: 'unorm8x4',\n                    stride,\n                    offset: 4 * 4,\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: 'uint16x2',\n                    stride,\n                    offset: 5 * 4,\n                },\n            },\n            indexBuffer\n        });\n    }\n}\n\n"],"names":[],"mappings":";;;;;;;;;;;AAIA,MAAM,qBAAA,GAAwB,IAAI,YAAA,CAAa,CAAC,CAAA,CAAA;AAChD,MAAM,oBAAA,GAAuB,IAAI,WAAA,CAAY,CAAC,CAAA,CAAA;AAQvC,MAAM,sBAAsB,qQACnC,CAAA;IACI,WACA,EAAA;QACI,MAAM,UAAa,GAAA,CAAA,CAAA;QAEb,MAAA,eAAA,GAAkB,IAAI,+PAAO,CAAA;YAC/B,IAAM,EAAA,qBAAA;YACN,KAAO,EAAA,wBAAA;YACP,KAAA,EAAO,mQAAY,CAAA,MAAA,GAAS,mQAAY,CAAA,QAAA;YACxC,WAAa,EAAA,KAAA;QAAA,CAChB,CAAA,CAAA;QAEK,MAAA,WAAA,GAAc,IAAI,+PAAO,CAAA;YAC3B,IAAM,EAAA,oBAAA;YACN,KAAO,EAAA,oBAAA;YACP,KAAA,EAAO,mQAAY,CAAA,KAAA,GAAQ,mQAAY,CAAA,QAAA;YAAA,wBAAA;YACvC,WAAa,EAAA,KAAA;QAAA,CAChB,CAAA,CAAA;QAED,MAAM,SAAS,UAAa,GAAA,CAAA,CAAA;QAEtB,KAAA,CAAA;YACF,UAAY,EAAA;gBACR,SAAW,EAAA;oBACP,MAAQ,EAAA,eAAA;oBACR,MAAQ,EAAA,WAAA;oBACR,MAAA;oBACA,MAAQ,EAAA,CAAA;gBAAA,CACZ;gBACA,GAAK,EAAA;oBACD,MAAQ,EAAA,eAAA;oBACR,MAAQ,EAAA,WAAA;oBACR,MAAA;oBACA,QAAQ,CAAI,GAAA,CAAA;gBAAA,CAChB;gBACA,MAAQ,EAAA;oBACJ,MAAQ,EAAA,eAAA;oBACR,MAAQ,EAAA,UAAA;oBACR,MAAA;oBACA,QAAQ,CAAI,GAAA,CAAA;gBAAA,CAChB;gBACA,kBAAoB,EAAA;oBAChB,MAAQ,EAAA,eAAA;oBACR,MAAQ,EAAA,UAAA;oBACR,MAAA;oBACA,QAAQ,CAAI,GAAA,CAAA;gBAAA,CAChB;YAAA,CACJ;YACA,WAAA;QAAA,CACH,CAAA,CAAA;IAAA,CACL;AACJ","debugId":null}},
    {"offset": {"line": 3346, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/utils/createIdFromString.ts"],"sourcesContent":["const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\n/**\n * @param value\n * @param groupId\n * @internal\n */\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAM,QAAA,GAAA,aAAA,GAA0C,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;AAC3D,MAAM,MAAA,GAAA,aAAA,GAAwC,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;AAOzC,SAAA,kBAAA,CAAmB,KAAA,EAAe,OAClD,EAAA;IACQ,IAAA,EAAA,GAAK,MAAA,CAAO,KAAK,CAAA,CAAA;IAErB,IAAI,OAAO,KACX,CAAA,EAAA;QACQ,IAAA,QAAA,CAAS,OAAO,CAAA,KAAM,KAC1B,CAAA,EAAA;YACI,QAAA,CAAS,OAAO,CAAI,GAAA,CAAA,CAAA;QAAA,CACxB;QAEA,MAAA,CAAO,KAAK,CAAA,GAAI,EAAK,GAAA,QAAA,CAAS,OAAO,CAAA,EAAA,CAAA;IAAA,CACzC;IAEO,OAAA,EAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 3369, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts"],"sourcesContent":["import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\n/** @internal */\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n"],"names":[],"mappings":";;;;;;;AAIA,IAAI,oBAAA,CAAA;AAGG,SAAS,uBAChB,GAAA;IACI,IAAI,CAAC,oBACL,EAAA;QAC2B,oBAAA,GAAA,SAAA,CAAA;QACvB,MAAM,SAAK,sRAAe,EAAA,CAAA;QAE1B,IAAI,EACJ,EAAA;YACI,IAAI,GAAG,wBACP,EAAA;gBACI,MAAM,iBAAiB,EAAG,CAAA,wBAAA,CAAyB,EAAG,CAAA,eAAA,EAAiB,GAAG,UAAU,CAAA,CAAA;gBAE7D,oBAAA,GAAA,cAAA,CAAe,SAAA,GAAY,OAAU,GAAA,SAAA,CAAA;YAAA,CAChE;QAAA,CACJ;IAAA,CACJ;IAEO,OAAA,oBAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 3396, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts"],"sourcesContent":["/**\n * @param src\n * @param isES300\n * @param isFragment\n * @internal\n */\nexport function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n\n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n"],"names":[],"mappings":";;;;;AAMgB,SAAA,iBAAA,CAAkB,GAAa,EAAA,OAAA,EAAkB,UACjE,EAAA;IACQ,IAAA,OAAA,EAAgB,OAAA,GAAA,CAAA;IAEpB,IAAI,UACJ,EAAA;QACU,GAAA,GAAA,GAAA,CAAI,OAAQ,CAAA,sBAAA,EAAwB,EAAE,CAAA,CAAA;QAErC,OAAA,mMAOL,GAAG,EAAA;IAAA,CAET;IAEO,OAAA,sJAMD,GAAG,EAAA;AAEb","debugId":null}},
    {"offset": {"line": 3415, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts"],"sourcesContent":["import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n"],"names":[],"mappings":";;;;;AAsBgB,SAAA,eAAA,CACZ,GACA,EAAA,OAAA,EACA,UAEJ,EAAA;IACI,MAAM,qBAAwB,GAAA,UAAA,GAAa,OAAQ,CAAA,6BAAA,GAAgC,OAAQ,CAAA,2BAAA,CAAA;IAE3F,IAAI,GAAI,CAAA,SAAA,CAAU,CAAG,EAAA,CAAC,MAAM,WAC5B,EAAA;QAEI,IAAI,SAAY,GAAA,UAAA,GAAa,OAAQ,CAAA,0BAAA,GAA6B,OAAQ,CAAA,wBAAA,CAAA;QAGtE,IAAA,SAAA,KAAc,OAAW,IAAA,qBAAA,KAA0B,OACvD,EAAA;YACgB,SAAA,GAAA,SAAA,CAAA;QAAA,CAChB;QAEA,OAAO,oBAAa,SAAS,EAAA,aAAe,CAAA,CAAA,KAAH,GAAG;IAAA,CAChD,MAAA,IACS,0BAA0B,OAAW,IAAA,GAAA,CAAI,SAAA,CAAU,CAAG,EAAA,EAAE,MAAM,iBACvE,EAAA;QAEW,OAAA,GAAA,CAAI,OAAQ,CAAA,iBAAA,EAAmB,mBAAmB,CAAA,CAAA;IAAA,CAC7D;IAEO,OAAA,GAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 3439, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts"],"sourcesContent":["/**\n * @param src\n * @param isES300\n * @internal\n */\nexport function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n"],"names":[],"mappings":";;;;;AAKgB,SAAA,aAAA,CAAc,GAAA,EAAa,OAC3C,EAAA;IACI,IAAI,CAAC,OAAA,EAAgB,OAAA,GAAA,CAAA;IAEd,OAAA,oBAAuB,CAAA,CAAA,KAAH,GAAG;AAClC","debugId":null}},
    {"offset": {"line": 3454, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts"],"sourcesContent":["const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\n/**\n * @param src\n * @param root0\n * @param root0.name\n * @param isFragment\n * @internal\n */\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAM,oBAA+C,CAAA,CAAC,CAAA;AACtD,MAAM,kBAA6C,CAAA,CAAC,CAAA;AAS7C,SAAS,eAAe,GAAa;UAAE,OAAO,AAAe,YAAA,EAAA,EAAA,GAAxB,oBAA8C,iEAAa,IACvG,EAAA;IACW,IAAA,GAAA,IAAA,CAAK,OAAQ,CAAA,MAAA,EAAQ,GAAG,CAAA,CAAA;IAE/B,IAAA,IAAQ,aAAa,WAAc,GAAA,SAAA,CAAA;IAE7B,MAAA,SAAA,GAAY,aAAa,iBAAoB,GAAA,eAAA,CAAA;IAE/C,IAAA,SAAA,CAAU,IAAI,CAClB,EAAA;QACI,SAAA,CAAU,IAAI,CAAA,EAAA,CAAA;QACN,IAAA,IAAA,CAAA,GAAmB,CAAA,CAAA,KAAf,SAAU,CAAA,IAAI,CAAC;IAAA,CAG/B,MAAA;QACI,SAAA,CAAU,IAAI,CAAI,GAAA,CAAA,CAAA;IAAA,CACtB;IAGI,IAAA,GAAA,CAAI,OAAQ,CAAA,qBAAqB,CAAM,KAAA,CAAA,CAAA,EAAW,OAAA,GAAA,CAAA;IAEhD,MAAA,UAAA,GAAa,uBAA2B,CAAA,CAAA,KAAJ,IAAI;IAE9C,OAAO,UAAG,UAAU,EAAA,MAAQ,CAAA,CAAA,KAAH,GAAG;AAChC","debugId":null}},
    {"offset": {"line": 3482, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts"],"sourcesContent":["/**\n * @param src\n * @param isES300\n * @internal\n */\nexport function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n"],"names":[],"mappings":";;;;;AAKgB,SAAA,YAAA,CAAa,GAAA,EAAa,OAC1C,EAAA;IACI,IAAI,CAAC,OAAA,EAAgB,OAAA,GAAA,CAAA;IAEd,OAAA,GAAA,CAAI,OAAQ,CAAA,iBAAA,EAAmB,EAAE,CAAA,CAAA;AAC5C","debugId":null}},
    {"offset": {"line": 3497, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts"],"sourcesContent":["import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\n/** @internal */\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\n/** @internal */\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @category rendering\n * @advanced\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n\n    transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @category rendering\n * @advanced\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     */\n    public readonly _key: number;\n    /**\n     * A cache key used to identify the program instance.\n     * @internal\n     */\n    public _cacheKey: string;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this.transformFeedbackVaryings = options.transformFeedbackVaryings;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n\n        programCache[this._cacheKey] = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n            programCache[key]._cacheKey = key;\n        }\n\n        return programCache[key];\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAoDA,MAAM,SAA8F,GAAA;IAAA,+BAAA;kBAEhG,mSAAA;IAAA,+CAAA;qBAEA,ySAAA;IAAA,4EAAA;uBAEA,6SAAA;IAAA,qCAAA;oBAEA,uSAAA;IAAA,8CAAA;mBAEA,qSAAA;AACJ,CAAA,CAAA;AAEA,MAAM,YAAA,GAAA,aAAA,GAAiD,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;AAiC3D,MAAM,UAAA,GAAN,MAAM,UACb,CAAA;IAmFI,yBAAA,GAGO,OACP,GAAA;QACK,IAAA,CAAK,QAAoB,GAAA,IAAA,CAAA;QACzB,IAAA,CAAK,MAAkB,GAAA,IAAA,CAAA;QAExB,IAAA,CAAK,cAAiB,GAAA,IAAA,CAAA;QACtB,IAAA,CAAK,YAAe,GAAA,IAAA,CAAA;QACpB,IAAA,CAAK,iBAAoB,GAAA,IAAA,CAAA;QAEzB,IAAA,CAAK,yBAA4B,GAAA,IAAA,CAAA;QAEpB,YAAA,CAAA,IAAA,CAAK,SAAS,CAAI,GAAA,IAAA,CAAA;IAAA,CACnC;IAAA;;;;;;GAAA,GASA,OAAc,KAAK,OACnB,EAAA;QACI,MAAM,MAAS,AAAH,UAAG,OAAA,CAAQ,MAAM,EAAA,CAAA,IAAoB,CAAA,CAAA,KAAhB,QAAQ,QAAQ;QAE7C,IAAA,CAAC,YAAa,CAAA,GAAG,CACrB,EAAA;YACI,YAAA,CAAa,GAAG,CAAA,GAAI,IAAI,UAAA,CAAU,OAAO,CAAA,CAAA;YAC5B,YAAA,CAAA,GAAG,CAAA,CAAE,SAAY,GAAA,GAAA,CAAA;QAAA,CAClC;QAEA,OAAO,YAAA,CAAa,GAAG,CAAA,CAAA;IAAA,CAC3B;IAtHJ;;;GAAA,GA2CI,YAAY,OACZ,CAAA;QACI,OAAA,GAAU;YAAE,GAAG,UAAU,CAAA,cAAA;YAAgB,GAAG,OAAQ;QAAA,CAAA,CAAA;QAIpD,MAAM,OAAU,GAAA,OAAA,CAAQ,QAAS,CAAA,OAAA,CAAQ,iBAAiB,CAAM,KAAA,CAAA,CAAA,CAAA;QAEhE,MAAM,mBAAsB,GAAA;YACxB,YAAc,EAAA,OAAA;YACd,eAAiB,EAAA;gBACb,4BAA4B,OAAQ,CAAA,0BAAA;gBACpC,0BAA0B,OAAQ,CAAA,wBAAA;gBAClC,2BAA6B,EAAA,OAAA;gBAC7B,mCAA+B,wSAAwB,EAAA;YAAA,CAC3D;YACA,cAAgB,EAAA;gBACZ,MAAM,OAAQ,CAAA,IAAA;YAAA,CAClB;YACA,iBAAmB,EAAA,OAAA;YACnB,aAAe,EAAA,OAAA;QAAA,CACnB,CAAA;QAEA,IAAI,WAAW,OAAQ,CAAA,QAAA,CAAA;QACvB,IAAI,SAAS,OAAQ,CAAA,MAAA,CAAA;QAErB,MAAA,CAAO,IAAK,CAAA,SAAS,CAAE,CAAA,OAAA,CAAQ,CAAC,UAChC,KAAA;YACU,MAAA,cAAA,GAAiB,mBAAA,CAAoB,UAA8C,CAAA,CAAA;YAEzF,QAAA,GAAW,SAAU,CAAA,UAAU,CAAE,CAAA,QAAA,EAAU,gBAAgB,IAAI,CAAA,CAAA;YAC/D,MAAA,GAAS,SAAU,CAAA,UAAU,CAAE,CAAA,MAAA,EAAQ,gBAAgB,KAAK,CAAA,CAAA;QAAA,CAC/D,CAAA,CAAA;QAED,IAAA,CAAK,QAAW,GAAA,QAAA,CAAA;QAChB,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;QAEd,IAAA,CAAK,yBAAA,GAA4B,OAAQ,CAAA,yBAAA,CAAA;QAEpC,IAAA,CAAA,IAAA,OAAO,sRAAA,EAAmB,AAAG,GAAe,OAAf,IAAA,CAAK,MAAM,EAAI,CAAA,IAAa,CAAA,UAAb,CAAK,QAAQ,GAAI,YAAY,CAAA,CAAA;IAAA,CAClF;AAoCJ,CAAA,CAAA;AAAA,6CAAA,GAxHa,UAAA,CAGK,cAA4C,GAAA;IACtD,wBAA0B,EAAA,OAAA;IAC1B,0BAA4B,EAAA,SAAA;AAChC,CAAA,CAAA;AANG,IAAM,SAAN,GAAA","debugId":null}},
    {"offset": {"line": 3600, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts"],"sourcesContent":["import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\n/**\n * @param format\n * @internal\n */\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3767, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts"],"sourcesContent":["import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\n/**\n * @param root0\n * @param root0.source\n * @param root0.entryPoint\n * @internal\n */\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n"],"names":[],"mappings":";;;;;;;AAMA,MAAM,oBAAqD,GAAA;IAEvD,GAAM,EAAA,SAAA;IACN,WAAa,EAAA,WAAA;IACb,WAAa,EAAA,WAAA;IACb,WAAa,EAAA,WAAA;IACb,KAAO,EAAA,WAAA;IACP,KAAO,EAAA,WAAA;IACP,KAAO,EAAA,WAAA;IAEP,GAAK,EAAA,QAAA;IACL,WAAa,EAAA,UAAA;IACb,WAAa,EAAA,UAAA;IACb,WAAa,EAAA,UAAA;IAEb,GAAK,EAAA,QAAA;IACL,WAAa,EAAA,UAAA;IACb,WAAa,EAAA,UAAA;IACb,WAAa,EAAA,UAAA;IAEb,IAAM,EAAA,QAAA;IACN,YAAc,EAAA,UAAA;IACd,YAAc,EAAA,UAAA;IACd,YAAc,EAAA,UAAA;AAClB,CAAA,CAAA;AAQO,SAAS,+BACZ,MAEJ,EAAA;UAFM,MAAQ,EAAA,UAAA,KAAV;IAGA,MAAM,UAAkD,CAAA,CAAC,CAAA;IAGzD,MAAM,aAAgB,GAAA,MAAA,CAAO,OAAQ,CAAA,GAAA,GAAkB,CAAA,CAAA,CAAA,IAAZ,UAAU;IAErD,IAAI,kBAAkB,CACtB,CAAA,EAAA;QAEI,MAAM,kBAAqB,GAAA,MAAA,CAAO,OAAQ,CAAA,IAAA,EAAM,aAAa,CAAA,CAAA;QAE7D,IAAI,uBAAuB,CAC3B,CAAA,EAAA;YACI,MAAM,qBAAwB,GAAA,MAAA,CAAO,SAAU,CAAA,aAAA,EAAe,kBAAkB,CAAA,CAAA;YAGhF,MAAM,WAAc,GAAA,yEAAA,CAAA;YAChB,IAAA,KAAA,CAAA;YAEJ,MAAA,CAAQ,KAAQ,GAAA,WAAA,CAAY,IAAK,CAAA,qBAAqB,CAAA,MAAO,IAC7D,CAAA;oBACmB;gBAAf,MAAM,MAAS,uDAAA,CAAqB,KAAM,CAAA,CAAC,CAAiB,CAAK,uFAAA,SAAA,CAAA;gBAEzD,OAAA,CAAA,KAAA,CAAM,CAAC,CAAC,CAAI,GAAA;oBAChB,QAAU,EAAA,QAAA,CAAS,KAAM,CAAA,CAAC,CAAA,EAAG,EAAE,CAAA;oBAC/B,MAAA;oBACA,MAAA,MAAQ,kTAA2B,EAAA,MAAM,CAAE,CAAA,MAAA;oBAC3C,MAAQ,EAAA,CAAA;oBACR,QAAU,EAAA,KAAA;oBACV,KAAO,EAAA,CAAA;gBAAA,CACX,CAAA;YAAA,CACJ;QAAA,CACJ;IAAA,CACJ;IAEO,OAAA,OAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 3827, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts"],"sourcesContent":["/**\n * Defines the structure of the extracted WGSL structs and groups.\n * @category rendering\n * @advanced\n */\nexport interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\n/**\n * @param wgsl\n * @internal\n */\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n"],"names":["name"],"mappings":";;;;;AAwBO,SAAS,uBAAuB,IACvC,EAAA;QAYmB,IAAK;IAVpB,MAAM,WAAc,GAAA,wCAAA,CAAA;IACpB,MAAM,YAAe,GAAA,iBAAA,CAAA;IACrB,MAAM,cAAiB,GAAA,mBAAA,CAAA;IACvB,MAAM,WAAc,GAAA,qBAAA,CAAA;IACpB,MAAM,WAAc,GAAA,WAAA,CAAA;IACpB,MAAM,aAAgB,GAAA,6BAAA,CAAA;IACtB,MAAM,mBAAsB,GAAA,0BAAA,CAAA;IAC5B,MAAM,UAAa,GAAA,gBAAA,CAAA;IAGnB,MAAM,6BAAc,KAAA,CAAM,WAAW,CAAG,4DAAA,GAAA,CAAI,CAAC,IAAU,GAAA,CAAA;YACnD,KAAA,EAAO,SAAS,IAAK,CAAA,KAAA,CAAM,YAAY,CAAE,CAAA,CAAC,CAAA,EAAG,EAAE,CAAA;YAC/C,OAAA,EAAS,SAAS,IAAK,CAAA,KAAA,CAAM,cAAc,CAAE,CAAA,CAAC,CAAA,EAAG,EAAE,CAAA;YACnD,IAAM,EAAA,IAAA,CAAK,KAAM,CAAA,WAAW,CAAA,CAAE,CAAC,CAAA;YAC/B,WAAW,IAAK,CAAA,KAAA,CAAM,WAAW,CAAA,CAAE,CAAC,CAAM,KAAA,WAAA;YAC1C,IAAM,EAAA,IAAA,CAAK,KAAM,CAAA,WAAW,CAAA,CAAE,CAAC,CAAA;QAAA,CACjC,CAAA,CAAA,CAAA;IAEF,IAAI,CAAC,MACL,EAAA;QACW,OAAA;YACH,QAAQ,EAAC;YACT,SAAS,EAAC;QAAA,CACd,CAAA;IAAA,CACJ;;IAGA,MAAM,yDACD,KAAA,CAAM,aAAa,CAClB,8DAAA,GAAA,CAAI,CAAC,MACP,KAAA;QACI,MAAM,IAAO,GAAA,MAAA,CAAO,KAAM,CAAA,UAAU,CAAA,CAAE,CAAC,CAAA,CAAA;QACjC,MAAA,OAAA,GAAU,OAAO,KAAM,CAAA,mBAAmB,EAAE,MAAO,CAAA,CAAC,KAA6B,MACvF,KAAA;YACI,MAAM,CAACA,KAAM,EAAA,IAAI,CAAI,GAAA,MAAA,CAAO,KAAA,CAAM,GAAG,CAAA,CAAA;YAErC,GAAA,CAAIA,KAAK,CAAA,IAAA,EAAM,CAAA,GAAI,KAAK,IAAK,EAAA,CAAA;YAEtB,OAAA,GAAA,CAAA;QAAA,CACX,EAAG,CAAA,CAAE,CAAA,CAAA;QAEL,IAAI,CAAC,OACL,EAAA;YACW,OAAA,IAAA,CAAA;QAAA,CACX;QAEO,OAAA;YAAE;YAAM,OAAQ;QAAA,CAAA,CAAA;IAAA,CAE1B,CACA,CAAA,MAAA,CAAO;YAAC,EAAE,IAAA,EAAW;eAAA,MAAA,CAAO,IAAK,CAAA,CAAC,QAAU,KAAM,CAAA,IAAA,KAAS,IAAI,CAAC;wDAtBrD,IACX,qBAqBqE,EAAC,CAAA;IAEpE,OAAA;QACH,MAAA;QACA,OAAA;IAAA,CACJ,CAAA;AACJ","debugId":null}},
    {"offset": {"line": 3885, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/shader/const.ts"],"sourcesContent":["/** @internal */\nexport enum ShaderStage\n{\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n"],"names":["ShaderStage"],"mappings":";;;;;AACY,IAAA,WAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,YAAL,KAAA;IAEHA,YAAAA,CAAAA,YAAAA,CAAA,SAAA,GAAS,CAAT,CAAA,GAAA,QAAA,CAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,WAAA,GAAW,CAAX,CAAA,GAAA,UAAA,CAAA;IACAA,YAAAA,CAAAA,YAAAA,CAAA,UAAA,GAAU,CAAV,CAAA,GAAA,SAAA,CAAA;IAJQA,OAAAA,YAAAA,CAAAA;AAAA,CAAA,EAAA,WAAA,IAAA,CAAA,CAAA","debugId":null}},
    {"offset": {"line": 3902, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts"],"sourcesContent":["import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\n/**\n * @param root0\n * @param root0.groups\n * @internal\n */\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n"],"names":[],"mappings":";;;;;;;AAUgB,SAAA,uBAAA;UAA0B,MAAA,EAC1C,EAAA,CADwC;IAEpC,MAAM,SAA2C,EAAC,CAAA;IAElD,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,CAAO,MAAA,EAAQ,CACnC,EAAA,CAAA;QACU,MAAA,KAAA,GAAQ,MAAA,CAAO,CAAC,CAAA,CAAA;QAEtB,IAAI,CAAC,MAAA,CAAO,KAAM,CAAA,KAAK,CACvB,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,GAAI,EAAC,CAAA;QAAA,CAC3B;QAEA,IAAI,MAAM,SACV,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,CAAE,IAAK,CAAA;gBACrB,SAAS,KAAM,CAAA,OAAA;gBACf,UAAA,EAAY,mQAAY,CAAA,MAAA,GAAS,mQAAY,CAAA,QAAA;gBAC7C,MAAQ,EAAA;oBACJ,IAAM,EAAA,SAAA;gBAAA,CACV;YAAA,CACH,CAAA,CAAA;QAAA,CACL,MAAA,IACS,KAAM,CAAA,IAAA,KAAS,SACxB,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,CAAE,IAAK,CAAA;gBACrB,SAAS,KAAM,CAAA,OAAA;gBACf,YAAY,mQAAY,CAAA,QAAA;gBACxB,OAAS,EAAA;oBACL,IAAM,EAAA,WAAA;gBAAA,CACV;YAAA,CACH,CAAA,CAAA;QAAA,CACL,MAAA,IACS,KAAM,CAAA,IAAA,KAAS,YACxB,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,CAAE,IAAK,CAAA;gBACrB,SAAS,KAAM,CAAA,OAAA;gBACf,YAAY,mQAAY,CAAA,QAAA;gBACxB,OAAS,EAAA;oBACL,UAAY,EAAA,OAAA;oBACZ,aAAe,EAAA,IAAA;oBACf,YAAc,EAAA,KAAA;gBAAA,CAClB;YAAA,CACH,CAAA,CAAA;QAAA,CACL;IAAA,CACJ;IAEO,OAAA,MAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 3953, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts"],"sourcesContent":["import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\n/**\n * @param root0\n * @param root0.groups\n * @internal\n */\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n"],"names":[],"mappings":";;;;;AAQgB,SAAA,kBAAA;UAAqB,MAAA,EACrC,EAAA,CADmC;IAE/B,MAAM,SAAwB,EAAC,CAAA;IAE/B,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,MAAA,CAAO,MAAA,EAAQ,CACnC,EAAA,CAAA;QACU,MAAA,KAAA,GAAQ,MAAA,CAAO,CAAC,CAAA,CAAA;QAEtB,IAAI,CAAC,MAAA,CAAO,KAAM,CAAA,KAAK,CACvB,EAAA;YACW,MAAA,CAAA,KAAA,CAAM,KAAK,CAAA,GAAI,CAAA,CAAC,CAAA;QAAA,CAC3B;QAEA,MAAA,CAAO,MAAM,KAAK,CAAA,CAAE,KAAM,CAAA,IAAI,CAAA,GAAI,KAAM,CAAA,OAAA,CAAA;IAAA,CAC5C;IAEO,OAAA,MAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 3976, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts"],"sourcesContent":["import type { StructsAndGroups } from './extractStructAndGroups';\n\n/**\n * @param vertexStructsAndGroups\n * @param fragmentStructsAndGroups\n * @internal\n */\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n"],"names":[],"mappings":";;;;;AAOgB,SAAA,8BAAA,CACZ,sBAAA,EACA,wBAEJ,EAAA;IACU,MAAA,aAAA,GAAA,aAAA,GAAA,IAAoB,GAAI,EAAA,CAAA;IACxB,MAAA,eAAA,GAAA,aAAA,GAAA,IAAsB,GAAI,EAAA,CAAA;IAE1B,MAAA,OAAA,GAAU,CAAC;WAAG,sBAAuB,CAAA,OAAA,EAAS;WAAG,wBAAA,CAAyB,OAAO;KAAA,CAClF,MAAO,CAAA,CAAC,MACT,KAAA;QACI,IAAI,aAAc,CAAA,GAAA,CAAI,MAAO,CAAA,IAAI,CACjC,EAAA;YACW,OAAA,KAAA,CAAA;QAAA,CACX;QACc,aAAA,CAAA,GAAA,CAAI,OAAO,IAAI,CAAA,CAAA;QAEtB,OAAA,IAAA,CAAA;IAAA,CACV,CAAA,CAAA;IAEC,MAAA,MAAA,GAAS,CAAC;WAAG,sBAAuB,CAAA,MAAA,EAAQ;WAAG,wBAAA,CAAyB,MAAM;KAAA,CAC/E,MAAO,CAAA,CAAC,KACT,KAAA;QACI,MAAM,MAAM,AAAG,GAAc,OAAd,KAAA,CAAM,IAAI,EAAA,CAAA,IAAiB,CAAA,CAAA,WAAP,OAAO;QAEtC,IAAA,eAAA,CAAgB,GAAI,CAAA,GAAG,CAC3B,EAAA;YACW,OAAA,KAAA,CAAA;QAAA,CACX;QACA,eAAA,CAAgB,GAAA,CAAI,GAAG,CAAA,CAAA;QAEhB,OAAA,IAAA,CAAA;IAAA,CACV,CAAA,CAAA;IAEE,OAAA;QAAE;QAAS,MAAO;IAAA,CAAA,CAAA;AAC7B","debugId":null}},
    {"offset": {"line": 4016, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts"],"sourcesContent":["import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is laid out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @category rendering\n * @advanced\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @category rendering\n * @advanced\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @category rendering\n * @advanced\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @category rendering\n * @advanced\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @category rendering\n * @advanced\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /** @internal */\n    public _layoutKey = 0;\n    /** @internal */\n    public _cacheKey: string;\n\n    /** @internal */\n    public _attributeLocationsKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n        programCache[this._cacheKey] = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n            programCache[key]._cacheKey = key;\n        }\n\n        return programCache[key];\n    }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4100, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts"],"sourcesContent":["import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n * @internal\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n"],"names":[],"mappings":";;;;;;;AASgB,SAAA,OAAA,CAAQ,QAAkC,EAAA,KAAA,EAAiC,IAC3F,EAAA;IACI,IAAI,QACJ,EAAA;QACI,IAAA,MAAW,KAAK,QAChB,CAAA;YACU,MAAA,EAAA,GAAK,EAAE,iBAAkB,EAAA,CAAA;YAEzB,MAAA,IAAA,GAAO,KAAA,CAAM,EAAE,CAAA,CAAA;YAErB,IAAI,IACJ,EAAA;gBACQ,IAAA,aAAA,GAAgB,QAAA,CAAS,CAAC,CAAA,CAAA;gBAE9B,IAAI,MAAM,QACV,EAAA;oBACI,aAAA,GAAgB,cACX,OAAQ,CAAA,kBAAA,EAAoB,EAAE,CAC9B,CAAA,OAAA,CAAQ,qBAAqB,EAAE,CAAA,CAAA;gBAAA,CACxC;gBAEA,IAAI,IACJ,EAAA;oBACS,IAAA,CAAA,IAAA,CAAK,AAAS,MAAA,UAAA,IAAI,EAAQ,MAAA,CAAA,CAAA,CAAA;gBAAA,CACnC;gBACA,IAAA,CAAK,IAAA,CAAK,aAAa,CAAA,CAAA;YAAA,CAI3B,MAAA;oBAES,iOAAA,EAAA,UAAG,CAAC,EAA0C,wCAAA,CAAA,CAAA,CAAA;YAAA,CAEvD;QAAA,CACJ;IAAA,CACJ;AACJ","debugId":null}},
    {"offset": {"line": 4133, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts"],"sourcesContent":["const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n * @internal\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n"],"names":[],"mappings":";;;;;AAAA,MAAM,WAAc,GAAA,gBAAA,CAAA;AAOb,SAAS,aAAa,UAC7B,EAAA;;IACI,MAAM,QAAkC,CAAA,CAAC,CAAA;QAErB,UAAA;IAApB,MAAM,WAAc,4DACf,KAAM,CAAA,WAAW,yEAChB,GAAI,CAAA,CAAC,IAAS,GAAA,IAAA,CAAK,OAAQ,CAAA,SAAA,EAAW,EAAE,CAAC,0EAAK,EAAC,CAAA;IAEzC,WAAA,CAAA,OAAA,CAAQ,CAAC,IACrB,KAAA;QACU,KAAA,CAAA,IAAI,CAAA,GAAI,EAAC,CAAA;IAAA,CAClB,CAAA,CAAA;IAEM,OAAA,KAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 4155, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts"],"sourcesContent":["function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\n/**\n * @param fragments\n * @param template\n * @param sort\n * @internal\n */\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,aAAA,CAAc,cAAA,EAAwB,GAC/C,EAAA;IACQ,IAAA,KAAA,CAAA;IACJ,MAAM,KAAQ,GAAA,iBAAA,CAAA;IAEd,MAAA,CAAQ,KAAQ,GAAA,KAAA,CAAM,IAAK,CAAA,cAAc,CAAA,MAAO,IAChD,CAAA;QACQ,GAAA,CAAA,IAAA,CAAK,KAAM,CAAA,CAAC,CAAC,CAAA,CAAA;IAAA,CACrB;AACJ,CAAA;AAQO,SAAS,aAAc,CAAA,SAAA,EAAkB,QAAkB;eAAA,IAAA,6DAAO,KACzE,EAAA;IAEI,MAAM,UAAoB,EAAC,CAAA;IAE3B,aAAA,CAAc,UAAU,OAAO,CAAA,CAAA;IAErB,SAAA,CAAA,OAAA,CAAQ,CAAC,QACnB,KAAA;QACI,IAAI,SAAS,MACb,EAAA;YACkB,aAAA,CAAA,QAAA,CAAS,MAAA,EAAQ,OAAO,CAAA,CAAA;QAAA,CAC1C;IAAA,CACH,CAAA,CAAA;IAGD,MAAM,SAAY,GAAA,OAAA,CAAA;IAElB,IAAI,IACJ,EAAA;QACI,SAAA,CAAU,IAAK,EAAA,CAAA;IAAA,CACnB;IAEA,MAAM,WAAc,GAAA,SAAA,CACf,GAAI,CAAA,CAAC,OAAS,EAAA,CAAA,GAAM,AAAoB,iBAAA,UAAA,CAAC,EAAK,EAAA,WAAA,OAAO,EAAG,CAAA,CAAA,CAAA,GACxD,IAAA,CAAK,IAAI,CAAA,CAAA;IAGd,IAAI,aAAgB,GAAA,QAAA,CAAS,OAAQ,CAAA,kBAAA,EAAoB,EAAE,CAAA,CAAA;IAE3C,aAAA,GAAA,aAAA,CAAc,OAAA,CAAQ,QAAU,EAAA,YAAK,WAAW,EAAA;IAEzD,OAAA,aAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 4191, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts"],"sourcesContent":["function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\n/**\n * @param fragments\n * @param template\n * @internal\n */\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n            ${results\n                .sort()\n                .map((inValue) => ` ${extractVariableName(inValue)}`)\n                .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n"],"names":[],"mappings":";;;;;AAAA,SAAS,cAAA,CAAe,cAAA,EAAwB,GAChD,EAAA;IACQ,IAAA,KAAA,CAAA;IACJ,MAAM,KAAQ,GAAA,kBAAA,CAAA;IAEd,MAAA,CAAQ,KAAQ,GAAA,KAAA,CAAM,IAAK,CAAA,cAAc,CAAA,MAAO,IAChD,CAAA;QACQ,GAAA,CAAA,IAAA,CAAK,KAAM,CAAA,CAAC,CAAC,CAAA,CAAA;IAAA,CACrB;AACJ,CAAA;AAEA,SAAS,oBAAoB,KAC7B,EAAA;IACI,MAAM,KAAQ,GAAA,cAAA,CAAA;IAER,MAAA,KAAA,GAAQ,KAAM,CAAA,IAAA,CAAK,KAAK,CAAA,CAAA;IAEvB,OAAA,KAAA,GAAQ,KAAM,CAAA,CAAC,CAAI,GAAA,EAAA,CAAA;AAC9B,CAAA;AAEA,SAAS,cAAc,KACvB,EAAA;IACI,MAAM,KAAQ,GAAA,UAAA,CAAA;IAEP,OAAA,KAAA,CAAM,OAAQ,CAAA,KAAA,EAAO,EAAE,CAAA,CAAA;AAClC,CAAA;AAOgB,SAAA,cAAA,CAAe,SAAA,EAAkB,QACjD,EAAA;IAEI,MAAM,UAAoB,EAAC,CAAA;IAE3B,cAAA,CAAe,UAAU,OAAO,CAAA,CAAA;IAEtB,SAAA,CAAA,OAAA,CAAQ,CAAC,QACnB,KAAA;QACI,IAAI,SAAS,MACb,EAAA;YACmB,cAAA,CAAA,QAAA,CAAS,MAAA,EAAQ,OAAO,CAAA,CAAA;QAAA,CAC3C;IAAA,CACH,CAAA,CAAA;IAED,IAAI,KAAQ,GAAA,CAAA,CAAA;IAGZ,MAAM,aAAa,OACd,CAAA,IAAA,EACA,CAAA,GAAA,CAAI,CAAC,OACN,KAAA;QACI,IAAI,OAAQ,CAAA,OAAA,CAAQ,SAAS,CAAA,GAAI,CACjC,CAAA,EAAA;YACW,OAAA,OAAA,CAAA;QAAA,CACX;QAEO,OAAA,UAAA,UAAa,KAAO,EAAA,EAAA,EAAA,IAAY,CAAA,CAAA,KAAP,OAAO;IAAA,CAC1C,CACA,CAAA,IAAA,CAAK,KAAK,CAAA,CAAA;IAGf,MAAM,SAAY,GAAA,OAAA,CACb,IAAK,EAAA,CACL,GAAA,CAAI,CAAC,OAAA,GAAY,AAAc,WAAA,UAAA,aAAA,CAAc,OAAO,CAAC,EAAG,CAAA,CAAA,CAAA,GACxD,IAAA,CAAK,IAAI,CAAA,CAAA;IAGd,MAAM,OAAU,GAAA,iCAIQ,EAAA,CAAA,CAAA,GAHd,OACG,CAAA,IAAA,EACA,CAAA,GAAA,CAAI,CAAC,OAAY,GAAA,CAAA,GAAgC,CAAE,CACnD,KADqB,mBAAoB,CAAA,OAAO,CAAC,GACjD,IAAA,CAAK,KAAK,CAAC;IAGxB,IAAI,YAAe,GAAA,QAAA,CAAS,OAAQ,CAAA,mBAAA,EAAqB,EAAE,CAAA,CAAA;IAE5C,YAAA,GAAA,YAAA,CAAa,OAAA,CAAQ,YAAc,EAAA,YAAK,UAAU,EAAA;IAClD,YAAA,GAAA,YAAA,CAAa,OAAA,CAAQ,WAAa,EAAA,YAAK,SAAS,EAAA;IAChD,YAAA,GAAA,YAAA,CAAa,OAAA,CAAQ,YAAc,EAAA,YAAK,OAAO,EAAA;IAEvD,OAAA,YAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 4241, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts"],"sourcesContent":["/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n * @internal\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n"],"names":[],"mappings":";;;;;AAMgB,SAAA,UAAA,CAAW,WAAA,EAAqB,aAChD,EAAA;IACI,IAAI,GAAM,GAAA,WAAA,CAAA;IAEV,IAAA,MAAW,KAAK,aAChB,CAAA;QACU,MAAA,KAAA,GAAQ,aAAA,CAAc,CAAC,CAAA,CAAA;QAEvB,MAAA,QAAA,GAAW,KAAM,CAAA,IAAA,CAAK,IAAI,CAAA,CAAA;QAEhC,IAAI,SAAS,MACb,EAAA;YACI,GAAA,GAAM,IAAI,OAAQ,CAAA,EAAA,GAAM,EAAA,CAAA,IAAD,CAAC,SAAM,iBAAU,CAAC,EAAA,0BAAkB,KAAA,CAAM,IAAK,CAAA,IAAI,CAAC,EAAA,mBAAW,CAAC,EAAe,aAAA,CAAA,CAAA,CAAA;QAAA,CAI1G,MAAA;YACI,GAAA,GAAM,GAAI,CAAA,OAAA,CAAQ,AAAK,EAAA,GAAC,OAAD,CAAC,EAAA,OAAM,EAAE,CAAA,CAAA;QAAA,CACpC;IAAA,CACJ;IAEO,OAAA,GAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 4265, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts"],"sourcesContent":["import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/**\n * A high template consists of vertex and fragment source\n * @internal\n */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\n/** @internal */\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n * @internal\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * It is specifically for WebGL and does not compile inputs and outputs.\n * @param options\n * @param options.template - The HighShader template containing vertex and fragment source.\n * @param options.bits - An array of HighShaderBit objects to be compiled into the shader.\n * @returns A HighShaderSource object containing the compiled vertex and fragment shaders.\n * @internal\n */\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4337, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts"],"sourcesContent":["/** @ignore */\nconst vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n\n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\n/** @ignore */\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n\n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n\n        {{start}}\n\n        var outColor:vec4<f32>;\n\n        {{main}}\n\n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`;\n\n/** @ignore */\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n\n        {{start}}\n\n        vColor = vec4(1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\n/** @ignore */\nconst fragmentGlTemplate = /* glsl */`\n\n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n\n        {{start}}\n\n        vec4 outColor;\n\n        {{main}}\n\n        finalColor = outColor * vColor;\n\n        {{end}}\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n"],"names":[],"mappings":";;;;;;;;;;;AACM,MAAA,iBAAA,GAA8B;AA+C9B,MAAA,mBAAA,GAAgC;AA0BhC,MAAA,gBAAA,GAA6B;AAuC7B,MAAA,kBAAA,GAA+B","debugId":null}},
    {"offset": {"line": 4358, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts"],"sourcesContent":["/** @internal */\nexport const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\n/** @internal */\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\n/** @internal */\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n"],"names":[],"mappings":";;;;;;;;;AACO,MAAM,iBAAoB,GAAA;IAC7B,IAAM,EAAA,qBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAkB;IAAA,CAUtB;AACJ,EAAA;AAGO,MAAM,sBAAyB,GAAA;IAClC,IAAM,EAAA,yBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAkB;IAAA,CAQtB;AACJ,EAAA;AAGO,MAAM,mBAAsB,GAAA;IAC/B,IAAM,EAAA,qBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAkB;IAAA,CAMtB;AAEJ","debugId":null}},
    {"offset": {"line": 4391, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts"],"sourcesContent":["import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\n/**\n * @param root0\n * @param root0.bits\n * @param root0.name\n * @internal\n */\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\n/**\n * @param root0\n * @param root0.bits\n * @param root0.name\n * @internal\n */\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAcO,SAAS,2BAA4B;UAAE,IAAM,EAAA,IAAA,EACpD,EAAA,CAD4C;IAExC,MAAM,aAAS,kRAAkB,EAAA;QAC7B,QAAU,EAAA;YACN,QAAU,EAAA,6QAAA;YACV,MAAQ,EAAA,2QAAA;QAAA,CACZ;QACA,IAAM,EAAA;YACF,wRAAA;eACG,IAAA;SACP;IAAA,CACH,CAAA,CAAA;IAED,OAAO,oQAAA,CAAW,IAAK,CAAA;QACnB,IAAA;QACA,MAAQ,EAAA;YACJ,QAAQ,MAAO,CAAA,MAAA;YACf,UAAY,EAAA,MAAA;QAAA,CAChB;QACA,QAAU,EAAA;YACN,QAAQ,MAAO,CAAA,QAAA;YACf,UAAY,EAAA,MAAA;QAAA,CAChB;IAAA,CACH,CAAA,CAAA;AACL,CAAA;AAQO,SAAS,0BAA2B;UAAE,IAAM,EAAA,IAAA,EACnD,EAAA,CAD2C;IAEvC,OAAO,IAAI,iQAAU,CAAA;QACjB,IAAA;QACA,OAAG,oRAAoB,EAAA;YACnB,QAAU,EAAA;gBACN,MAAQ,EAAA,0QAAA;gBACR,QAAU,EAAA,4QAAA;YAAA,CACd;YACA,IAAM,EAAA;gBACF,0RAAA;mBACG,IAAA;aACP;QAAA,CACH,CAAA;IAAA,CACJ,CAAA,CAAA;AACL","debugId":null}},
    {"offset": {"line": 4454, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts"],"sourcesContent":["/** @internal */\nexport const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\n/** @internal */\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n"],"names":[],"mappings":";;;;;;;AACO,MAAM,QAAW,GAAA;IACpB,IAAM,EAAA,WAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAkB;QAGlB,IAAA,EAAgB;IAAA,CAGpB;AACJ,EAAA;AAGO,MAAM,UAAa,GAAA;IACtB,IAAM,EAAA,WAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAkB;QAGlB,IAAA,EAAgB;IAAA,CAGpB;AACJ","debugId":null}},
    {"offset": {"line": 4481, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts"],"sourcesContent":["import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\n/**\n * @param maxTextures\n * @internal\n */\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\n/**\n * @param maxTextures\n * @internal\n */\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n                main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4578, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts"],"sourcesContent":["/** @internal */\nexport const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n/** @internal */\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`\n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n"],"names":[],"mappings":";;;;;;;AACO,MAAM,cAAiB,GAAA;IAC1B,IAAM,EAAA,kBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAkB;IAAA,CAMtB;AACJ,EAAA;AAGO,MAAM,gBAAmB,GAAA;IAC5B,IAAM,EAAA,kBAAA;IACN,MAAQ,EAAA;QACJ,MAAA,EAAkB;IAAA,CAMtB;AACJ","debugId":null}},
    {"offset": {"line": 4603, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/shader/types.ts"],"sourcesContent":["// TODO add more types as required\n/** @internal */\nexport const UNIFORM_TYPES_VALUES = [\n    'f32',\n    'i32',\n    'vec2<f32>',\n    'vec3<f32>',\n    'vec4<f32>',\n    'mat2x2<f32>',\n    'mat3x3<f32>',\n    'mat4x4<f32>',\n    'mat3x2<f32>',\n    'mat4x2<f32>',\n    'mat2x3<f32>',\n    'mat4x3<f32>',\n    'mat2x4<f32>',\n    'mat3x4<f32>',\n    'vec2<i32>',\n    'vec3<i32>',\n    'vec4<i32>',\n] as const;\n\n/**\n * useful for checking if a type is supported - a map of supported types with a true value.\n * @internal\n */\nexport const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) =>\n{\n    acc[type] = true;\n\n    return acc;\n}, {} as Record<UNIFORM_TYPES, boolean>);\n\n/** @internal */\nexport type UNIFORM_TYPES_SINGLE = typeof UNIFORM_TYPES_VALUES[number];\n\ntype OPTIONAL_SPACE = ' ' | '';\n\n/** @internal */\nexport type UNIFORM_TYPES_ARRAY = `array<${UNIFORM_TYPES_SINGLE},${OPTIONAL_SPACE}${number}>`;\n\n/** @internal */\nexport type UNIFORM_TYPES = UNIFORM_TYPES_SINGLE | UNIFORM_TYPES_ARRAY;\n\n/**\n * This is the type of the uniform structures that are used in the UniformGroup.\n * @category rendering\n * @advanced\n */\nexport interface UniformData\n{\n    /** the value of the uniform, this could be any object - a parser will figure out how to write it to the buffer */\n    value: unknown;\n    type: UNIFORM_TYPES;\n    /** the size of the variable (eg 2 for vec2, 3 for vec3, 4 for vec4) */\n    size?: number;\n    name?: string;\n}\n\n/** @internal */\nexport interface UboElement\n{\n    data: UniformData;\n    offset: number;\n    size: number;\n}\n\n/** @internal */\nexport interface UboLayout\n{\n    uboElements: UboElement[];\n    /** float32 size // TODO change to bytes */\n    size: number;\n}\n\n/** @internal */\nexport type UniformsSyncCallback = (...args: any[]) => void;\n"],"names":[],"mappings":";;;;;;;AAEO,MAAM,oBAAuB,GAAA;IAChC,KAAA;IACA,KAAA;IACA,WAAA;IACA,WAAA;IACA,WAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,aAAA;IACA,WAAA;IACA,WAAA;IACA,WAAA;CACJ,CAAA;AAMO,MAAM,iBAAoB,GAAA,oBAAA,CAAqB,MAAO,CAAA,CAAC,KAAK,IACnE,KAAA;IACI,GAAA,CAAI,IAAI,CAAI,GAAA,IAAA,CAAA;IAEL,OAAA,GAAA,CAAA;AACX,CAAA,EAAG,CAAA,CAAoC","debugId":null}},
    {"offset": {"line": 4639, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts"],"sourcesContent":["/**\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n"],"names":[],"mappings":";;;;;AAKgB,SAAA,sBAAA,CACZ,IAAA,EACA,IAEJ,EAAA;IACI,OAAQ,IACR;QACI,KAAK,KAAA;YACM,OAAA,CAAA,CAAA;QAEX,KAAK,WAAA;YACM,OAAA,IAAI,YAAa,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAEpC,KAAK,WAAA;YACM,OAAA,IAAI,YAAa,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QAEpC,KAAK,WAAA;YACM,OAAA,IAAI,YAAa,CAAA,CAAA,GAAI,IAAI,CAAA,CAAA;QACpC,KAAK,aAAA;YACD,OAAO,IAAI,YAAa,CAAA;gBAAC,CAAA;gBAAG,CAAA;gBACxB,CAAA;gBAAG,CAAA;aAAE,CAAA,CAAA;QAEb,KAAK,aAAA;YACD,OAAO,IAAI,YAAa,CAAA;gBAAC,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAC3B,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBACN,CAAA;gBAAG,CAAA;gBAAG,CAAA;aAAE,CAAA,CAAA;QAEhB,KAAK,aAAA;YACD,OAAO,IAAI,YAAa,CAAA;gBAAC,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAC9B,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBACT,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBACT,CAAA;gBAAG,CAAA;gBAAG,CAAA;gBAAG,CAAA;aAAE,CAAA,CAAA;IAAA,CACvB;IAEO,OAAA,IAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 4701, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/shader/UniformGroup.ts"],"sourcesContent":["import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, type UniformData } from './types';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n/**\n * Extracts the value type from a uniform data object.\n * @internal\n */\nexport type ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @category rendering\n * @advanced\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```ts\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n * ```\n * @category rendering\n * @advanced\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('uniform');\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     */\n    public _resourceType = 'uniformGroup';\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     */\n    public readonly _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n\n            if (!UNIFORM_TYPES_MAP[uniformData.type])\n            {\n                const arrayMatch = uniformData.type.match(/^array<(\\w+(?:<\\w+>)?),\\s*(\\d+)>$/);\n\n                if (arrayMatch)\n                {\n                    const [, innerType, size] = arrayMatch;\n\n                    throw new Error(\n                        `Uniform type ${uniformData.type} is not supported. Use type: '${innerType}', size: ${size} instead.`\n                    );\n                }\n\n                // eslint-disable-next-line max-len\n                throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(', ')}`);\n            }\n\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;AAuFO,MAAM,aAAA,GAAN,MAAM,aACb,CAAA;IA2GI,+GAAA,GAGO,MACP,GAAA;QACS,IAAA,CAAA,QAAA,EAAA,CAAA;IAAA,CAET;IAlHJ;;;;GAAA,GA6DI,WAAA,CAAY,iBAAA,EAA6B,OACzC,CAAA;QAjDA;;;KAAA,GAAA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;QAGlB,iEAAA,GAAgB,IAAA,CAAA,GAAA,OAAc,4NAAA,EAAI,SAAS,CAAA,CAAA;QAK3C;;;KAAA,GAAA,IAAA,CAAO,aAAgB,GAAA,cAAA,CAAA;QAKvB;;;KAAA,GAAO,IAAA,CAAA,WAAA,OAAc,4NAAA,EAAI,UAAU,CAAA,CAAA;QAenC,iDAAA,GAAA,IAAA,CAAgB,cAAiB,GAAA,IAAA,CAAA;QAKjC;;;KAAA,GAAA,IAAA,CAAO,QAAW,GAAA,CAAA,CAAA;QAQlB,8DAAA;QAAA,IAAA,CAAgB,SAAY,GAAA,KAAA,CAAA;QASxB,OAAA,GAAU;YAAE,GAAG,aAAa,CAAA,cAAA;YAAgB,GAAG,OAAQ;QAAA,CAAA,CAAA;QAEvD,IAAA,CAAK,iBAAoB,GAAA,iBAAA,CAAA;QAEzB,MAAM,WAAW,CAAA,CAAC,CAAA;QAElB,IAAA,MAAW,KAAK,iBAChB,CAAA;YACU,MAAA,WAAA,GAAc,iBAAA,CAAkB,CAAC,CAAA,CAAA;YAEvC,WAAA,CAAY,IAAO,GAAA,CAAA,CAAA;;YACP,WAAA,CAAA,IAAA,oCAAmB,IAAQ,6CAApB,oBAAoB,CAAA,CAAA;YAEvC,IAAI,CAAC,yQAAA,CAAkB,WAAY,CAAA,IAAI,CACvC,EAAA;gBACI,MAAM,UAAa,GAAA,WAAA,CAAY,IAAK,CAAA,KAAA,CAAM,mCAAmC,CAAA,CAAA;gBAE7E,IAAI,UACJ,EAAA;oBACI,MAAM,GAAG,SAAW,EAAA,IAAI,CAAI,GAAA,UAAA,CAAA;oBAE5B,MAAM,IAAI,KAAA,CACN,gBAAiE,OAAjD,EAA0D,SAA9C,CAAA,IAAI,EAAiC,8BAAA,sBAAS,oBAAY,IAAI,EAAA,SAAA,CAAA;gBAC9F,CACJ;gBAGM,MAAA,IAAI,KAAM,CAAA,aAAA,UAAgB,WAAY,CAAA,IAAI,EAAA,oDAAoF,CAAA,CAAA,CAAA,IAAjC,4QAAqB,CAAA,IAAA,CAAK,IAAI,CAAC;YAAE,CACxI;;8CAEY,KAAA,8CAAZ,WAAA,UAAA,WAAY,CAAA,KAAA,OAAU,wSAAA,EAAuB,WAAY,CAAA,IAAA,EAAM,YAAY,IAAI,CAAA,CAAA,CAAA;YAEtE,QAAA,CAAA,CAAC,CAAA,GAAI,WAAY,CAAA,KAAA,CAAA;QAAA,CAC9B;QAEA,IAAA,CAAK,QAAW,GAAA,QAAA,CAAA;QAEhB,IAAA,CAAK,QAAW,GAAA,CAAA,CAAA;QAChB,IAAA,CAAK,GAAA,GAAM,OAAQ,CAAA,GAAA,CAAA;QACnB,IAAA,CAAK,QAAA,GAAW,OAAQ,CAAA,QAAA,CAAA;QAExB,IAAA,CAAK,UAAa,OAAA,sRAAA,EAAmB,MAAO,CAAA,IAAA,CAAK,QAAQ,CAAE,CAAA,GAAA,CACvD,CAAC,IAAM,AAAG,UAAA,CAAC,EAAA,KAAgF,CAAA,MAA3E,iBAAkB,CAAA,CAAmC,CAAA,CAAkB,IAAI,GAC7F,IAAA,CAAK,GAAG,CAAA,EAAG,eAAe,CAAA,CAAA;IAAA,CAChC;AAQJ,CAAA,CAAA;AAAA,mDAAA,GApHa,aAAA,CAGK,cAAsC,GAAA;IAAA,qEAAA,GAEhD,GAAK,EAAA,KAAA;IAAA,qGAAA,GAEL,QAAU,EAAA,KAAA;AACd,CAAA,CAAA;AARG,IAAM,YAAN,GAAA","debugId":null}},
    {"offset": {"line": 4784, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.ts"],"sourcesContent":["import { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst batchSamplersUniformGroupHash: Record<number, UniformGroup> = {};\n\n/**\n * Automatically generates a uniform group that holds the texture samplers for a shader.\n * This is used mainly by the shaders that batch textures!\n * @param maxTextures - the number of textures that this uniform group will contain.\n * @returns a uniform group that holds the texture samplers.\n * @internal\n */\nexport function getBatchSamplersUniformGroup(maxTextures: number)\n{\n    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n\n    if (batchSamplersUniformGroup) return batchSamplersUniformGroup;\n\n    const sampleValues = new Int32Array(maxTextures);\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        sampleValues[i] = i;\n    }\n\n    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n        uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n    }, { isStatic: true });\n\n    return batchSamplersUniformGroup;\n}\n"],"names":[],"mappings":";;;;;;;AAEA,MAAM,gCAA8D,CAAA,CAAC,CAAA;AAS9D,SAAS,6BAA6B,WAC7C,EAAA;IACQ,IAAA,yBAAA,GAA4B,6BAAA,CAA8B,WAAW,CAAA,CAAA;IAErE,IAAA,yBAAA,EAAkC,OAAA,yBAAA,CAAA;IAEhC,MAAA,YAAA,GAAe,IAAI,UAAA,CAAW,WAAW,CAAA,CAAA;IAE/C,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,EAAa,CACjC,EAAA,CAAA;QACI,YAAA,CAAa,CAAC,CAAI,GAAA,CAAA,CAAA;IAAA,CACtB;IAEA,yBAAA,GAA4B,6BAA8B,CAAA,WAAW,CAAI,GAAA,IAAI,2QAAa,CAAA;QACtF,WAAW;YAAE,KAAA,EAAO;YAAc,IAAM,EAAA,GAAA,CAAA;YAAO,MAAM,WAAY;QAAA,CAAA;IAAA,CAClE,EAAA;QAAE,QAAU,EAAA,IAAA;IAAA,CAAM,CAAA,CAAA;IAEd,OAAA,yBAAA,CAAA;AACX","debugId":null}},
    {"offset": {"line": 4816, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/types.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/types.ts"],"sourcesContent":["import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/**\n * A generic renderer that can be either a WebGL or WebGPU renderer.\n * @category rendering\n * @extends WebGLRenderer\n * @extends WebGPURenderer\n * @standard\n */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\n/**\n * Generic pipes for the renderer.\n * @category rendering\n * @advanced\n */\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\n/**\n * Options for the renderer.\n * @extends WebGLOptions\n * @extends WebGPUOptions\n * @category rendering\n * @standard\n */\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter whether or not you want to do something\n * in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n * @category rendering\n * @internal\n */\nexport enum RendererType\n{\n    /** The WebGL renderer */\n    WEBGL = 0b01,\n    /** The WebGPU renderer */\n    WEBGPU = 0b10,\n    /** Either WebGL or WebGPU renderer */\n    BOTH = 0b11\n}\n\n/**\n * The GPU power preference for the WebGPU context.\n * This is an optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n *\n * - `'high-performance'` will prioritize rendering performance over power consumption,\n * - `'low-power'` will prioritize power saving over rendering performance.\n * @category rendering\n * @advanced\n */\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n"],"names":["RendererType"],"mappings":";;;;;AAqCY,IAAA,YAAA,GAAA,aAAA,GAAA,CAAA,CAAAA,aAAL,KAAA;IAGHA,aAAAA,CAAAA,aAAAA,CAAA,QAAA,GAAQ,CAAR,CAAA,GAAA,OAAA,CAAA;IAEAA,aAAAA,CAAAA,aAAAA,CAAA,SAAA,GAAS,CAAT,CAAA,GAAA,QAAA,CAAA;IAEAA,aAAAA,CAAAA,aAAAA,CAAA,OAAA,GAAO,CAAP,CAAA,GAAA,MAAA,CAAA;IAPQA,OAAAA,aAAAA,CAAAA;AAAA,CAAA,EAAA,YAAA,IAAA,CAAA,CAAA","debugId":null}},
    {"offset": {"line": 4833, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/shader/Shader.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @category rendering\n * @advanced\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\n/**\n * A base interface for shaders that includes the common properties.\n * @category rendering\n * @advanced\n */\nexport interface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\n/**\n * A base interface for shaders that includes the common properties.\n * @category rendering\n * @advanced\n */\nexport interface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\n/**\n * A descriptor for a shader with groups.\n * This is used to define a shader that uses {@link BindGroup}'s.\n * @category rendering\n * @advanced\n */\nexport interface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @category rendering\n * @advanced\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @category rendering\n * @advanced\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @category rendering\n * @advanced\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\n/**\n * A shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\n/**\n * A descriptor for a shader with resources and groups.\n * @category rendering\n */\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\n/**\n * A descriptor for a shader with groups and resources.\n * @category rendering\n */\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\n/**\n * A descriptor for a shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\n/**\n * A descriptor for a shader that can be used with both WebGL and WebGPU.\n * @category rendering\n * @advanced\n */\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @category rendering\n * @advanced\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** A unique identifier for the shader */\n    public readonly uid: number = uid('shader');\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param options - The options for the shader\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            groups = {};\n            groupMap = {};\n\n            if (gpuProgram)\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            let bindTick = 0;\n\n            for (const i in resources)\n            {\n                if (nameHash[i]) continue;\n\n                // build out a dummy bind group..\n                if (!groups[99])\n                {\n                    groups[99] = new BindGroup();\n                    this._ownedBindGroups.push(groups[99]);\n                }\n                // Yes i know this is a little strange, but wil line up the shaders neatly\n                // basically we want to be driven by how webGPU does things.\n                // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                groupMap[99] = groupMap[99] || {};\n                groupMap[99][bindTick] = i;\n\n                bindTick++;\n            }\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 5022, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/batcher/shared/DefaultShader.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/batcher/shared/DefaultShader.ts"],"sourcesContent":["import { compileHighShaderGlProgram, compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../renderers/shared/shader/Shader';\n\n/**\n * DefaultShader is a specialized shader class designed for batch rendering.\n * It extends the base Shader class and provides functionality for handling\n * color, texture batching, and pixel rounding in both WebGL and WebGPU contexts.\n *\n * It is used by the default batcher\n * @extends Shader\n * @category rendering\n * @advanced\n */\nexport class DefaultShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'batch',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                roundPixelsBitGl,\n            ]\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'batch',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                roundPixelsBit,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAiBO,MAAM,sBAAsB,+PACnC,CAAA;IACI,YAAY,WACZ,CAAA;QACI,MAAM,gBAAY,wRAA2B,EAAA;YACzC,IAAM,EAAA,OAAA;YACN,IAAM,EAAA;gBACF,wQAAA;oBACA,sSAAA,EAA0B,WAAW,CAAA;gBACrC,oRAAA;aACJ;QAAA,CACH,CAAA,CAAA;QAED,MAAM,iBAAa,yRAA4B,EAAA;YAC3C,IAAM,EAAA,OAAA;YACN,IAAM,EAAA;gBACF,sQAAA;oBACA,oSAAA,EAAwB,WAAW,CAAA;gBACnC,kRAAA;aACJ;QAAA,CACH,CAAA,CAAA;QAEK,KAAA,CAAA;YACF,SAAA;YACA,UAAA;YACA,SAAW,EAAA;gBACP,aAAA,MAAe,uSAAA,EAA6B,WAAW,CAAA;YAAA,CAC3D;QAAA,CACH,CAAA,CAAA;IAAA,CACL;AACJ","debugId":null}},
    {"offset": {"line": 5072, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/batcher/shared/DefaultBatcher.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/batcher/shared/DefaultBatcher.ts"],"sourcesContent":["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Batcher } from './Batcher';\nimport { BatchGeometry } from './BatchGeometry';\nimport { DefaultShader } from './DefaultShader';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { BatchableMeshElement, BatchableQuadElement, BatcherOptions } from './Batcher';\n\nlet defaultShader: Shader = null;\n\n/**\n * Represents the common elements for default batch rendering.\n * This interface defines the properties that are used by the DefaultBatcher\n * to render elements efficiently in a batch.\n * @category rendering\n * @advanced\n */\nexport interface DefaultBatchElements\n{\n    /**\n     * The color of the element that will be multiplied with the texture color.\n     * This is typically represented as a 32-bit integer in RGBA format.\n     */\n    color: number;\n\n    /**\n     * Determines whether the element should be rounded to the nearest pixel.\n     * - 0: No rounding (default)\n     * - 1: Round to nearest pixel\n     * This can help with visual consistency, especially for pixel art styles.\n     */\n    roundPixels: 0 | 1;\n\n    /**\n     * The transform matrix of the element.\n     * This matrix represents the position, scale, rotation, and skew of the element.\n     */\n    transform: Matrix;\n}\n\n/**\n * Represents a batchable quad element with default batch properties.\n * @category rendering\n * @advanced\n */\nexport interface DefaultBatchableQuadElement extends BatchableQuadElement, DefaultBatchElements {}\n\n/**\n * Represents a batchable mesh element with default batch properties.\n * @category rendering\n * @advanced\n */\nexport interface DefaultBatchableMeshElement extends BatchableMeshElement, DefaultBatchElements {}\n\n/**\n * The default batcher is used to batch quads and meshes. This batcher will batch the following elements:\n * - tints\n * - roundPixels\n * - texture\n * - transform\n * @category rendering\n * @advanced\n */\nexport class DefaultBatcher extends Batcher\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.Batcher,\n        ],\n        name: 'default',\n    } as const;\n\n    public geometry = new BatchGeometry();\n    public shader: DefaultShader;\n\n    public name = DefaultBatcher.extension.name;\n\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    public vertexSize = 6;\n\n    constructor(options: BatcherOptions)\n    {\n        super(options);\n\n        defaultShader ??= new DefaultShader(options.maxTextures);\n\n        this.shader = defaultShader;\n    }\n\n    /**\n     * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n     * @param element - The DefaultBatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packAttributes(\n        element: DefaultBatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const { positions, uvs } = element;\n\n        const argb = element.color;\n\n        const offset = element.attributeOffset;\n        const end = offset + element.attributeSize;\n\n        for (let i = offset; i < end; i++)\n        {\n            const i2 = i * 2;\n\n            const x = positions[i2];\n            const y = positions[(i2) + 1];\n\n            float32View[index++] = (a * x) + (c * y) + tx;\n            float32View[index++] = (d * y) + (b * x) + ty;\n\n            float32View[index++] = uvs[i2];\n            float32View[index++] = uvs[(i2) + 1];\n\n            uint32View[index++] = argb;\n            uint32View[index++] = textureIdAndRound;\n        }\n    }\n\n    /**\n     * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n     * @param element - The DefaultBatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packQuadAttributes(\n        element: DefaultBatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const texture = element.texture;\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = element.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = element.color;\n\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 5190, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/buildUvs.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/buildUvs.ts"],"sourcesContent":["import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Takes a vertices array and a matrix and transforms the vertices based on the matrix.\n * this out put is written to the uvs array\n * @param vertices - the vertices to calculate uvs from\n * @param verticesStride - the stride of the vertice\n * @param verticesOffset - the offset of the vertices\n * @param uvs - the uvs to fill\n * @param uvsOffset - the offset of the uvs\n * @param uvsStride - the stride of the uvs\n * @param size - the size of the vertices\n * @param matrix - the matrix to apply to the uvs\n * @internal\n */\nexport function buildUvs(\n    vertices: number[],\n    verticesStride: number,\n    verticesOffset: number,\n\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n\n    size: number,\n    matrix: Matrix = null\n): void\n{\n    let index = 0;\n\n    verticesOffset *= verticesStride;\n    uvsOffset *= uvsStride;\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    while (index < size)\n    {\n        const x = vertices[verticesOffset];\n        const y = vertices[verticesOffset + 1];\n\n        uvs[uvsOffset] = (a * x) + (c * y) + tx;\n        uvs[uvsOffset + 1] = (b * x) + (d * y) + ty;\n\n        uvsOffset += uvsStride;\n\n        verticesOffset += verticesStride;\n\n        index++;\n    }\n}\n/**\n * @param uvs\n * @param uvsOffset\n * @param uvsStride\n * @param size\n * @internal\n */\nexport function buildSimpleUvs(\n    uvs: number[],\n    uvsOffset: number,\n    uvsStride: number,\n    size: number,\n)\n{\n    let index = 0;\n\n    uvsOffset *= uvsStride;\n\n    while (index < size)\n    {\n        uvs[uvsOffset] = 0;\n        uvs[uvsOffset + 1] = 0;\n\n        uvsOffset += uvsStride;\n\n        index++;\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAegB,SAAA,QAAA,CACZ,QAAA,EACA,cACA,EAAA,cAAA,EAEA,GAAA,EACA,SACA,EAAA,SAAA,EAEA,IACA;iBAAA,MAAA,2DAAiB,IAErB,EAAA;IACI,IAAI,KAAQ,GAAA,CAAA,CAAA;IAEM,cAAA,IAAA,cAAA,CAAA;IACL,SAAA,IAAA,SAAA,CAAA;IAEb,MAAM,IAAI,MAAO,CAAA,CAAA,CAAA;IACjB,MAAM,IAAI,MAAO,CAAA,CAAA,CAAA;IACjB,MAAM,IAAI,MAAO,CAAA,CAAA,CAAA;IACjB,MAAM,IAAI,MAAO,CAAA,CAAA,CAAA;IACjB,MAAM,KAAK,MAAO,CAAA,EAAA,CAAA;IAClB,MAAM,KAAK,MAAO,CAAA,EAAA,CAAA;IAElB,MAAO,QAAQ,IACf,CAAA;QACU,MAAA,CAAA,GAAI,QAAA,CAAS,cAAc,CAAA,CAAA;QAC3B,MAAA,CAAA,GAAI,QAAS,CAAA,cAAA,GAAiB,CAAC,CAAA,CAAA;QAErC,GAAA,CAAI,SAAS,CAAA,GAAK,CAAI,GAAA,CAAA,GAAM,IAAI,CAAK,GAAA,EAAA,CAAA;QACrC,GAAA,CAAI,YAAY,CAAC,CAAA,GAAK,CAAI,GAAA,CAAA,GAAM,IAAI,CAAK,GAAA,EAAA,CAAA;QAE5B,SAAA,IAAA,SAAA,CAAA;QAEK,cAAA,IAAA,cAAA,CAAA;QAElB,KAAA,EAAA,CAAA;IAAA,CACJ;AACJ,CAAA;AAQO,SAAS,cACZ,CAAA,GAAA,EACA,SACA,EAAA,SAAA,EACA,IAEJ,EAAA;IACI,IAAI,KAAQ,GAAA,CAAA,CAAA;IAEC,SAAA,IAAA,SAAA,CAAA;IAEb,MAAO,QAAQ,IACf,CAAA;QACI,GAAA,CAAI,SAAS,CAAI,GAAA,CAAA,CAAA;QACb,GAAA,CAAA,SAAA,GAAY,CAAC,CAAI,GAAA,CAAA,CAAA;QAER,SAAA,IAAA,SAAA,CAAA;QAEb,KAAA,EAAA,CAAA;IAAA,CACJ;AACJ","debugId":null}},
    {"offset": {"line": 5234, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/transformVertices.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/transformVertices.ts"],"sourcesContent":["import type { Matrix } from '../../../../../maths/matrix/Matrix';\n\n/**\n * Transforms the vertices in an array with the given matrix.\n * @param vertices - the vertices to transform\n * @param m - the matrix to apply to the vertices\n * @param offset - the offset of the vertices (defaults to 0)\n * @param stride - the stride of the vertices (defaults to 2)\n * @param size - the size of the vertices (defaults to vertices.length / stride - offset)\n * @category rendering\n * @internal\n */\nexport function transformVertices(vertices: number[], m: Matrix, offset?: number, stride?: number, size?: number)\n{\n    const a = m.a;\n    const b = m.b;\n    const c = m.c;\n    const d = m.d;\n    const tx = m.tx;\n    const ty = m.ty;\n\n    offset ||= 0;\n    stride ||= 2;\n    size ||= (vertices.length / stride) - offset;\n\n    let index = offset * stride;\n\n    for (let i = 0; i < size; i++)\n    {\n        const x = vertices[index];\n        const y = vertices[index + 1];\n\n        vertices[index] = (a * x) + (c * y) + tx;\n        vertices[index + 1] = (b * x) + (d * y) + ty;\n\n        index += stride;\n    }\n}\n"],"names":[],"mappings":";;;;;AAYO,SAAS,iBAAkB,CAAA,QAAA,EAAoB,CAAW,EAAA,MAAA,EAAiB,MAAA,EAAiB,IACnG,EAAA;IACI,MAAM,IAAI,CAAE,CAAA,CAAA,CAAA;IACZ,MAAM,IAAI,CAAE,CAAA,CAAA,CAAA;IACZ,MAAM,IAAI,CAAE,CAAA,CAAA,CAAA;IACZ,MAAM,IAAI,CAAE,CAAA,CAAA,CAAA;IACZ,MAAM,KAAK,CAAE,CAAA,EAAA,CAAA;IACb,MAAM,KAAK,CAAE,CAAA,EAAA,CAAA;IAEF,MAAA,IAAA,CAAA,MAAA,GAAA,CAAA,CAAA,CAAA;IACA,MAAA,IAAA,CAAA,MAAA,GAAA,CAAA,CAAA,CAAA;IACD,IAAA,IAAA,CAAA,IAAA,GAAA,QAAA,CAAS,MAAA,GAAS,MAAU,GAAA,MAAA,CAAA,CAAA;IAEtC,IAAI,QAAQ,MAAS,GAAA,MAAA,CAAA;IAErB,IAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,EAAM,CAC1B,EAAA,CAAA;QACU,MAAA,CAAA,GAAI,QAAA,CAAS,KAAK,CAAA,CAAA;QAClB,MAAA,CAAA,GAAI,QAAS,CAAA,KAAA,GAAQ,CAAC,CAAA,CAAA;QAE5B,QAAA,CAAS,KAAK,CAAA,GAAK,CAAI,GAAA,CAAA,GAAM,IAAI,CAAK,GAAA,EAAA,CAAA;QACtC,QAAA,CAAS,QAAQ,CAAC,CAAA,GAAK,CAAI,GAAA,CAAA,GAAM,IAAI,CAAK,GAAA,EAAA,CAAA;QAEjC,KAAA,IAAA,MAAA,CAAA;IAAA,CACb;AACJ","debugId":null}},
    {"offset": {"line": 5264, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/.pnpm/pixi.js@8.13.1/node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs","sources":["file:///home/andrew/Development/bitwars/node_modules/.pnpm/pixi.js%408.13.1/node_modules/pixi.js/src/rendering/renderers/shared/texture/CanvasPool.ts"],"sourcesContent":["import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\nimport { GlobalResourceRegistry } from '../../../../utils/pool/GlobalResourceRegistry';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\n/**\n * A utility type that represents a canvas and its rendering context.\n * @category rendering\n * @internal\n */\nexport interface CanvasAndContext\n{\n    /** The canvas element. */\n    canvas: ICanvas;\n    /** The rendering context of the canvas. */\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * CanvasPool is a utility class that manages a pool of reusable canvas elements\n * @category rendering\n * @internal\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const canvas = canvasAndContext.canvas;\n        const { width, height } = canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        canvasAndContext.context.resetTransform();\n        canvasAndContext.context.clearRect(0, 0, width, height);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\n/**\n * CanvasPool is a utility class that manages a pool of reusable canvas elements\n * @category rendering\n * @internal\n */\nexport const CanvasPool = new CanvasPoolClass();\nGlobalResourceRegistry.register(CanvasPool);\n"],"names":[],"mappings":";;;;;;;;;;;;;AAyBO,MAAM,eACb,CAAA;IAiBI;;;;GAAA,GAOQ,uBAAA,CAAwB,UAAA,EAAoB,WACpD,EAAA;QACI,MAAM,MAAS,GAAA,qOAAA,CAAW,GAAI,EAAA,CAAE,YAAa,EAAA,CAAA;QAE7C,MAAA,CAAO,KAAQ,GAAA,UAAA,CAAA;QACf,MAAA,CAAO,MAAS,GAAA,WAAA,CAAA;QAEV,MAAA,OAAA,GAAU,MAAO,CAAA,UAAA,CAAW,IAAI,CAAA,CAAA;QAE/B,OAAA;YAAE;YAAQ,OAAQ;QAAA,CAAA,CAAA;IAAA,CAC7B;IAAA;;;;;;GAAA,GASO,0BAA2B,CAAA,QAAA,EAAkB,SAAmB,EACvE;yBADuE,UAAA,uDAAa,CACpF;QACI,QAAA,GAAW,IAAK,CAAA,IAAA,CAAM,QAAW,GAAA,UAAA,GAAc,IAAI,CAAA,CAAA;QACnD,SAAA,GAAY,IAAK,CAAA,IAAA,CAAM,SAAY,GAAA,UAAA,GAAc,IAAI,CAAA,CAAA;QACrD,QAAA,GAAW,sOAAA,EAAS,QAAQ,CAAA,CAAA;QAC5B,SAAA,OAAY,kOAAA,EAAS,SAAS,CAAA,CAAA;QAExB,MAAA,GAAA,GAAA,CAAO,QAAY,IAAA,EAAA,IAAA,CAAO,SAAa,IAAA,CAAA,CAAA,CAAA;QAE7C,IAAI,CAAC,IAAA,CAAK,WAAY,CAAA,GAAG,CACzB,EAAA;YACS,IAAA,CAAA,WAAA,CAAY,GAAG,CAAA,GAAI,EAAC,CAAA;QAAA,CAC7B;QAEA,IAAI,gBAAmB,GAAA,IAAA,CAAK,WAAY,CAAA,GAAG,CAAA,CAAE,GAAI,EAAA,CAAA;QAEjD,IAAI,CAAC,gBACL,EAAA;YACuB,gBAAA,GAAA,IAAA,CAAK,uBAAwB,CAAA,QAAA,EAAU,SAAS,CAAA,CAAA;QAAA,CACvE;QAEO,OAAA,gBAAA,CAAA;IAAA,CACX;IAAA;;;GAAA,GAMO,uBAAuB,gBAC9B,EAAA;QACI,MAAM,SAAS,gBAAiB,CAAA,MAAA,CAAA;QAC1B,MAAA,EAAE,KAAO,EAAA,MAAA,EAAW,GAAA,MAAA,CAAA;QAEpB,MAAA,GAAA,GAAA,CAAO,KAAS,IAAA,EAAA,IAAA,CAAO,MAAU,IAAA,CAAA,CAAA,CAAA;QAEvC,gBAAA,CAAiB,OAAA,CAAQ,cAAe,EAAA,CAAA;QACxC,gBAAA,CAAiB,OAAQ,CAAA,SAAA,CAAU,CAAG,EAAA,CAAA,EAAG,OAAO,MAAM,CAAA,CAAA;QAEtD,IAAA,CAAK,WAAY,CAAA,GAAG,CAAE,CAAA,IAAA,CAAK,gBAAgB,CAAA,CAAA;IAAA,CAC/C;IAEO,KACP,GAAA;QACI,IAAA,CAAK,WAAA,GAAc,CAAA,CAAC,CAAA;IAAA,CACxB;IA3EA,YAAY,aACZ,CAAA;QACS,IAAA,CAAA,WAAA,GAAA,aAAA,GAAqB,MAAA,CAAA,MAAA,CAAO,IAAI,CAAA,CAAA;QAChC,IAAA,CAAA,aAAA,GAAgB,iBAAiB,CAAA,CAAC,CAAA;QACvC,IAAA,CAAK,gBAAmB,GAAA,KAAA,CAAA;IAAA,CAC5B;AAuEJ,CAAA;AAOa,MAAA,UAAA,GAAa,IAAI,eAAgB,GAAA;AAC9C,kQAAA,CAAuB,QAAA,CAAS,UAAU,CAAA","debugId":null}}]
}