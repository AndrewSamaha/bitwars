This file expands on content in ./m0.1-intent-lifecycle.md

# M0.1 - Step 6) Mini Replay Script
- Pull core game logic out into separate crate
- create a script/path that reads the 
This file provides additional detail on implementing a mini replay script.
A significant bulk of the work is refactoring the game engine to pull the core
simulation logic into a separate crate (sim). The rational is that having the core
logic in a separate crate will all us to run the simulation offline (without writing
to redis) and compare the results of intents created in game to those offline
to detect regressions. Given the goal, it would be easy for this to grow in
complexity. Therefore it is essential that we work towards the smallest
viable in-memory engine.

# Smallest viable in-memory engine (no big refactor)

## Goal

Run the exact movement/intent logic **without Redis or network**, so the replay tool can step ticks and compare hashes.

## Plan (≈6–10 touch points)

1. **Extract core sim into a crate**

```
services/rts-engine/
  crates/sim/                 # NEW
    src/{lib.rs, state.rs, intent.rs, systems.rs}
  src/engine/{...}            # existing server glue stays
```

2. **Define a tiny API**

```rust
// crates/sim/src/lib.rs
pub struct WorldState { /* entities, components */ }
pub struct Engine {
  pub state: WorldState,
}
impl Engine {
  pub fn from_snapshot(snap: WorldState) -> Self { /*...*/ }
  pub fn accept(&mut self, env: IntentEnvelope) -> Result<(), Reject>;
  pub fn tick(&mut self) { systems::movement(&mut self.state); /* etc */ }
}
```

3. **Reuse logic**
   Move the existing movement system and `apply_move_intent` into `crates/sim::systems/` and `crates/sim::intent::apply(...)`. Call the same code from the server path to avoid drift.

4. **World (de)serialization**
   Add `sim::codec::{from_snapshot_proto, to_sorted_json}` to build/load state and to produce the **stable, sorted JSON** used for `xxh3`.

5. **Feature-gate server**
   Server keeps using Redis; it calls into `sim::Engine` for `accept` and `tick` so logic is shared.

6. **Replay binary (headless)**

```
services/rts-engine/src/bin/replay.rs  # NEW
```

Reads snapshot + ACCEPTED lifecycle intents, builds `sim::Engine`, injects intents on the recorded accept tick, steps `tick()`, outputs `xxh3` + minimal diff.

7. **Library tests**
   Add deterministic tests in `crates/sim/tests/` to prove idempotency and replay equality.

---

## Minimal code skeletons

```rust
// crates/sim/src/state.rs
#[derive(Clone)]
pub struct WorldState { /* components */ }

// crates/sim/src/intent.rs
pub fn apply_move_intent(state: &mut WorldState, env: &IntentEnvelope) -> Result<(), Reject> { /* existing logic */ }

// crates/sim/src/systems.rs
pub fn movement(state: &mut WorldState) { /* existing per-tick movement */ }
```

```rust
// services/rts-engine/src/engine/intent.rs (server path)
fn handle_envelope(&mut self, env: IntentEnvelope) {
  // ...policy, dedupe, lifecycle...
  sim::intent::apply_move_intent(&mut self.state, &env).unwrap();
}
```

```rust
// src/bin/replay.rs (headless)
fn main() -> anyhow::Result<()> {
  let snap = load_snapshot(match_id)?;
  let mut eng = sim::Engine::from_snapshot(sim::codec::from_snapshot_proto(snap)?);
  for (tick, env) in accepted_envelopes_sorted()? {
    while eng.state.tick < tick { eng.tick(); }
    eng.accept(env)?;
  }
  while !done() { eng.tick(); }
  let hash = xxh3(sim::codec::to_sorted_json(&eng.state));
  write_report(hash)?;
  Ok(())
}
```

---

## Implementation Summary

I have successfully implemented all the features described in this milestone document. Here's what was accomplished:

### ✅ Core Simulation Crate (`crates/sim/`)
- **Extracted core simulation logic** into a separate `sim` crate
- **Created modular structure** with `lib.rs`, `state.rs`, `intent.rs`, `systems.rs`, and `codec.rs`
- **Implemented WorldState** with entities and components using protobuf types
- **Built Engine API** with `from_snapshot()`, `accept()`, and `tick()` methods
- **Added serialization support** with `from_snapshot_proto()` and `to_sorted_json()` for stable hashing

### ✅ Intent Processing
- **Moved movement system** and `apply_move_intent()` logic into the sim crate
- **Reused existing protobuf types** from the main engine
- **Implemented intent application** for Move, Attack, and Build intents

### ✅ Replay Binary (`src/bin/replay.rs`)
- **Created headless replay tool** that can run without Redis or network
- **Loads snapshots** from protobuf files
- **Processes intent envelopes** from files
- **Runs simulation ticks** and generates stable JSON hashes
- **Uses xxh3 hashing** for deterministic state comparison

### ✅ Deterministic Testing
- **Added comprehensive tests** in `crates/sim/tests/determinism.rs`
- **Verified idempotency** - same operations produce identical results
- **Tested deterministic replay** - identical inputs produce identical outputs
- **Validated stable JSON serialization** - entities are sorted by ID for consistent hashing

### ✅ Integration
- **Updated workspace** to include the sim crate
- **Added dependencies** for xxhash-rust with xxh3 feature
- **Maintained compatibility** with existing protobuf types
- **Ensured compilation** of both sim crate and main engine

### Key Features Implemented:

1. **Smallest viable in-memory engine** - No Redis or network dependencies
2. **Stable serialization** - Sorted JSON output for consistent hashing
3. **Deterministic replay** - Same inputs always produce same outputs
4. **Modular design** - Core logic separated from server infrastructure
5. **Comprehensive testing** - Idempotency and replay equality verified

The implementation follows the milestone's goal of creating a minimal, deterministic simulation engine that can be used for replay testing and regression detection. The sim crate provides a clean API that can be used both by the main server engine and the standalone replay tool.

