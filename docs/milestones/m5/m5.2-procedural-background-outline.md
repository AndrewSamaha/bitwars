# M5.2 Deterministic Procedural Background — Work Outline

## 1. Description, spec, and acceptance

**Goal (from milestones.md)**  
Add a deterministic, procedural background generated from **world coordinates** so that the same world position looks identical on all clients and across reloads. No server or shared cell data.

**Spec (from `procedurally-generated-background.md`)**  
- **Infinite plane:** Sector layout is a pure function of world position + hardcoded seed.  
- **Cell grid:** Fixed cell size `S` (e.g. 1200 world units). For any point `p = (x, y)`:
  - `cx = floor(x / S)`, `cy = floor(y / S)`.
- **Sites:** For the 3×3 neighborhood of `(cx, cy)`, each neighbor cell `(cellX, cellY)` gets a site:
  - Deterministic offset `(u, v) ∈ [0,1)²` from hash of `(cellX, cellY, SEED)`.
  - Site in world space: `((cellX + u) * S, (cellY + v) * S)`.
- **Sector at p:** Sector = cell that owns the **nearest site** to `p` among those 9 candidates.  
- **Sector ID / color:** Winning cell `(cellX, cellY)` (or hash of it) = sector ID. Color = `palette[hash(sectorID) % palette.length]`.  
- **Borders (optional):** Track nearest and second-nearest site distances `d1`, `d2`; where `d2 - d1` is small, draw faint border lines.

**Approach (from m5-camera-worldspace-mapux.md)**  
- Background layer **under** the existing ground (same world transform; entities and ground clicks stay on top).  
- Only generate/draw what’s visible: compute viewport bounds in world space, generate cells that intersect (with margin), cache by cell key.  
- Single hardcoded `SEED`; all inputs = world position + SEED only (no time, no random).

**Acceptance criteria**  
- Background is identical for all clients at the same world coordinates.  
- Background is deterministic across reloads (same coords → same image).

---

## 2. Work outline

### 2.1 Core procedural math (deterministic Voronoi)

- **Hash function**  
  Implement a deterministic hash from `(cellX, cellY, SEED)` that yields a stable numeric seed or two floats. Must be pure: same inputs → same outputs everywhere. Options: simple integer hash (e.g. multiply by primes, mix with SEED) then derive `u, v ∈ [0,1)` via fixed formula (e.g. low bits for u, high bits for v, normalized to [0,1)).

- **Constants**  
  - `CELL_SIZE` (e.g. 1200).  
  - `SEED` (hardcoded number or string, single place).

- **Site for one cell**  
  - Input: `(cellX, cellY)`.  
  - Output: world position `(sx, sy) = ((cellX + u) * S, (cellY + v) * S)` with `(u, v)` from hash(cellX, cellY, SEED).  
  - No randomness; no `Date` or `Math.random()`.

- **Sector at a point**  
  - Input: world `(x, y)`.  
  - Compute `(cx, cy) = (floor(x/S), floor(y/S))`.  
  - Consider 3×3 cells centered on `(cx, cy)`; for each, compute site position.  
  - Find which site is nearest to `(x, y)`; that cell’s `(cellX, cellY)` is the sector.  
  - Optional: also return second-nearest distance for border drawing (`d2 - d1`).

- **Sector color**  
  - Sector ID = winning `(cellX, cellY)` (or a hash of that pair).  
  - Fixed palette (array of hex colors).  
  - `color = palette[hash(sectorID) % palette.length]`.

- **Unit test (recommended)**  
  - For fixed `(x, y)` and SEED, assert exact sector ID and color. Ensures determinism and guards refactors.

---

### 2.2 Viewport in world space

- **Inputs**  
  - Camera = `worldContainer`: `position` (x, y) and `scale` (sx, sy).  
  - Screen size: `app.screen.width`, `app.screen.height`.

- **Inverse transform**  
  - Screen (0,0) and (width, height) map to world via `camera.toLocal(...)` (or inverse of position + scale).  
  - Compute axis-aligned world AABB that covers the visible area (with margin so panning doesn’t show empty edges).

- **Cell range**  
  - From world AABB min/max, compute `minCx = floor(minX / S)`, `maxCx`, `minCy`, `maxCy`.  
  - Generate only cells in that range (plus a small margin, e.g. +1 cell each side).

- **Where this runs**  
  - Each time the background is updated (see 2.4), use current camera and app.screen to compute world AABB and cell range. No viewport logic inside the hash/sector math.

---

### 2.3 Rendering layer (Pixi)

- **Placement**  
  - New Graphics (or container with Graphics) in **world space**, as a child of `worldContainer`.  
  - Add it **before** the ground so draw order is: background → ground → waypoints → entities.  
  - In GameStage’s `initWorld`, create the background layer and `addChild` it to `worldContainer` first, then add ground, then waypoints, etc.

- **Coordinate system**  
  - All background geometry is drawn in the same coordinates as entities (worldContainer local). So a rect at world (wx, wy) is drawn at (wx, wy) in the background Graphics.  
  - Camera pan/zoom moves this layer with the world; no extra transform.

- **Drawing strategy**  
  - **Option A — Cell quads:** For each visible cell, compute sector color (and optional border), draw a quad/polygon for that cell’s world rect. Simple and easy to cache per cell.  
  - **Option B — Dense grid of points:** Sample a grid of world points in the viewport, compute sector at each, draw small rects or use a texture. More flexible for borders but heavier.  
  - Recommended starting point: **Option A**. For each cell in the computed range, determine sector ID and color, then draw one filled rect (or polygon) per cell in world space. Optional: for cells where `d2 - d1` is below a threshold, draw a thin border (e.g. line at cell boundary or along Voronoi edge).

- **Performance**  
  - Only draw cells that intersect the current viewport (+ margin).  
  - Cache by cell key `(cx, cy)`: store generated geometry or at least sector ID/color so the same cell isn’t recomputed every frame. Invalidate or extend cache when the camera moves (e.g. when viewport in world space changes).  
  - Re-draw the background when the visible cell set changes (e.g. after panning past a threshold) or once per frame if cheap; if using a cache, “re-draw” can mean updating Graphics only for newly visible cells.

---

### 2.4 When to update the background

- **Options**  
  - **Every frame:** Recompute viewport, visible cells, and redraw. Acceptable if cell count is small and drawing is fast; otherwise optimize with cache.  
  - **On camera change:** When `worldContainer.position` or `scale` changes beyond a threshold, recompute viewport and visible cells, update cache and Graphics.  
  - **Hybrid:** Cache per-cell; each frame (or on interval) check if the visible cell set changed and only then redraw or append new cells.

- **Implementation note**  
  - The ticker already has access to `worldContainer` and `app`. Either:  
    - In the same ticker callback that runs after pan, compute viewport in world space and update the background (e.g. “dirty” flag or compare previous cell range), or  
    - Expose a small “background manager” that receives camera + screen and owns the cache and Graphics, and call it from the ticker or from a dedicated update after camera movement.

---

### 2.5 Optional: sector borders

- For each point or cell, compute both nearest and second-nearest site distances `d1`, `d2`.  
- Where `(d2 - d1)` is below a threshold, the point is “near” a Voronoi edge; draw a faint line or darker edge.  
- Can be done per-cell (e.g. sample center and corners, draw borders along cell edges where neighbor sector differs) or with a finer grid; document as optional and implement after solid cell coloring works.

---

### 2.6 File and dependency overview

- **New modules (suggested)**  
  - **Procedural background / Voronoi:** One module (or file) that exports:  
    - `getSectorAt(x, y, cellSize, seed)` → sector ID and optionally `d2 - d1`.  
    - `getSiteForCell(cellX, cellY, cellSize, seed)` → world (sx, sy).  
    - `getSectorColor(sectorId, palette)` or similar.  
  - All inputs to these functions are world position and/or cell indices + SEED; no globals, no time, no random.

- **GameStage integration**  
  - In `initWorld`, after creating `worldContainer` but before adding `ground`:  
    - Create a Container or Graphics for the background.  
    - Add it as the first child of `worldContainer`.  
  - Each frame (or on camera change):  
    - Compute viewport AABB in world space from camera + app.screen.  
    - Compute visible cell range; optionally get cached sector/color per cell or compute.  
    - Clear and redraw the background Graphics (or update only changed cells if using a more advanced cache).  
  - Keep ground, waypoints, and entity setup unchanged so click targeting and layering remain correct.

- **Constants**  
  - `CELL_SIZE` and `SEED` in one place (e.g. next to the procedural module or in a small config used only by the background).

---

### 2.7 Testing and acceptance

- **Determinism**  
  - Call `getSectorAt(x, y, ...)` and color lookup with fixed inputs from two different “clients” (e.g. two runs or two modules); assert same sector ID and same color.  
  - Optionally snapshot sector IDs or colors for a small grid and commit as a golden file; regression test on refactor.

- **Visual**  
  - Pan around; confirm background moves with the world and no visible seams or wrong colors at cell boundaries (for the chosen cell size).  
  - Reload; same area should look identical (acceptance: “identical for all clients at the same world coordinates” and “deterministic across reloads”).

---

## 3. Suggested implementation order

1. **Hash + site + sector math** — Implement and unit-test `hash → (u,v)`, `getSiteForCell`, `getSectorAt`, and color from sector ID with a fixed palette and SEED.  
2. **Viewport → cell range** — Helper: camera + screen → world AABB → min/max cell indices (with margin).  
3. **Background layer in GameStage** — Add a Graphics (or Container) as first child of `worldContainer`; draw a single test color or a few test quads in world space to confirm order and transform.  
4. **Wire viewport to cells** — In ticker (or on camera change), compute viewport, cell range, then for each cell compute sector and color; draw one quad per cell. No cache yet.  
5. **Cache and invalidation** — Cache sector ID/color (or drawn geometry) by `(cx, cy)`; only recompute or redraw when the visible cell set changes.  
6. **(Optional) Borders** — Add `d2 - d1` to sector logic and draw faint lines where below threshold.  
7. **Polish** — Tune CELL_SIZE and palette; document SEED and determinism in code.

This order keeps determinism and math correct first, then viewport, then integration, then performance and optional features.
