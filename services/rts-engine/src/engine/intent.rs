use std::collections::{HashMap, VecDeque};

use tracing::{debug, info, warn};

use crate::engine::state::GameState;
use crate::pb;

/// Minimal intent manager that holds per-entity queues and current action state.
///
/// Notes:
/// - This is framework-agnostic and does not require adopting an ECS.
/// - Integrate with Engine by calling `ingest`, then `process_pending`, then `follow_targets` before `integrate()`.
pub struct IntentManager {
    intent_queues: HashMap<u64, VecDeque<pb::Intent>>, // entity_id -> FIFO queue
    current_action: HashMap<u64, pb::ActionState>,     // entity_id -> executing action
    default_stop_radius: f32,
}

impl IntentManager {
    pub fn new(default_stop_radius: f32) -> Self {
        Self {
            intent_queues: HashMap::new(),
            current_action: HashMap::new(),
            default_stop_radius,
        }
    }

    /// Returns the entity_id this intent applies to.
    fn intent_entity_id(intent: &pb::Intent) -> Option<u64> {
        match intent.kind.as_ref()? {
            pb::intent::Kind::Move(m) => Some(m.entity_id),
            pb::intent::Kind::Attack(a) => Some(a.entity_id),
            pb::intent::Kind::Build(b) => Some(b.entity_id),
        }
    }

    /// Enqueue an intent into the per-entity FIFO.
    pub fn enqueue(&mut self, intent: pb::Intent) {
        if let Some(eid) = Self::intent_entity_id(&intent) {
            let q = self.intent_queues.entry(eid).or_insert_with(VecDeque::new);
            q.push_back(intent);
        } else {
            warn!("dropping intent with no kind");
        }
    }

    /// Convenience for batch ingestion (e.g., from a Redis stream consumer).
    pub fn ingest<I: IntoIterator<Item = pb::Intent>>(&mut self, intents: I) {
        for it in intents {
            self.enqueue(it);
        }
    }

    /// If an entity has no current action, start the next one from its queue.
    /// Returns number of actions started.
    pub fn process_pending(&mut self) -> usize {
        let mut started = 0usize;
        // Collect entity ids to check; avoid borrowing issues while mutating the map
        let entity_ids: Vec<u64> = self.intent_queues.keys().cloned().collect();
        for eid in entity_ids {
            if self.current_action.contains_key(&eid) {
                continue; // already executing
            }
            let maybe_next = self.intent_queues.get_mut(&eid).and_then(|q| q.pop_front());
            if let Some(intent) = maybe_next {
                let action = make_action_state_from_intent(intent, self.default_stop_radius);
                self.current_action.insert(eid, action);
                started += 1;
            }
        }
        started
    }

    /// Advances current move actions by `dt` at a given `speed`.
    /// When an entity reaches its target within stop_radius, marks the action finished.
    pub fn follow_targets(&mut self, state: &mut GameState, speed: f32, _dt: f32) {
        // Collect finished ids to avoid holding mutable borrows across the loop
        let mut finished: Vec<u64> = Vec::new();

        for (eid, action) in self.current_action.iter_mut() {
            match action.exec.as_mut() {
                Some(pb::action_state::Exec::Move(mov)) => {
                    // Handle Option fields generated by prost
                    let Some(mt) = mov.target.as_ref() else {
                        warn!("follow_targets: missing MotionTarget for entity id {}", eid);
                        finished.push(*eid);
                        continue;
                    };
                    let Some(to) = mt.target.as_ref() else {
                        warn!("follow_targets: missing target Vec2 for entity id {}", eid);
                        finished.push(*eid);
                        continue;
                    };
                    let stop_r = mt.stop_radius;
                    if let Some(entity) = find_entity_mut(state, *eid) {
                        // Ensure pos/vel are present
                        let pos = entity.pos.get_or_insert(pb::Vec2 { x: 0.0, y: 0.0 });
                        let vel = entity.vel.get_or_insert(pb::Vec2 { x: 0.0, y: 0.0 });
                        let dx = to.x - pos.x;
                        let dy = to.y - pos.y;
                        let dist2 = dx * dx + dy * dy;
                        let sr2 = stop_r * stop_r;
                        if dist2 <= sr2 {
                            // Arrived
                            vel.x = 0.0;
                            vel.y = 0.0;
                            finished.push(*eid);
                        } else {
                            let dist = dist2.sqrt();
                            let dir_x = dx / dist;
                            let dir_y = dy / dist;
                            vel.x = dir_x * speed;
                            vel.y = dir_y * speed;
                            // Position will be advanced by physics::integrate
                        }
                    } else {
                        warn!("follow_targets: entity id {} not found", eid);
                        finished.push(*eid);
                    }
                }
                // Other action kinds can be advanced here later (Attack, Build, ...)
                _ => {}
            }
        }

        // Clear finished actions and log
        for eid in finished {
            if let Some(action) = self.current_action.remove(&eid) {
                log_finish(&action, eid);
            }
        }
    }

    /// Returns a snapshot of internal state references for inspection/logging.
    pub fn snapshot(&self) -> (&HashMap<u64, VecDeque<pb::Intent>>, &HashMap<u64, pb::ActionState>) {
        (&self.intent_queues, &self.current_action)
    }
}

fn make_action_state_from_intent(intent: pb::Intent, default_stop_radius: f32) -> pb::ActionState {
    // Build exec by borrowing from the intent, then move the original intent into the ActionState.
    let mut exec: Option<pb::action_state::Exec> = None;
    match intent.kind.as_ref() {
        Some(pb::intent::Kind::Move(m)) => {
            let move_state = pb::MoveState {
                target: Some(pb::MotionTarget { target: m.target.clone(), stop_radius: default_stop_radius }),
            };
            exec = Some(pb::action_state::Exec::Move(move_state));
            log_start(&intent, m.entity_id);
        }
        Some(pb::intent::Kind::Attack(a)) => {
            let attack_state = pb::AttackState { target_id: a.target_id, last_known_pos: None };
            exec = Some(pb::action_state::Exec::Attack(attack_state));
            log_start(&intent, a.entity_id);
        }
        Some(pb::intent::Kind::Build(b)) => {
            let build_state = pb::BuildState { blueprint_id: b.blueprint_id.clone(), location: b.location.clone(), progress: 0.0 };
            exec = Some(pb::action_state::Exec::Build(build_state));
            log_start(&intent, b.entity_id);
        }
        None => warn!("intent had no kind; ignoring"),
    }
    pb::ActionState { intent: Some(intent), exec }
}

fn find_entity_mut<'a>(state: &'a mut GameState, id: u64) -> Option<&'a mut pb::Entity> {
    state.entities.iter_mut().find(|e| e.id == id)
}
fn log_start(intent: &pb::Intent, entity_id: u64) {
    match intent.kind.as_ref() {
        Some(pb::intent::Kind::Move(m)) => {
            if let Some(t) = m.target.as_ref() {
                info!(entity_id, client_cmd_id = %m.client_cmd_id, player_id = %m.player_id, target_x = t.x, target_y = t.y, "start intent=Move");
            } else {
                warn!(entity_id, client_cmd_id = %m.client_cmd_id, player_id = %m.player_id, "start intent=Move (missing target)");
            }
        }
        Some(pb::intent::Kind::Attack(a)) => {
            info!(entity_id, client_cmd_id = %a.client_cmd_id, player_id = %a.player_id, target_id = a.target_id, "start intent=Attack");
        }
        Some(pb::intent::Kind::Build(b)) => {
            if let Some(loc) = b.location.as_ref() {
                info!(entity_id, client_cmd_id = %b.client_cmd_id, player_id = %b.player_id, blueprint_id = %b.blueprint_id, loc_x = loc.x, loc_y = loc.y, "start intent=Build");
            } else {
                warn!(entity_id, client_cmd_id = %b.client_cmd_id, player_id = %b.player_id, blueprint_id = %b.blueprint_id, "start intent=Build (missing location)");
            }
        }
        None => {}
    }
}

fn log_finish(action: &pb::ActionState, entity_id: u64) {
    match action.exec.as_ref() {
        Some(pb::action_state::Exec::Move(_)) => info!(entity_id, "finish intent=Move"),
        Some(pb::action_state::Exec::Attack(_)) => info!(entity_id, "finish intent=Attack"),
        Some(pb::action_state::Exec::Build(_)) => info!(entity_id, "finish intent=Build"),
        None => debug!(entity_id, "finish intent=(unknown)"),
    }
}
