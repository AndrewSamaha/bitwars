# M5.2 Deterministic Procedural Background — Approach Validation

This document validates the M5.2 approach against the codebase and captures potential issues, complexity, and follow-up planning. No code changes.

---

## 1. Approach validation against code

### 1.1 Scene order and insertion point

**Claim (outline):** Add a background layer as the **first** child of `worldContainer` so it draws under ground and entities.

**Code:** In `GameStage.tsx`, `worldContainer` currently gets children in this order:

1. `ground` (Graphics) — added first at L84  
2. `waypointContainer` — L89  
3. Entity containers — added dynamically in `render()` via `worldContainer.addChild(entityContainer)` (L148)

Pixi draws children in order: first added = back, last added = front. So ground is already behind waypoints and entities. To put the procedural background **under** the ground, we must add a background container **before** the ground. That implies:

- Create a container (or single `Graphics`) for the background.
- `worldContainer.addChild(backgroundContainer)` **before** `worldContainer.addChild(ground)`.
- Do **not** reorder later; entity containers are always appended, so background and ground stay at indices 0 and 1.

**Validated:** Insertion point is clear. Create background, add it first, then ground, then waypointContainer. No change to ground or entity logic.

---

### 1.2 Viewport in world space

**Claim (outline):** Compute visible world AABB from camera (`worldContainer`) and `app.screen`, then cell range from that AABB.

**Code:**  
- `worldContainer` has `position` and `scale` (M5.1: pannable camera).  
- `CoordsOverlay` already does: `camera.toLocal({ x: centerX, y: centerY })` with `centerX = app.screen.width / 2`, `centerY = app.screen.height / 2`. So screen-space points are transformed to world via `camera.toLocal()`.

**Implementation:** Transform the four screen corners `(0,0)`, `(app.screen.width, 0)`, `(app.screen.width, app.screen.height)`, `(0, app.screen.height)` with `camera.toLocal()`, then take `minX`, `minY`, `maxX`, `maxY` of the four results. That is the visible world AABB. Add margin (e.g. one `CELL_SIZE` per side) so panning doesn’t reveal empty space. Then:

- `minCx = floor(minX / CELL_SIZE)`, `maxCx = floor(maxX / CELL_SIZE)`, same for `cy`.

**Validated:** Same pattern as CoordsOverlay; no new concepts. Camera and app are in closure in the ticker where we’ll update the background.

---

### 1.3 Where to run background update

**Claim (outline):** Update background each frame (or when visible cells change) using the same ticker that runs after pan.

**Code:** The main ticker in `GameStage.tsx` (L316–338) already:

1. Applies pan to `worldContainer.position`  
2. Calls `game.tick()`  
3. Calls `render()`

So we have access to `worldContainer`, `app`, and `app.screen` in that closure. We can either:

- **A)** Add a call to `updateProceduralBackground(backgroundGraphics, worldContainer, app)` at the start of the ticker (after `if (!game.ready) return`), or  
- **B)** Do the same update inside `render()`.

**Recommendation:** Option A keeps `render()` focused on ECS → Pixi; the background is viewport-driven only. The background layer and its Graphics are created in `initWorld` and held in closure, so the ticker can update them without touching React state.

**Validated:** Ticker has everything needed; no need to expose camera/screen elsewhere for the background.

---

### 1.4 Pixi v8 Graphics API

**Codebase:** Uses Pixi v8 (`pixi.js` ^8.13.1). Existing usage:

- **Ground:** `ground.rect(-4000, -4000, 8000, 8000).fill(0x000000, 0)` — fluent `rect().fill(color, alpha)`.
- **Waypoints:** New `Graphics()` per segment, then `g.moveTo()`, `g.lineTo()`, `g.stroke()`, `g.circle()`, etc.; waypoint container uses `waypointContainer.removeChildren()` each frame and re-adds new Graphics.
- **Hover indicator:** `new Graphics().fill(SELECTED_COLOR).circle(0, 0, 150).stroke(SELECTED_COLOR)`.

**Pixi v8 (from `node_modules/pixi.js`):**

- `Graphics` has `.clear()` — clears the context so the same Graphics can be redrawn (no need to remove/recreate).
- Drawing: `.rect(x, y, w, h).fill(style)` where `style` is `FillInput`. The signature `fill(color, alpha)` exists but is **deprecated** in 8.0.0; preferred is `fill({ color, alpha })` or `fill({ color: hex })`.
- Batching: Graphics uses a context; multiple `.rect().fill()` calls in sequence are supported. No need for one Graphics per cell; one Graphics, clear each frame, then many `rect().fill()` is valid.

**Implications:**

- Use a **single** `Graphics` for the procedural layer: each frame `graphics.clear()`, then for each visible cell `graphics.rect(cx*S, cy*S, S, S).fill({ color: sectorColor })`.
- Use the non-deprecated fill API: `fill({ color: hex })` (and `alpha: 1` if needed). Avoid relying on `fill(color, alpha)` for new code.

**Validated:** Approach of “one Graphics, clear + redraw each frame” is supported and matches Pixi v8.

---

### 1.5 Ground hit area and events

**Claim:** Background must not capture pointer events; ground should remain the click target.

**Code:** Ground has `ground.eventMode = 'static'` and is the only large hit target for move/selection. The new background layer will sit **behind** the ground in the scene graph. In Pixi, children drawn later can still receive events when they are in front. So as long as the background is **before** the ground (lower index), the ground will receive pointer events. We should still set the background’s `eventMode = 'none'` (or leave default) so it does not participate in hit testing.

**Validated:** Draw order keeps ground on top; explicitly set background to non-interactive.

---

## 2. Potential issues and complexity

### 2.1 Hash determinism and environment

**Issue:** The procedural spec requires a **deterministic** hash of `(cellX, cellY, SEED)` so that all clients and reloads get the same `(u, v)` and thus the same sectors and colors. Any dependence on platform, engine, or floating-point order can break that.

**Complexity:**

- **Integer hash:** Use only integer arithmetic (e.g. multiply by primes, xor, add SEED) and derive `u, v` from fixed bit masks (e.g. low 16 bits / 65536) so that the result is identical in all JS engines.
- **No:** `Date`, `Math.random()`, `crypto.getRandomValues()`, or any external input. No string hash that might vary by implementation (e.g. some engines have different string hash algorithms).
- **Floating point:** `(cellX + u) * S` and `(cellY + v) * S` will be floats. Small differences across engines are possible in theory, but for **sector ID** we use the **cell** `(cellX, cellY)` of the nearest site, not the float position. So sector ID and color can remain integer/key driven and deterministic. Only if we later use exact float positions for something (e.g. border placement) do we need to be cautious.

**Recommendation:** Implement the hash with integers only; document “deterministic, integers only” in the module. Add a unit test that asserts exact sector ID and color for a fixed `(x, y)`, `SEED`, and `CELL_SIZE`.

---

### 2.2 Cell-centered vs. true Voronoi coloring

**Issue:** The spec defines “sector at point **p**” as the cell owning the **nearest site** to **p**. If we draw one quad per **cell** and color it by the sector at the **cell center**, we get a blocky Voronoi: boundaries fall on cell edges, not the true Voronoi edges (which can cut through cells).

**Complexity:**

- **Cell-centered (recommended for v1):** For each cell `(cx, cy)`, sample sector at center `(cx*S + S/2, cy*S + S/2)`, draw one rect with that color. Simple, fast, deterministic; boundaries are stepped.
- **Smoother boundaries:** Would require either subdividing cells and sampling multiple points, or drawing actual Voronoi edges (more math and draw calls). Defer to a later iteration.

**Recommendation:** Implement cell-centered coloring first; document that boundaries are stepped. Optional borders (nearest vs second-nearest) can still be added later on top of this.

---

### 2.3 Viewport margin and resize

**Issue:** If we add exactly one cell of margin and the user pans quickly, they may briefly see empty space before the next frame. If the window is resized, `app.screen.width/height` change; we recompute viewport every frame, so the new size is picked up automatically.

**Complexity:** Margin of 1× `CELL_SIZE` is usually enough. For very fast pan or large cells, consider 2× margin; cost is a few extra cells per side. No extra resize listener is needed because we always use current `app.screen` in the ticker.

---

### 2.4 Performance: cell count and clear+redraw

**Rough numbers:**  
- Camera scale 0.5 → visible world size ≈ 2× screen size in pixels.  
- Example: 1920×1080 → ~3840×2160 world units. With `CELL_SIZE = 1200` → ~4×2 cells + margin → on the order of 24–40 cells.  
- Each frame: one `graphics.clear()` plus 24–40 `rect().fill()` calls. That is well within what Pixi’s batched Graphics can handle.

**Complexity:** If we later increase resolution or decrease `CELL_SIZE`, cell count grows. Options then: (1) cache by cell key and only redraw when the **set** of visible cells changes (compare `minCx,maxCx,minCy,maxCy` to previous frame), or (2) draw only changed cells (incremental). For the initial implementation, full redraw each frame is acceptable; we can add a “dirty” or “visible set changed” check later if needed.

---

### 2.5 Coordinate system and scale

**Code:** `worldContainer.scale.set(.5)` is uniform. World-space coordinates used for entities (e.g. `e.pos.x`, `e.pos.y`) and for the ground rect (-4000..4000) are in the same space. So drawing background quads at `(cx*S, cy*S, S, S)` in the background Graphics (which is a child of `worldContainer`) uses the same world space. No extra transform.

**Validated:** No coordinate-system surprises; background and entities share the same world space.

---

### 2.6 Optional borders (d2 − d1)

**Spec:** Use nearest and second-nearest site distances to draw faint borders where `d2 - d1` is small.

**Complexity:** Requires returning `d2 - d1` (or both distances) from the “sector at point” logic. Drawing borders then means either: (a) drawing line segments along Voronoi edges (compute edge geometry), or (b) a second pass that darkens or strokes cell edges when a neighbor has a different sector or when `d2 - d1` is below a threshold. That adds both math and draw calls. Recommendation: implement solid cell coloring first; add borders as a follow-up and document as optional in the outline.

---

## 3. Summary: validated vs. needs care

| Item | Status | Notes |
|------|--------|--------|
| Insertion order (background first) | Validated | Add background before ground; no reorder. |
| Viewport from camera + screen | Validated | Use `camera.toLocal()` on four corners; same as CoordsOverlay. |
| Ticker has camera/app | Validated | Update background in same ticker, in closure. |
| Pixi v8 Graphics clear + rect/fill | Validated | Use `.clear()` and `.rect().fill({ color })`; avoid deprecated `fill(color, alpha)`. |
| Ground still receives events | Validated | Background behind ground; set background non-interactive. |
| Hash determinism | Needs care | Integer-only hash; no Date/random; unit test fixed outputs. |
| Cell-centered vs. smooth Voronoi | Planned | Cell-centered for v1; document stepped boundaries. |
| Resize / margin | Low risk | One-cell margin; viewport recomputed every frame from `app.screen`. |
| Performance | Low risk | ~24–50 cells/frame is fine; add cache or dirty check later if needed. |
| Optional borders | Deferred | Implement after solid cells; document as optional. |

---

## 4. Recommended additions to the outline

1. **Hash:** In “Core procedural math”, explicitly state: “Use integer-only operations for the hash; no floats until after u,v are derived; no Date, Math.random(), or engine-dependent behavior.”
2. **Graphics API:** In “Rendering layer”, state: “Use a single Graphics instance; each frame call `graphics.clear()` then for each visible cell `graphics.rect(cx*S, cy*S, S, S).fill({ color: sectorColor })`. Use `fill({ color })` (Pixi v8 preferred), not deprecated `fill(color, alpha)`.”
3. **Interaction:** In “Rendering layer”, state: “Set the background container or Graphics to `eventMode = 'none'` so it does not capture pointer events.”
4. **Test:** In “Testing and acceptance”, add: “Unit test: for fixed (x, y), SEED, CELL_SIZE, assert exact sector ID and color (e.g. snapshot or hardcoded expected values) to guard determinism across refactors.”

With these, the approach is validated and the main risks (determinism, API, interaction) are explicitly planned for.
