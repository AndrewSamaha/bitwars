# M0.1: Intent Lifecycle, IDs, and Observability Seed

## Goals

* Lock the canonical **intent lifecycle** and identifiers.
* Stamp **`server_tick`** everywhere.
* Seed **observability + mini-replay** to protect determinism/idempotency later.

---

## Deliverables

### 1) Intent envelope (transport wrapper) [DONE]

* Introduce **`IntentEnvelope`** carrying:

  * `client_cmd_id` **[bytes UUIDv7, 16 bytes]**
  * `intent_id` **[bytes UUIDv7/server-assigned, 16 bytes]**
  * `player_id` **[string]**
  * `client_seq` **[uint64, client-maintained]**
  * `server_tick` **[uint64]**
  * `protocol_version` **[uint32, major]**
  * `policy` **[enum: `REPLACE_ACTIVE` | `APPEND` | `CLEAR_THEN_APPEND`]**
* Nest existing payloads (`move`/`attack`/`build`) **without** transport fields; mark `client_cmd_id` / `player_id` in payloads as `[deprecated = true]` for a short transition.
* **Default policy**: `REPLACE_ACTIVE` if omitted.
* **Legacy fallback**: If envelope fields are absent, read legacy payload fields and **synthesize** an envelope with `policy=REPLACE_ACTIVE`.

### 2) Lifecycle states & events [DONE]

* Engine now emits `RECEIVED → ACCEPTED → IN_PROGRESS → FINISHED` plus `CANCELED(INTERRUPTED)` when policies replace active work and `BLOCKED` when queues remain occupied (`services/rts-engine/src/engine/mod.rs`, `.../intent.rs`).
* Policy handling (`IntentManager::apply_policy_before_enqueue()`) publishes lifecycle updates for replaced intents and logs cancellations via `log_cancel()`.

**Status**
- **Automated validation**: DONE unit tests cover policy cancellation/blocked logic (`services/rts-engine/src/engine/intent.rs`) and an ignored integration test now replays intents through Redis to assert lifecycle ordering (`services/rts-engine/src/engine/mod.rs::integration_tests`). Run it with a Redis instance available:
  ```bash
  TEST_REDIS_URL=redis://127.0.0.1/ cargo test -p rts-engine integration_tests:: -- --ignored
  ```
  Dashboards or saved queries remain _out of scope_ for M0.1.

* States: `RECEIVED → ACCEPTED → IN_PROGRESS → BLOCKED? → FINISHED | CANCELED | REJECTED`.
* Each **LifecycleEvent** includes: `intent_id`, `client_cmd_id`, `player_id`, `server_tick`, `state`, `reason (enum)`, `protocol_version`.
* **Reason is an enum** (not a free-form string): `NONE`, `INTERRUPTED`, `DUPLICATE`, `OUT_OF_ORDER`, `INVALID_TARGET`, `PROTOCOL_MISMATCH` (extend as needed).
* **Idempotent emission**: emit at most one event per `(intent_id, state)`.

**Tick semantics**

* `IntentEnvelope.server_tick` = **tick when ACCEPTED** (frozen thereafter).
* `LifecycleEvent.server_tick` = **tick when that state was emitted** (varies per state).

### 3) Identifiers & ordering [DONE]

**Status**
- **Tightened validation**: [DONE] `services/rts-engine/src/engine/mod.rs::handle_envelope()` now rejects non-UUIDv7 `client_cmd_id` / `intent_id` values via `ensure_uuid_v7` and emits `REJECTED(INVALID_TARGET)`. Legacy payloads are upgraded to UUIDv7 when parsing fails.
- **Improve observability**: [DONE] existing `warn!` logs and lifecycle events capture dedupe hits, out-of-order drops, and intent acceptance; no additional counters required for M0.1.
* `client_cmd_id` / `intent_id`: [DONE] **protobuf `bytes`** (UUIDv7). Clients format as hex/base64 **only** for logs/devtools.
* **Dedupe TTL**: [DONE] store `(player_id, client_cmd_id)` in Redis with **SETEX 5–15 minutes** (configurable) to drop duplicates.
* `client_seq`: [DONE] per-player incrementing; engine stores **last seen `client_seq`** and **drops older** (emit `REJECTED(OUT_OF_ORDER)`).
* `server_tick`: [DONE] stamped on **all** deltas and lifecycle events.

### 4) Wire / Streams (Redis) [DONE]

**Status**
- **Snapshot stream**: `services/rts-engine/src/io/redis.rs::publish_snapshot()` writes Redis keys _and_ `XADD`s `rts:match:{id}:snapshots`.
- **Intent ingestion**: `apps/web/src/app/api/v1/intent/route.ts` now authenticates the caller, validates UUIDv7 `client_cmd_id` + monotonic `client_seq`, wraps payloads in `IntentEnvelope`, and publishes to `rts:match:{gameId}:intents`.
- **Client publisher**: `apps/web/src/features/pixijs/components/GameStage.tsx` generates UUIDv7 command IDs, increments `client_seq`, and posts intents via `/api/v1/intent`.
- **SSE consumer**: `apps/web/src/app/api/v2/gamestate/stream/route.ts` tails `rts:match:{GAME_ID}:events` (via `bootstrapAndCatchUp()` + live `XREAD`) and forwards decoded `EventsStreamRecord` payloads.
- **Utility coverage**: Redis read/write test scripts now target `rts:match:{id}:events` and decode `EventsStreamRecord` entries; Rust + tooling parity tracked separately.
- **Protocol**: Streams remain protobuf-on-wire; JSON is dev-only.

**Validation**
- Verified end-to-end: authenticated web client publishes intents → Redis `rts:match:{id}:intents`; engine ingests envelopes, moves entities, and emits lifecycle + delta events that flow back to the client.

### 5) Protocol header (M0.1 scope)

* **Log-only in M0.1**: engine logs `{ protocol_version (major), content_version (hash) }` at startup and attaches `protocol_version` to the **first event** sent to a client.
* **Enforcement**: engine rejects intents whose `protocol_version` major ≠ engine major with `REJECTED(PROTOCOL_MISMATCH)` (still emit lifecycle).

### 6) Mini-replay script (`pnpm demo:replay:lastN`)

* Replays the last **N** intents against an in-memory engine and asserts final world hash.
* Use a **stable serializer** (sorted entity keys; sorted object keys; numeric normalization) and compute **`xxh3`** over the serialized bytes.
* On mismatch, print a **minimal diff** (first differing entity id + fields) and return non-zero exit code.

### 7) Latency probe CLI

* Send **100** `Move` intents; report **p50/p95** from submit → first delta referencing that `intent_id`.
* Write metrics as JSON under `./.metrics/m0.1/` and print a brief histogram summary to console.

### 8) Schema / contract CI guardrails

* Regenerate TS/Rust code from `.proto` in CI and **fail** if generated files change.
* If `.proto` files change without a `PROTOCOL_VERSION` major bump, require a **“compat: non-breaking”** label; otherwise **fail**.

---

## Acceptance Criteria

* **Lifecycle visibility**: `Move` produces `RECEIVED → ACCEPTED → IN_PROGRESS → FINISHED` with all IDs + `server_tick`; UI may ignore, logs must show.
* **Idempotency**: applying the same delta twice on a cloned world yields the same world hash.
* **Determinism**: mini-replay of the last **N** intents yields **identical** final world hash to the live world.
* **Latency**: latency probe prints p50/p95 and writes a JSON metrics file per run.
* **Protocol mismatch**: an intent with a different major `protocol_version` is **REJECTED(PROTOCOL_MISMATCH)** (not enqueued); lifecycle event is emitted and visible in logs.
* **Legacy fallback**: sending a **legacy payload** (no envelope) is accepted via synthesized envelope and yields a normal lifecycle chain with a generated `intent_id`.

---

## Possible Implementation Details

### Lifecycle states

* Extend `packages/schemas/proto/intent.proto` with `IntentLifecycleEvent`, `IntentLifecycleState`, and `LifecycleReason`; regenerate via `pnpm --filter @bitwars/schemas run gen:ts`.
* Add a lifecycle publisher in `services/rts-engine/src/engine/intent.rs` or `services/rts-engine/src/engine/lifecycle.rs`; construct from `IntentManager` and publish via `services/rts-engine/src/io/redis.rs`.
* **(Optional in M0.1)** Store last-known lifecycle state in Redis hashes `intent:{intent_id}`; otherwise defer to M1.
* Update the `Move` flow so log-only transitions become structured events; map failure paths to `BLOCKED` / `CANCELED` / `REJECTED` with **enum `reason`**.

### Identifiers

* Ingest loop (`services/rts-engine/src/engine/mod.rs`): enforce UUIDv7 `client_cmd_id` and monotonic `client_seq`; cache `(player_id, client_cmd_id)` in Redis via `SETEX`.
* Generate `intent_id` on decode; include it in lifecycle events and deltas.
* Add `packages/shared/src/ids.ts` helpers for client + tools to format/validate IDs consistently.

### Server tick stamping

* Expose a single tick accessor (e.g., `self.state.tick`) and pass into lifecycle publisher; **all** deltas & lifecycle events must share authoritative tick semantics.
* Add Rust unit/integration tests asserting identical `server_tick` presence/values where expected.

### Wire / Streams (Redis)

* Provision streams in Rust (`services/rts-engine/src/io/redis.rs`) or a Node script under `scripts/`.
* Align naming where current code uses `intents:{id}` / `deltas:{id}`; update the SSE route at `apps/web/src/app/api/v2/gamestate/stream/route.ts`.
* **Type tag**: implement `EventsStreamRecord { oneof record { LifecycleEvent lifecycle = 1; Delta delta = 2; } }` to route without full decode.
* **(Optional in M0.1)** Stream reader “ack after replay success”; otherwise keep current behavior and add a TODO.

### Protocol header

* **M0.1**: no new handshake transport—log/startup + first-event attachment only; enforce major match on ingest.
* Plan to introduce a proper handshake message (`packages/schemas/proto/protocol.proto`) in **M1**.

### Mini-replay script (`pnpm demo:replay:lastN`)

* Add a workspace package (e.g., `apps/replay-tool/`) or `scripts/replay-last-n.ts`. Reuse shared protobuf from `packages/shared/src/gen/` and Redis helpers from `apps/web/src/lib/db/utils/redis-streams.ts`.
* Flags: `--match`, `--count`, `--snapshot`. Bootstrap from `snapshot:{id}` if present.
* Implement the **stable serializer** (sorted keys; numeric normalization) and compute `xxh3`. Print hash + minimal diff; exit non-zero on mismatch.

### Latency probe CLI

* Implement as Node (`scripts/latency-probe.ts`) or Rust (`services/rts-engine/src/bin/latency_probe.rs`).
* Use existing Redis utilities to publish envelopes and listen for the **first delta that references each `intent_id`**.
* Emit histogram to `./.metrics/m0.1/` and enforce a timeout.

### CI guardrails

* Add a job that regenerates code from `.proto` and fails on diffs.
* Add a check that `.proto` changes without major bump must be labeled **“compat: non-breaking.”**

---

## Example proto excerpts (reference)

```proto
enum IntentPolicy { REPLACE_ACTIVE = 0; APPEND = 1; CLEAR_THEN_APPEND = 2; }

enum LifecycleState { RECEIVED = 0; ACCEPTED = 1; IN_PROGRESS = 2; BLOCKED = 3; FINISHED = 4; CANCELED = 5; REJECTED = 6; }

enum LifecycleReason {
  NONE               = 0;
  INTERRUPTED        = 1;
  DUPLICATE          = 2;
  OUT_OF_ORDER       = 3;
  INVALID_TARGET     = 4;
  PROTOCOL_MISMATCH  = 5;
}

message IntentEnvelope {
  bytes  client_cmd_id    = 1;  // UUIDv7 (16 bytes)
  bytes  intent_id        = 2;  // server-assigned UUIDv7
  string player_id        = 3;
  uint64 client_seq       = 4;
  uint64 server_tick      = 5;  // set on ACCEPTED
  uint32 protocol_version = 6;  // major
  IntentPolicy policy     = 7;
  oneof payload {
    MoveToLocationIntent move   = 10;
    AttackIntent         attack = 11;
    BuildIntent          build  = 12;
  }
  reserved 8, 9, 13, 14, 15;
}

message LifecycleEvent {
  bytes  intent_id        = 1;
  bytes  client_cmd_id    = 2;
  string player_id        = 3;
  uint64 server_tick      = 4;     // emission tick
  LifecycleState state    = 5;
  LifecycleReason reason  = 6;
  uint32 protocol_version = 7;
}

message EventsStreamRecord {
  oneof record {
    LifecycleEvent lifecycle = 1;
    Delta          delta     = 2;  // your existing delta message
    // Metrics can be added later if needed
  }
}

// Payloads trimmed (transport fields deprecated for transition)
message MoveToLocationIntent {
  uint64 entity_id = 1;
  Vec2   target    = 2;
  string client_cmd_id = 3 [deprecated = true];
  string player_id     = 4 [deprecated = true];
}
```

