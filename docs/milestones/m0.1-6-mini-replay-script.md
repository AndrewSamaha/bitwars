This file expands on content in ./m0.1-intent-lifecycle.md

# M0.1 - Step 6) Mini Replay Script
- Pull core game logic out into separate crate
- create a script/path that reads the 
This file provides additional detail on implementing a mini replay script.
A significant bulk of the work is refactoring the game engine to pull the core
simulation logic into a separate crate (sim). The rational is that having the core
logic in a separate crate will all us to run the simulation offline (without writing
to redis) and compare the results of intents created in game to those offline
to detect regressions. Given the goal, it would be easy for this to grow in
complexity. Therefore it is essential that we work towards the smallest
viable in-memory engine.

# Smallest viable in-memory engine (no big refactor)

## Goal

Run the exact movement/intent logic **without Redis or network**, so the replay tool can step ticks and compare hashes.

## Plan (≈6–10 touch points)

1. **Extract core sim into a crate**

```
services/rts-engine/
  crates/sim/                 # NEW
    src/{lib.rs, state.rs, intent.rs, systems.rs}
  src/engine/{...}            # existing server glue stays
```

2. **Define a tiny API**

```rust
// crates/sim/src/lib.rs
pub struct WorldState { /* entities, components */ }
pub struct Engine {
  pub state: WorldState,
}
impl Engine {
  pub fn from_snapshot(snap: WorldState) -> Self { /*...*/ }
  pub fn accept(&mut self, env: IntentEnvelope) -> Result<(), Reject>;
  pub fn tick(&mut self) { systems::movement(&mut self.state); /* etc */ }
}
```

3. **Reuse logic**
   Move the existing movement system and `apply_move_intent` into `crates/sim::systems/` and `crates/sim::intent::apply(...)`. Call the same code from the server path to avoid drift.

4. **World (de)serialization**
   Add `sim::codec::{from_snapshot_proto, to_sorted_json}` to build/load state and to produce the **stable, sorted JSON** used for `xxh3`.

5. **Feature-gate server**
   Server keeps using Redis; it calls into `sim::Engine` for `accept` and `tick` so logic is shared.

6. **Replay binary (headless)**

```
services/rts-engine/src/bin/replay.rs  # NEW
```

Reads snapshot + ACCEPTED lifecycle intents, builds `sim::Engine`, injects intents on the recorded accept tick, steps `tick()`, outputs `xxh3` + minimal diff.

7. **Library tests**
   Add deterministic tests in `crates/sim/tests/` to prove idempotency and replay equality.

---

## Minimal code skeletons

```rust
// crates/sim/src/state.rs
#[derive(Clone)]
pub struct WorldState { /* components */ }

// crates/sim/src/intent.rs
pub fn apply_move_intent(state: &mut WorldState, env: &IntentEnvelope) -> Result<(), Reject> { /* existing logic */ }

// crates/sim/src/systems.rs
pub fn movement(state: &mut WorldState) { /* existing per-tick movement */ }
```

```rust
// services/rts-engine/src/engine/intent.rs (server path)
fn handle_envelope(&mut self, env: IntentEnvelope) {
  // ...policy, dedupe, lifecycle...
  sim::intent::apply_move_intent(&mut self.state, &env).unwrap();
}
```

```rust
// src/bin/replay.rs (headless)
fn main() -> anyhow::Result<()> {
  let snap = load_snapshot(match_id)?;
  let mut eng = sim::Engine::from_snapshot(sim::codec::from_snapshot_proto(snap)?);
  for (tick, env) in accepted_envelopes_sorted()? {
    while eng.state.tick < tick { eng.tick(); }
    eng.accept(env)?;
  }
  while !done() { eng.tick(); }
  let hash = xxh3(sim::codec::to_sorted_json(&eng.state));
  write_report(hash)?;
  Ok(())
}
```

