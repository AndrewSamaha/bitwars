# M5.1 Client Camera — Approach Validation

This document validates the M5.1 Client camera approach against the codebase and captures additional complexity and dependencies. No code changes.

---

## 1. Approach recap

- **Single source of transform:** Treat `worldContainer` as the camera; all pan/zoom by updating its position (and optionally scale). Keep using `worldContainer.toLocal(global)` for screen→world so click-to-move and selection stay correct.
- **WASD panning:** Key listener for W/A/S/D (and optionally arrows); update `worldContainer.position` each frame (velocity or fixed step).
- **World coords on screen:** HUD element showing world (x, y), derived from pointer using the same screen→world path.
- **Preserving click targeting:** Do not change existing move/selection logic; only change where the transform is applied.

---

## 2. Validated assumptions

| Assumption | Status | Evidence |
|------------|--------|----------|
| Click-to-move uses world space via `worldContainer.toLocal(global)` | **Correct** | `GameStage.tsx` L259–261: `ground.on('pointerdown')` uses `ev.global` and `worldContainer.toLocal(global)`; result passed to `intentQueue.handleMoveCommand(..., { x, y })`. |
| Only one container holds the world transform | **Correct** | Single `worldContainer` at L59–62; position (800, 500), scale 0.5; ground, waypoints, and entity containers are children. Moving only this container preserves the single transform for all hit-testing and rendering. |
| Panning by updating that container keeps `toLocal` correct | **Correct** | Pixi’s `toLocal` inverts the container’s world transform. Changing `worldContainer.position` (and scale, if used) is exactly that; no second code path needed. |
| Waypoints and entities move with the world | **Correct** | `waypointContainer` and entity sprites are children of `worldContainer`; no extra logic needed when panning. |
| Tooltip positioning survives pan | **Correct** | `TooltipOverlay` uses `hoveredEntity.pixiContainer.toGlobal(...)`; entities are in `worldContainer`, so their screen position updates with pan. No change required. |

---

## 3. Additional complexity and dependencies

### 3.1 Where `worldContainer` lives and who needs it

- **Current:** `worldContainer` is created inside `initWorld()` and is only in closure scope. Ground click and `render()` use it; nothing else has a reference.
- **For M5.1:**
  - **Pan:** Must update `worldContainer.position` every frame (or on key repeat). That logic must run in the same closure (e.g. inside the existing `app.ticker` callback) or receive a ref to `worldContainer`. So panning naturally stays inside `GameStage`’s init.
  - **World coords HUD:** Need to show “world (x, y)” for the cursor (and optionally for a fixed point like screen center). That implies:
    - Cursor position in screen space (DOM or Pixi),
    - Conversion screen → world via the same transform as click-to-move.

- **Dependency:** Anything outside `GameStage` that needs “current view” or “screen→world” (e.g. a coords overlay component, and later the minimap) must get either:
  - **A)** A reference to `worldContainer` (or a wrapper that exposes position/scale + `toLocal`), or  
  - **B)** Pre-computed values (e.g. cursor world position) pushed into state/context from inside `GameStage`.

- **Implication:** If we keep `worldContainer` private to `GameStage`, the “world coords” UI must either live inside `GameStage` (sibling of the canvas in the same component, fed by state/ref updated on pointermove) or receive cursor world position from context. For **M5.3 Minimap**, viewport bounds in world space are required (camera position + scale + screen size). So the view transform will eventually need to be shared. **Recommendation:** Plan to expose the pannable container (or a thin view-state) as the “camera” so that both coords overlay and minimap can derive world from screen without duplicating logic. Today `setCamera(app.stage)`; switching to `setCamera(worldContainer)` is safe because no consumer currently uses `state.camera` for logic—only type and storage exist.

### 3.2 Keyboard focus and WASD

- **Current:** One `window` keydown listener in `GameStage` (L75–84) handles M (Move), Escape (clear action). No focus check.
- **Risk:** Terminal panel has an `<input>` that can be focused. If WASD are handled at `window` level, W/A/S/D would both pan the camera and type into the input.
- **Dependency:** Before applying WASD (and optionally arrow keys), check that focus is not in an editable field, e.g.  
  `if (document.activeElement instanceof HTMLInputElement || document.activeElement instanceof HTMLTextAreaElement) return;`  
  Same pattern can be applied in the existing keydown handler (e.g. extend it for WASD) so M/Escape and WASD share one focus guard.

### 3.3 World coords overlay: getting pointer position and screen→world

- **Option A – Coords inside GameStage:** A small overlay div (e.g. corner) rendered inside `GameStage`’s return, with pointermove on the same wrapper that contains the canvas. In the handler we have `worldContainer` in closure; we get pointer in Pixi global (from the event that Pixi might emit, or from DOM `clientX/clientY` + canvas bounds + resolution). Then `worldContainer.toLocal(global)` gives world; store in state or ref and show in the overlay. No need to expose `worldContainer` for this only.
- **Option B – Coords as sibling component:** A HUD component (e.g. next to TerminalPanel) that shows world coords. It needs (1) pointer position in screen space, (2) screen→world. For (2) it needs the same transform as click-to-move. So either:
  - **B1:** Context holds “camera” = `worldContainer` and a way to convert (screenX, screenY) → world. Screen position must be supplied from the canvas (e.g. GameStage dispatches pointermove to context: `cursorScreenX/Y` or `cursorWorldX/Y`). If we store screen, the coords component needs to convert screen→world: it must map DOM (clientX, clientY) to Pixi global, then `camera.toLocal(global)`. That requires canvas element, app resolution, and camera—so a small shared helper (e.g. `clientToWorld(app, camera, clientX, clientY)`) and camera in context.  
  - **B2:** GameStage pushes `cursorWorldX/Y` into context on pointermove; coords component only displays them. Then we don’t need to expose camera for coords, but we do need to ensure pointermove is attached (e.g. on the canvas wrapper) and that we’re not missing events when the pointer is outside the canvas.

- **Complexity:** DOM pointer events give `clientX/clientY`. Pixi’s `ev.global` is in its own coordinate system (stage space, affected by resolution). So any code that converts “DOM pointer → world” outside of a Pixi event callback must implement “client (clientX, clientY) → Pixi global” using canvas `getBoundingClientRect()` and renderer resolution (or equivalent). This is a small but explicit dependency; either centralize it in one helper or keep all such logic inside GameStage (Option A).

### 3.4 Resize behavior

- **Current:** `app.init({ resizeTo: window })`; canvas resizes with the window. `worldContainer` stays at fixed (800, 500) and scale 0.5. So the “center” of the view in world terms is fixed in canvas space; on resize, more or less world is visible but the camera doesn’t re-center.
- **For M5.1:** The approach doesn’t require changing this. Optional follow-up: on resize, adjust initial or current camera so that “world center” or “current view center” stays sensible (e.g. center world in view on first load). Not a blocker; just a note.

### 3.5 Semantic of “camera” in HUD state

- **Current:** `setCamera(app.stage)`; `camera` in state is the stage (root). Nothing in the app reads `selectors.camera` for behavior; only `TooltipOverlay` uses `app` (for resolution), and `EntityDetailPanel` uses `app` (for ticker).
- **Change:** If we call `setCamera(worldContainer)` instead, no existing behavior breaks. Then “camera” becomes the pannable view transform, which is what the minimap and any shared screen→world helper will need. So switching to `worldContainer` is a low-risk, forward-looking choice.

### 3.6 Pan speed and frame rate

- **Approach:** “Tune pan speed”; “consider making speed configurable (e.g. constant or scaled by delta time)”.
- **Dependency:** Use the same ticker that already runs `game.tick()` and `render()` so pan is applied once per frame. Multiply pan offset by `dt` (delta time) so speed is independent of frame rate; otherwise pan would be faster on high-FPS machines.

---

## 4. Summary of dependencies (no code)

| Item | Dependency / complexity |
|------|-------------------------|
| **Single transform** | Keep all pan/zoom on `worldContainer`; no second transform path. Validated. |
| **WASD** | Add key handling in same place as M/Escape; **must skip when focus is in &lt;input&gt; or &lt;textarea&gt;**. Use delta-time–based pan so speed is frame-rate independent. |
| **World coords HUD** | Need pointer position + screen→world. Either (A) do both inside GameStage and pass world coords to a small overlay, or (B) expose `worldContainer` as camera and implement client→Pixi global→world (canvas bounds + resolution) for use by a sibling component. |
| **Exposing camera** | No current consumer of `state.camera`. Safe to set `camera` to `worldContainer` for future use (minimap, shared screen→world). |
| **Resize** | No change required for M5.1; optional later: adjust camera on resize for a better default view. |
| **Tooltip / waypoints / ground** | No extra work; they already live under the same transform. |

---

## 5. Acceptance criteria check

- **“Panning does not break click targeting (move/selection still land in correct world coordinates).”**  
  Satisfied if: (1) only `worldContainer` position/scale change for pan, and (2) ground click and entity click keep using `worldContainer.toLocal(ev.global)` (or equivalent). No other code path for screen→world.

- **World coords on screen**  
  Satisfied if the displayed (x, y) is computed with the same screen→world used for clicks (and focus/input guard is in place so WASD doesn’t type in the terminal).

No server or schema changes required for M5.1.
