This file expands on content in ./m0.1-intent-lifecycle.md

# M0.1 - Step 6) Mini Replay Tests (`pnpm test:replay:x`)

This file provides additional detail on implementing **named replay tests** invoked as `pnpm test:replay:x`, where **x** is the name of a test scenario.

Each **named test x** includes:
- **Beginning world state** — initial snapshot or in-memory state
- **Entities** — a small set of entities in that world
- **Predefined intents** — a fixed sequence of intents (and the ticks at which they are accepted)
- **Predefined number of ticks** — how many ticks to run before asserting the final state

Tests run **server-side** (unit/integration) against an in-memory engine; **no Redis** is required. The goal is to assert a stable final world hash (e.g. via xxh3 over sorted JSON) so that determinism and regressions can be validated.

A significant bulk of the work is refactoring the game engine to pull the core simulation logic into a separate crate (sim). The rationale is that having the core logic in a separate crate allows running the simulation offline (without writing to Redis) and comparing results to detect regressions. Given the goal, it would be easy for this to grow in complexity. Therefore it is essential that we work towards the **smallest viable in-memory engine**.

# Smallest viable in-memory engine (no big refactor)

## Goal

Run the exact movement/intent logic **without Redis or network**, so the replay tool can step ticks and compare hashes.

## Plan (≈6–10 touch points)

1. **Extract core sim into a crate**

```
services/rts-engine/
  crates/sim/                 # NEW
    src/{lib.rs, state.rs, intent.rs, systems.rs}
  src/engine/{...}            # existing server glue stays
```

2. **Define a tiny API**

```rust
// crates/sim/src/lib.rs
pub struct WorldState { /* entities, components */ }
pub struct Engine {
  pub state: WorldState,
}
impl Engine {
  pub fn from_snapshot(snap: WorldState) -> Self { /*...*/ }
  pub fn accept(&mut self, env: IntentEnvelope) -> Result<(), Reject>;
  pub fn tick(&mut self) { systems::movement(&mut self.state); /* etc */ }
}
```

3. **Reuse logic**
   Move the existing movement system and `apply_move_intent` into `crates/sim::systems/` and `crates/sim::intent::apply(...)`. Call the same code from the server path to avoid drift.

4. **World (de)serialization**
   Add `sim::codec::{from_snapshot_proto, to_sorted_json}` to build/load state and to produce the **stable, sorted JSON** used for `xxh3`.

5. **Feature-gate server**
   Server keeps using Redis; it calls into `sim::Engine` for `accept` and `tick` so logic is shared.

6. **Named replay tests (`pnpm test:replay:x`)**

   Each test **x** is a scenario: beginning world state + entities + predefined intents + predefined tick count. The test runner (script or Rust binary) builds `sim::Engine` from the scenario, injects intents at the specified ticks, runs `tick()` for the predefined number of ticks, and asserts the final world hash (e.g. `xxh3` over stable JSON). On mismatch: print minimal diff and exit non-zero. No Redis.

   Optionally, a headless binary (e.g. `services/rts-engine/src/bin/replay.rs`) can load scenario data from files and be invoked by the test runner.

7. **Library tests**
   Add deterministic tests in `crates/sim/tests/` to prove idempotency and replay equality; these can double as or feed into named replay scenarios.

---

## Minimal code skeletons

```rust
// crates/sim/src/state.rs
#[derive(Clone)]
pub struct WorldState { /* components */ }

// crates/sim/src/intent.rs
pub fn apply_move_intent(state: &mut WorldState, env: &IntentEnvelope) -> Result<(), Reject> { /* existing logic */ }

// crates/sim/src/systems.rs
pub fn movement(state: &mut WorldState) { /* existing per-tick movement */ }
```

```rust
// services/rts-engine/src/engine/intent.rs (server path)
fn handle_envelope(&mut self, env: IntentEnvelope) {
  // ...policy, dedupe, lifecycle...
  sim::intent::apply_move_intent(&mut self.state, &env).unwrap();
}
```

```rust
// src/bin/replay.rs (headless)
fn main() -> anyhow::Result<()> {
  let snap = load_snapshot(match_id)?;
  let mut eng = sim::Engine::from_snapshot(sim::codec::from_snapshot_proto(snap)?);
  for (tick, env) in accepted_envelopes_sorted()? {
    while eng.state.tick < tick { eng.tick(); }
    eng.accept(env)?;
  }
  while !done() { eng.tick(); }
  let hash = xxh3(sim::codec::to_sorted_json(&eng.state));
  write_report(hash)?;
  Ok(())
}
```

---

## Implementation Summary

The milestone deliverable is **named replay tests** invoked as `pnpm test:replay:x` (each **x** = beginning world state + entities + predefined intents + predefined ticks; server-side, no Redis). The following was accomplished to support that:

### ✅ Core Simulation Crate (`crates/sim/`)
- **Extracted core simulation logic** into a separate `sim` crate
- **Created modular structure** with `lib.rs`, `state.rs`, `intent.rs`, `systems.rs`, and `codec.rs`
- **Implemented WorldState** with entities and components using protobuf types
- **Built Engine API** with `from_snapshot()`, `accept()`, and `tick()` methods
- **Added serialization support** with `from_snapshot_proto()` and `to_sorted_json()` for stable hashing

### ✅ Intent Processing
- **Moved movement system** and `apply_move_intent()` logic into the sim crate
- **Reused existing protobuf types** from the main engine
- **Implemented intent application** for Move, Attack, and Build intents

### ✅ Replay Binary (`src/bin/replay.rs`)
- **Created headless replay tool** that can run without Redis or network
- **Loads snapshots** from protobuf files
- **Processes intent envelopes** from files
- **Runs simulation ticks** and generates stable JSON hashes
- **Uses xxh3 hashing** for deterministic state comparison

### ✅ Deterministic Testing
- **Added comprehensive tests** in `crates/sim/tests/determinism.rs`
- **Verified idempotency** - same operations produce identical results
- **Tested deterministic replay** - identical inputs produce identical outputs
- **Validated stable JSON serialization** - entities are sorted by ID for consistent hashing

### ✅ Integration
- **Updated workspace** to include the sim crate
- **Added dependencies** for xxhash-rust with xxh3 feature
- **Maintained compatibility** with existing protobuf types
- **Ensured compilation** of both sim crate and main engine

### Key Features Implemented:

1. **Smallest viable in-memory engine** - No Redis or network dependencies
2. **Stable serialization** - Sorted JSON output for consistent hashing
3. **Deterministic replay** - Same inputs always produce same outputs
4. **Modular design** - Core logic separated from server infrastructure
5. **Comprehensive testing** - Idempotency and replay equality verified

The implementation follows the milestone's goal of creating a minimal, deterministic simulation engine that can be used for replay testing and regression detection. The sim crate provides a clean API that can be used both by the main server engine and the standalone replay tool.

---

## How to Run the Replay Tests

The milestone defines **named replay tests** as `pnpm test:replay:x`, where **x** is a scenario name (beginning world state + entities + predefined intents + predefined tick count).

### Named replay tests (`pnpm test:replay:x`)

From the repo root:

```bash
pnpm test:replay:two_entities_move
```

This runs the Rust binary `replay_test` with scenario `two_entities_move`: two entities, one move intent at tick 0, 20 ticks total; asserts final world hash (xxh3). On mismatch, prints a minimal diff (first differing entity id + fields) and exits non-zero.

To add a new scenario: define it in `services/rts-engine/src/bin/replay_test.rs` (in `scenarios()`), run `cargo run -p rts-engine --bin replay_test -- <name> --golden` to print expected hash and JSON, paste them into the scenario, then add a script in root `package.json`: `"test:replay:<name>": "cargo run -p rts-engine --bin replay_test -- <name>"`.

### 1. Run the Deterministic Tests (Unit Tests)
```bash
cd services/rts-engine
cargo test --package sim --test determinism
```

This runs the three deterministic tests:
- `test_deterministic_replay` - Verifies identical inputs produce identical outputs
- `test_idempotent_operations` - Ensures same operations produce identical results
- `test_stable_json_serialization` - Validates entities are sorted by ID for consistent hashing

### 2. Run the Replay Binary with Test Data
```bash
cd services/rts-engine
cargo run --bin replay ../../packages/schemas/testdata/snapshot.bin
```

This loads a snapshot with 2 entities and runs the simulation for 10 ticks, outputting:
- Final state hash (using xxh3)
- Final JSON state with entity positions and velocities

### 3. Run All Tests (Including Replay Tests)
```bash
cd services/rts-engine
cargo test
```

This runs all tests including the deterministic replay tests and other engine tests.

### 4. Optional: Run with Intent Files
If you have intent files, you can run:
```bash
cd services/rts-engine
cargo run --bin replay ../../packages/schemas/testdata/snapshot.bin [intent_file1.bin] [intent_file2.bin]
```

The replay binary accepts:
- First argument: snapshot file (required)
- Additional arguments: intent files (optional)

### Test Data Available
The test data is located in `packages/schemas/testdata/` and includes:
- `snapshot.bin` - Contains 2 entities at tick 42
- `delta.bin` - Contains entity updates
- Various other test files for different scenarios

### Expected Output
When you run the replay binary, you should see:
- "Loaded snapshot with 2 entities at tick 42"
- "Final state hash: [hex value]"
- "Final JSON: [sorted JSON with entity states]"

The tests verify that the simulation is deterministic and produces stable, consistent results for regression testing.

### 5. Extract Real Game Data from Redis
```bash
cd services/rts-engine
cargo run --bin redis_to_files <game_id> <time1> <time2> [output_dir] [time_window_seconds]
```

This tool reads gamestate from Redis at two points in time and outputs them to files for ingestion by the offline replay engine. It enables you to:

- **Extract real game data** from Redis at specific timestamps
- **Use Redis data as source-of-truth** for validation
- **Compare offline simulation results** against actual Redis state
- **Create test fixtures** from real game sessions

Example:
```bash
# Extract data from now and 1 hour ago
cargo run --bin redis_to_files demo-001 now 1640995200

# Use extracted data with replay engine
cargo run --bin replay ./redis_data/time1_snapshot.bin ./redis_data/time1_intents.bin
```

For detailed usage instructions, see [redis-to-files.md](../tools/redis-to-files.md).

